{"/Pico_RP2040_doc/en/index.html": {"title": "【 BPI-Pico-RP2040 Development Board 】", "content": "# 【 BPI-Pico-RP2040 Development Board 】\n\n## introduce\n\n![](assets/images/BPI-Pico-RP2040_banner.png)\n\nThe Banana Pi Pico series is a low-power microcontroller development board designed for the Internet of Things.\n\nBPI-Pico-RP2040 is a microcontroller development board launched by Banana Pi equipped with RP2040 chip. Its most notable feature is to add a Onboard WS2812 color LED; replace the 3-Pin DEBUG interface with a JST SH 1mm 4-Pin socket, which can be connected with Qwiic & STEMMA QT or any possible peripherals; replace the micro-USB socket with a USB Type-C socket , supports reversible insertion, and is compatible with the USB Type-C cable of most modern smartphones, no additional purchase is required.\n\nJump to [Unboxing BPI-Pico-RP2040 Development Board](Unboxing/Introduction.html) page for details.\n\n## Programming with MicroPython\n\n![](assets/images/Mircopython.png)\n\nRegardless of the programmer is a beginner or not, MicroPython is considered to be less difficult to develop than other MCU programming languages.\n\nIts code is easy to understand compared to other programming languages, and it has various resources accumulated over the years by the open source community.\n\nJust like Python, it has strong vitality and application value.\n\nBy uploading the MicroPython firmware, you can use the Python language to program in the development board.\n\n## Programming with CircuitPython\n\n![](assets/images/CircuitPython_Repo_header_logo.jpg)\n\nCircuitPython is a programming language designed to simplify programming experiments and learning on microcontroller development boards.\n\nCircuitPython programming with the Mu editor is the least difficult way to get started. Install the software and connect the device to start using it.\n\n## Programming with Arduino\n\n![](assets/images/Arduino_logo_1200x350.png)\n\nProvides software tools and best examples to get started with Arduino, lowering the barrier to entry for ESP32 embedded professional development.\n\n>Arduino will not explain too much basic content, please have C/C++ language development foundation.\n\n## Reference Resources\n\n- [Official WIKI](https://wiki.banana-pi.org/BPI-Pico-RP2040)\n\n- [GitHub: BPI-Pico-RP2040 Development Board Schematic PDF](https://github.com/BPI-STEAM/BPI-Pico-RP2040-Doc/blob/main/BPI-Pico-RP2040-V0.2-SCH.pdf)\n\n- [rp2040-datasheet.pdf](https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf)\n\n- [rp2040-product-brief.pdf](https://datasheets.raspberrypi.com/rp2040/rp2040-product-brief.pdf)\n\n## Sample Purchase\n\n- [Official AliExpress]()\n\n- [Official Taobao]()\n\n- OEM&OEM customized service: sales@banana-pi.com"}, "/Pico_RP2040_doc/en/Unboxing/Introduction.html": {"title": "Development board introduction", "content": "# Development board introduction\nThe Banana Pi Pico series is a low-power microcontroller development board designed for the Internet of Things.\n\nBPI-Pico-RP2040 is a microcontroller development board launched by Banana Pi equipped with RP2040 chip. Its most notable feature is to add a Onboard WS2812 color LED; replace the 3-Pin DEBUG interface with a JST SH 1mm 4-Pin socket, which can be connected with Qwiic & STEMMA QT or any possible peripherals; replace the micro-USB socket with a USB Type-C socket , supports reversible insertion, and is compatible with the USB Type-C cable of most modern smartphones, no additional purchase is required.\n\n## Key Features\n\n- Dual-core ARM Cortex M0+ CPU cores (up to 133 MHz)\n- 264K SRAM\n- 2MB Flash\n- 26 available GPIO pins, 4 of which support ADC analog input\n- Peripherals:\n  - 2 x UARTs\n  - 2 × SPI controllers\n  - 2 × I2C controllers\n  - 16 × PWM channels\n  - 1 × USB 1.1 controller and PHY, supporting host and device\n  - 8 × PIO state machines\n- 1 x LED\n- 1 x WS2812 LED\n- 1 × JST SH 1mm 4-Pin socket\n- 1 × USB Type-C socket\n\n## hardware\n\n### Interface diagram\n\n![](../assets/images/BPI-Pico-RP2040-V0.2-IO.jpg)\n\n### Hardware Dimensions\n\n![](../assets/images/BPI-Pico-RP2040-V0.2-dimension.jpg)\n\n<table>\n   <tr>\n      <td>BPI-Pico-RP2040 Size Chart</td>\n   </tr>\n   <tr>\n      <td>Pin spacing</td>\n      <td>2.54mm</td>\n   </tr>\n   <tr>\n      <td>Mounting hole spacing</td>\n      <td>17.6mm/ 11.4mm</td>\n   </tr>\n   <tr>\n      <td>Mounting hole size</td>\n      <td>Inner diameter 2.1mm/outer diameter 3.4mm</td>\n   </tr>\n   <tr>\n      <td>Motherboard Dimensions</td>\n      <td>11.4 × 55.8(mm)</td>\n   </tr>\n   <tr>\n      <td>Board thickness</td>\n      <td>1.2mm</td>\n   </tr>\n   <tr>\n      <td></td>\n   </tr>\n</table>\n\nThe pin spacing is compatible with universal boards (perforated boards, dot matrix boards), breadboards, and can be directly attached to other PCBs for easy debugging.\n\n\n## References and Resources\n\n- [GitHub: BPI-Pico-RP2040 Development Board Schematic PDF]()\n\n- [RP2040 Technical Specification](https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf)\n\n- [RP2040 Technical Reference Manual](https://datasheets.raspberrypi.com/rp2040/hardware-design-with-rp2040.pdf)\n\n- [rp2040-product-brief.pdf](https://datasheets.raspberrypi.com/rp2040/rp2040-product-brief.pdf)\n\n- [raspberry-pi-pico-python-sdk.pdf](https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-python-sdk.pdf)"}, "/Pico_RP2040_doc/en/Programming/MicroPython_Gettingstart.html": {"title": "", "content": "## MicroPython firmware download and burn\n\nOn the [MicroPython official website] (https://micropython.org/), you can find the firmware supporting the RP2040 chip. The BPI-Pico-RP2040 is fully compatible with the firmware of the Raspberry Pi Pico: https://micropython.org/download/rp2-pico/\n\nAfter clicking the link to enter the page, you can see several lists of firmware download addresses below. It is recommended to select the first item in the Releases column to download, taking into account stability and new features. Subsequent routines are written based on v1.19.1 firmware.\n\n![](../assets/images/micropython_env_1.png)\n\nThe firmware provided in the Nightly builds column is a daily build and will have the latest features, but the stability may be slightly poorer, and there may be no documentation for the latest features.\n\nAfter the download is complete, you will get a file with a .uf2 extension. The way to burn it to the BPI-Pico-RP2040 development board is very simple. First, make sure there is a type-c data cable, connect one end to the PC, pick up the development board, Keep the above without any connection or peripheral hardware, press and hold the Boot button, connect the type-c data cable to the development board, release the Boot button, a new disk named RPI-RP2 will appear in the PC system, and the .uf2 The files are copied to this disk. After the copy is completed, the development board will automatically reset and enter the MicroPython mode.\n\n## Install Thonny IDE\n\nTake Windows as an example, click the link to download [thonny-3.3.13.zip](../assets/images/thonny-3.3.13.zip), and get `thonny-3.3.13.exe` after decompression.\n\nRun `thonny-3.3.13.exe`, and follow the installation prompts to complete the installation step by step.\n\nIt can also be installed through pip, `pip install thonny==3.3.13`, requires [Python](https://www.python.org/) environment, suitable for macOS or Linux.\n\n## Establish a connection between the development board and Thonny\n\nConnect the development board to the computer.\n\nTo run Thonny, click Run > Select interpreter.\n![](../assets/images/micropython_env_2.png)\n\nSelect MicroPython(Raspberry Pi Pico).\n![](../assets/images/micropython_env_3.png)\n\nSelect the serial interface where the development board is located, and click OK to confirm the settings.\n![](../assets/images/micropython_env_4.png)\n\nCheck View > Files to open the file management bar.\n![](../assets/images/micropython_env_5.png)\n\n## Use the REPL to output Hello World\n\n**REPL** is the abbreviation of **Read-Eval-Print-Loop**, translated as **Read-Eval-Output-Loop**.\n\nWe can understand its meaning through practical operation.\n\nAfter connecting the development board with MicroPython firmware installed to the computer, running Thonny IDE and configuring it correctly, the following text will appear in the Shell window:\n\n```\nMicroPython v1.19.1 on 2022-06-18; Raspberry Pi Pico with RP2040\nType \"help()\" for more information.\n>>>\n```\n\nPay attention to the `>>>` prompt on the last line, we can directly enter the formula or code after this, and press the `enter` key on the keyboard to get the output result in the next line immediately.\n\n```python\n>>> 1+2\n3\n>>> print(\"Hello World\")\nhello world\n>>>\n```\n\nNow it can be understood very intuitively. It will read the information we input, perform calculation and evaluation, output the result, and then wait for our subsequent input, and keep looping this process. This is why **REPL** is translated into ** The reason for the interactive interpreter is that we can directly interact with the hardware by inputting codes. There is no need to execute the compilation process in the middle like the traditional C language. The information we input is transmitted to the chip for interpretation and operation without compilation. Yes, this is an important feature of the Python language, and MicroPython perfectly inherits it.\n\nIf you just use MicroPython REPL, many software with serial port information sending and receiving functions can be operated. If you are interested, you can try various serial port tools, which can give people a deeper understanding of the meaning of \"there is no intermediate compilation process\".\n\n>About the application of REPL, more detailed and comprehensive content can refer to [MicroPython Documentation: REPL](https://docs.micropython.org/en/latest/reference/repl.html)\n\n## code editor\n\nOf course, Thonny IDE can not only perform REPL operations, but as a python code editor, it still has its own functions.\n\nCreate a new file and enter the code in its editing area.\n\n```python\nprint(1+2)\nprint(\"Hello World\")\n```\n\nAfter finishing the code editing, click **Save**, you can choose to save the file to the development board, which will directly transfer the entire file to the flash of the development board. You can name the file `main.py`, and the device will execute it after each power-on or reset.\n\n![](../assets/images/Quick_Start.png)\n\nNow click **Run current script** to run. It also does not need to be compiled, and the result will be obtained immediately in the Shell.\n\n```\n3\nhello world\n```\n\nIn addition, you can also try the REPL keyboard shortcut **ctrl+D** software reset, you can see that the program is executed immediately after the reset and prints out the information.\n\n## Turn on the LED\n\nThe onboard LED on the BPI-Pico-RP2040 is connected to GPIO 25 pin, you can light it on the REPL. When you see the REPL prompt `>>>`, please enter the following code.\n```python\n>>> from machine import Pin\n>>> led = Pin(25, Pin.OUT)\n```\n> The `machine` module is used to control the hardware on the development board. This is standard across all MicroPython ports, and you can learn more about it in the [MicroPython documentation: machine](https://docs.micropython.org/en/v1.19.1/library/machine.html).\n\nEnter the following code and the LED will light up.\n```python\n>>> led. value(1)\n```\n\nEntering the following code will turn off the LED.\n```python\n>>> led. value(0)\n```\n\n## Use onboard lights\n\nThe onboard WS2812 colored light on BPI-Pico-RP2040 is connected to GPIO 3 pin, it only needs one signal line to control, enter the following code in REPL.\n```python\n>>> from machine import Pin\n>>> from neopixel import NeoPixel\n>>> neo = NeoPixel(Pin(3), 1)\n```\n> The `neopixel` module provides drivers for WS2812 colored lights. You can learn more about it in the [MicroPython documentation: neopixel](https://docs.micropython.org/en/v1.19.1/library/neopixel.html).\nEnter the code below and the colored light will light up red.\n```python\n>>> neo[0] = (25,0,0)\n>>> neo.write()\n```\n`neo[0] = (25,0,0)` sets the color of the first lantern.\n\nThere are three solid-color LEDs in the WS2812 lantern, and their colors are red, green, and blue. The elements in the `(25,0,0)` tuple control their brightness in turn, and the value range is 0 ~ 255. The value of the element The bigger it is, the brighter the solid color LED it controls.\nIt is recommended to control the value of the element below 50. When the value is too high, it will be dazzling when viewed directly at close range.\n\nAfter `neo.write()` is executed, the chip will transmit the control signal to the onboard WS2812 lantern.\n\nYou can try to modify the data in the tuple yourself to control the color of the colored lights. For example, continue to enter the following code in the REPL to make the colored lights white.\n```python\n>>> neo[0] = (25,25,25)\n>>> neo.write()\n```\n\n## Reference Resources\n- [raspberry-pi-pico-python-sdk.pdf](https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-python-sdk.pdf)"}, "/Pico_RP2040_doc/en/Programming/Arduino_Gettingstart.html": {"title": "", "content": "## Arduino download and install\n\nArduino IDE download link: https://www.arduino.cc/en/software\n\nSelect the version corresponding to the operating system to download, and follow the installation prompts to install step by step.\n\n## Install RP2040 development board support package\n\nTake Arduino IDE 2.0.2 as an example, enter `PICO` or `RP2040` in the search bar of the Boards Manager, select `Arduino Mbed OS RP2040 Boards`, click `Install` to install the RP2040 development board support package, and the latest version is installed by default That's it.\n\n![](../assets/images/arduino_env_1.png)\n\n## Set the board type\n\nIn the upper option bar, click Tools > Boards > Arduino Mbed OS RP2040 Boards > Raspberry Pico.\n\n![](../assets/images/arduino_env_2.png)\n\n## Connect to the development board\n\nWhen using Arduino on the BPI-Pico-RP2040 development board for the first time, it is necessary to manually enter the development board into UF2 Bootloader mode, and this step can usually be avoided later.\n\nMake sure there is a type-c data cable, one end is connected to the PC, pick up the development board, keep it free of any connection or peripheral hardware, press and hold the Boot button, connect the type-c data cable to the development board, release the Boot button, A new disk called RPI-RP2 will appear in the PC's system.\n\n## Turn on the LED\nIn the upper option bar, click File > Examples > 01.Basics > Blink to open the Blink example,\n\n![](../assets/images/arduino_env_3.png)\n\nOr directly enter the following code in the code editing area.\n\n```c\nvoid setup() {\n  // initialize digital pin LED_BUILTIN as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level)\n  delay(1000); // wait for a second\n  digitalWrite(LED_BUILTIN, LOW); // turn the LED off by making the voltage LOW\n  delay(1000); // wait for a second\n}\n\n```\n\nClick the `Upload` button, the program will be uploaded to the development board after the compilation is complete, and the onboard LED will blink at intervals of 1 second.\n\n## Reference Resources\n\n- [RP2040 Arduino documentation](https://arduino-pico.readthedocs.io/en/latest/)"}, "/Pico_RP2040_doc/en/no_translate.html": {"title": "no translation", "content": "---\ntitle: no translation\nclass: md_page\n---\n\n\n<div id=\"visit_from\"></div>\n<div id=\"no_translate_hint\">This page not translated yet</div>\n<div>\n    <span id=\"visit_hint\">Please visit</span>\n    <a id=\"translate_src\"></a>\n</div>\n\n<div>\n    <script>\n        function getQueryVariable(variable)\n        {\n            var query = window.location.search.substring(1);\n            var vars = query.split(\"&\");\n            for (var i=0;i<vars.length;i++) {\n                    var pair = vars[i].split(\"=\");\n                    if(pair[0] == variable){return pair[1];}\n            }\n            return(false);\n        }\n        var ref = getQueryVariable(\"ref\");\n        var from = getQueryVariable(\"from\");\n        var link = document.getElementById(\"translate_src\");\n        var fromDis = document.getElementById(\"visit_from\");\n        link.href = ref;\n        link.text = ref;\n        fromDis.innerHTML = from;\n    </script>\n</div>"}}