{"/PicoW_S3_doc/zh/Arduino/Basic.html": {"title": "板载资源的使用", "content": "# 板载资源的使用\n\n本章主要是通过一些示例项目，阐述 PicoW-S3 主控板的外设基本使用方法，通过下面的项目，您可以进行修改完成您的自己的项目。 \n其中 PicoW-S3 外设主要包括：UART、I2C、SPI、ADC、PWM、DAC等。 \n\n## 开始之前的准备\n\nBPI-PicoW-S3 开发板上的MicorUSB使用的是ESP32-S3的原生USB接口，而不是传统的USB转TLL芯片。\n\n为了让您的开发板能正确下载程序，您需要将BPI-PicoW-S3设置为下载模式，有以下两种方法：\n\n- 通过USB连接到电脑，使用镊子将BOOT短接，再按一下Reset键并松开，最后断开BOOT短接。\n\n- 在断开所有供电的状态下，将BOOT短接，然后将开发板插上电脑，最后断开BOOT短接。\n\n![](../assets/images/PicoW-BOOT.png)\n\n这时候可以在设备管理器中看到一个多的COM口\n\n![](../assets/images/Device_manager.jpg)\n\n在IDE中选择这个端口\n\n![](../assets/images/Device_manager_1.jpg)\n\n##  项目一 串口实验\n\n在最开始的章节中，我们上传了一个 Blink 闪烁程序来测试板子上的 LED 状态灯。现在，我们使用 UART 串口，每秒打印一次计时数据。\n\n### 所需元件\n\nPicoW-S3 主板 X 1\n\n![](../assets/images/PicoW-S3.png)\n\n### 硬件连接 \n\n此项目不需要其他传感器，所以只需要把PicoW-S3用USB连到电脑就能用。\n\n### 输入代码 \n\n打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 \n\n代码如下:  \n\n<details>\n<summary>展开查看</summary>\n\n<pre><code>\nvoid setup() \n{\n  Serial.begin(115200);         //设置串口通信波特率\n} \nvoid loop() \n{\n  static unsigned long i = 0;   //定义变量i\n  Serial.println(i++);          //i加一后输出i\n  delay(1000);                  //延时1秒\n} \n</code></pre>\n</details>\n\n输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE 会把代码发送给 PicoW-S3 主板。上传完成之后，你需要按一下复位键，这样代码就能正常运行了\n\n### 实验现象\n\n完成之前步骤的上传后，打开 Arduino IDE 自带的串口监视器，可以看到如下的打印信息： \n\n![](../assets/images/Lesson1-1.png)\n\n## 项目二 PWM(呼吸灯)\n\n呼吸灯，即让 PicoW-S3 通过 PWM 驱动 LED 灯，实现 LED 的亮度渐变，看起来就像是在呼吸一样。关于 PWM 的解释，请阅览知识扩展部分。 \n\n### 所需元件\n\nPicoW-S3 主板 X 1\n\n![](../assets/images/PicoW-S3.png)\n\nLED X 1 (建议串联一个电阻限流)\n\n![](../assets/images/led.png)\n\n### 硬件连接\n\n将LED连接到PicoW-S3的GPIO13就可以了，长的那个脚接GPIO13，短的接到GND\n\n### 输入代码 \n\n打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 \n代码如下: \n\n<details>\n<summary>展开查看</summary>\n\n<pre><code>\n#define LED_CHANNEL_0     0    //设置通道0 \n#define LED_TIMER_13_BIT  13   //设置13位定时器\n#define LED_BASE_FREQ     5000 //设置定时器频率位5000Hz \n#define LED_PIN            13  //设置LED灯 \n\nint brightness = 0;    // LED亮度\nint fadeAmount = 1;    // LED数量\n \n//设置led灯的亮度 \nvoid ledcAnalogWrite(uint32_t value, uint32_t valueMax = 255) { \n  //计算占空比 \n  uint32_t duty = (LED_BASE_FREQ / valueMax) * min(value, valueMax); \n  //设置占空比 \n  ledcWrite(LED_CHANNEL_0, duty); \n}  \nvoid setup() { \n  ledcSetup(LED_CHANNEL_0, LED_BASE_FREQ, LED_TIMER_13_BIT);   ledcAttachPin(LED_PIN, LED_CHANNEL_0); \n}  \nvoid loop() { \n  ledcAnalogWrite(brightness);   brightness += fadeAmount; \n \n  if (brightness <= 0 || brightness >= 255) { \n       fadeAmount = -fadeAmount; \n  }   \n  delay(30); \n}\n\n</code></pre>\n</details>\n\n输入完成后，点击“编译”按钮检查代码是否有错误。确定没有错误后可以开始上传了，点击“上传”按钮 。IDE 会把代码发送给 PicoW-S3 主板。上传完成后您就可以看见Type-C旁边的LED 灯开始“呼吸”了！\n现在让我们来回顾一下代码和硬件，看看它是如何工作。\n\n### 知识学习\n\n什么是 PWM 控制信号？ \n\nPWM（pulse-width modulation）脉冲宽度调制，MCU（微控制器）通过对开关器件的通断进行控制，使输出端得到一系列幅值相等的脉冲，用这些脉冲来代替正弦波或所需的波形。如下图所示：\n\n![](../assets/images/Lesson2-1.jpg)\n\n其中，tON 是高电平持续时间，tPWM 是 PWM 波的周期，tPWM-tON 是低电平持续时间，占空比是指高电平持续时间占整个周期的比例，即 D=ton/tPWM 。\n\n### 代码分析\n\nPicoW-S3 的 PWM 比普通的 Arduino UNO 高级的多，设置上不能简单的使用analogWrite 函数来驱动 PWM，而是需要设置 timer 函数，以及相关的频率参数等才能工作。 \n\n```\n#define LEDC_CHANNEL_0     0\n```\n\n定义了定时器使用的通道，PicoW-S3 总共有 16 个通道，这里用的是通道 0。\n\n```\n#define LEDC_TIMER_13_BIT  13\n```\n\n定义了定时器为 13 位定时器，即定时器最大计数为 2 的 13 次方。 \n\n```\n#define LEDC_BASE_FREQ     5000\n```\n\n这是设置定时器的频率，单位是 Hz。接下来的 brightness 和 fadeAmount 参数分别表示 PWM 的占空比和每次变化的数值。 \n\n```\nvoid ledcAnalogWrite(uint32_t value, uint32_t valueMax = 255)\n```\n\n这个函数是计算 PWM 占空比和设置 PWM 占空比，类似 Arduino 的 analogWrite 函数，可以看到，传递参数的最大值是 255，这是为了和 analogWrite 兼容。 \n\n```\nledcSetup(LEDC_CHANNEL_0, LEDC_BASE_FREQ, LEDC_TIMER_13_BIT); \n\t       ledcAttachPin(LED_PIN, LEDC_CHANNEL_0);\n```\n\n这两个函数是 PicoW-S3 定时器设置函数，函数原型及原理这里不讲述，如果您感兴趣可以看看底层源码（源码地址：C:\\Users\\“your-PC”\\AppData\\Local\\Arduino15\\packages\\esp32\\ hardware\\ adafruit_metro_esp32s2 \\0.0.3\\libraries\\ESP32\\），这里只需要知道怎么用这些函数来设置相关的 timer 就可以了。 \n\n关于什么是 PWM 信号，在前面已经阐述过了，这里不再说明。 \n\n>注意：PicoW-S3 的任何引脚都可以配置成 PWM 输出，您可以尝试着修改代码，完成您的项目。\n\n## 项目三 ADC \n\nADC（模数转换器即 A/D 转换器），是指将模拟信号转变成数字信号。PicoW-S3 的ADC 是13位的，最大输出值为 8191，而 Arduino UNO 是 10 位的，最大输出值是 1023，因此，在精度上比Arduino UNO 要高，而且转换速率快，且在使用上兼容 Arduino analogRead 函数，直接读取即可。\n\n### 所需元件 \n\n模拟角度传感器 X 1\n\n![](../assets/images/Lesson3-1.png)\n\n面包板 X 1\n\n![](../assets/images/Lesson3-2.png)\n\nPicoW-S3 主板 X 1\n\n![](../assets/images/PicoW-S3.png)\n\n### 硬件连接 \n\n 把 电位计插接到 PicoW-S3 主板上，然后将模拟角度传感器插接到 IO2（实验中用的是IO2）。  元件连接好后，使用 USB 线连接 PicoW-S3 和电脑。 \n\n ### 输入代码\n\n 打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。代码如下: \n\n<details>\n<summary>展开查看</summary>\n\n<pre><code>\n void setup() { \n  // put your setup code here, to run once: \n  Serial.begin(115200); \n}  \nvoid loop() { \n  // put your main code here, to run repeatedly:   \n  Serial.println(analogRead(2));  \n  delay(100); \n}\n\n</code></pre>\n</details>\n\n 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后IDE 会把代码发送给 PicoW-S3 主板。上传完成后，打开 Arduino IDE 的串口监视器，旋转模拟角度传感器，可以看到串口监视器中的数值变化，如下图所示：\n\n \n![](../assets/images/Lesson3-3.png)\n\n### 代码分析\n\n由于PicoW-S3 的 ADC 在使用上完全兼容 Arduino，因此这里不再对analogRead 函数进行过多的讲解。 \n \n注意：如果您对 Arduino 的基本函数不是特别熟悉，您可以[点击链接](https://www.arduino.cc/en/Tutorial/BuiltInExamples)进行学习。 \n\n## 项目四 I2C\n\nPicoW-S3 的 I2C 可以配置到任意 I/O 口，您可以通过传递相关参数进行配置。为了方便使用，我们已经将 I2C 进行了默认配置，在使用上完全兼容 Arduino，默认配置引脚可以在第一章简介中查看到。本项目是基于 I2C 默认配置，驱动 OLED 显示屏。 \n\n所需元件\n\nI2C OLED-12864 显示屏 X 1 \n\n![](../assets/images/Lesson4-1.png)\n\n面包板 X 1\n\n![](../assets/images/Lesson3-2.png)\n\nPicoW-S3 主板 X 1\n\n![](../assets/images/PicoW-S3.png)\n\n### 硬件连接\n\n把PicoW-S3 主板插到面包板上，然后将 OLED显示屏插接到 I2C 接口。（SDA是33，SCL是34）元件连接好后，使用 USB 线连接 PicoW-S3 和电脑。\n\n### 输入代码 \n\n打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。代码如下:\n\n<details>\n<summary>展开查看</summary>\n\n<pre><code>\n#include <Wire.h> \n   int UG2864Address = 0x3C;//OLED UG2864器件7位地址 \n \nprog_char F8X16[][16] PROGMEM =\n{\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// 0\n  0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,//!1\n  0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//\"2\n  0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,//#3\n  0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,//$4\n  0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,//%5\n  0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,//&6\n  0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//'7\n  0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,//(8\n  0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,//)9\n  0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,//*10\n  0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,//+11\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,//,12\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,//-13\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,//.14\n  0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,///15\n  0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,//016\n  0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//117\n  0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,//218\n  0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,//319\n  0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,//420\n  0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,//521\n  0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,//622\n  0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,//723\n  0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,//824\n  0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,//925\n  0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,//:26\n  0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,//;27\n  0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,//<28\n  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,//=29\n  0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,//>30\n  0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,//?31\n  0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,//@32\n  0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,//A33\n  0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,//B34\n  0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,//C35\n  0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,//D36\n  0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,//E37\n  0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,//F38\n  0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,//G39\n  0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,//H40\n  0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//I41\n  0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,//J42\n  0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,//K43\n  0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,//L44\n  0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,//M45\n  0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,//N46\n  0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,//O47\n  0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,//P48\n  0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,//Q49\n  0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,//R50\n  0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,//S51\n  0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//T52\n  0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//U53\n  0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,//V54\n  0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,//W55\n  0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,//X56\n  0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//Y57\n  0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,//Z58\n  0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,//[59\n  0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,//\\60\n  0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,//]61\n  0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//^62\n  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,//_63\n  0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//`64\n  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,//a65\n  0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,//b66\n  0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,//c67\n  0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,//d68\n  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,//e69\n  0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//f70\n  0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,//g71\n  0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//h72\n  0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//i73\n  0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,//j74\n  0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,//k75\n  0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//l76\n  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,//m77\n  0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//n78\n  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//o79\n  0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,//p80\n  0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,//q81\n  0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,//r82\n  0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,//s83\n  0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,//t84\n  0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,//u85\n  0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,//v86\n  0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,//w87\n  0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,//x88\n  0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,//y89\n  0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,//z90\n  0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,//{91\n  0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,//|92\n  0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,//}93\n  0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//~94\n};\n \n \nchar ch_buf[17]={0};\nint RES = 6;//Gadgeteer PIN6\nint DC = 7;//Gadgeteer PIN3\n \nvoid Writec(unsigned char COM)\n{\n  Wire.beginTransmission(UG2864Address);\n  Wire.write(0x00);\n  Wire.write(COM);\n  Wire.endTransmission();\n}\n \nvoid Writed(unsigned char DATA)\n{\n  Wire.beginTransmission(UG2864Address);\n  Wire.write(0x40);\n  Wire.write(DATA);\n  Wire.endTransmission();\n}\n \nvoid SSD1306()\n{\n  Writec(0XAE);//display off\n  Writec(0X00);//set lower column address\n  Writec(0X10);//set higher column address\n  Writec(0X40);//set display start line\n  Writec(0XB0);//set page address\n  Writec(0X81);//set contract control\n  Writec(0XCF);// VCC Generated by Internal DC/DC Circuit\n  Writec(0XA0);//set segment remap  column address 127 is mapped to SEG0\n  Writec(0XA6);//normal / reverse   normal display\n  Writec(0XA8);//multiplex ratio\n  Writec(0X3F);//1/64\n  Writec(0XC0);//Com scan direction remapped mode. Scan from COM[N-1] to COM0\n  Writec(0XD3);//set display offset\n  Writec(0X00);\n  Writec(0XD5);//set osc division\n  Writec(0X80);\n  Writec(0XD9);//set pre-charge period\n  Writec(0X11);\n  Writec(0XDa);//set COM pins\n  Writec(0X12);\n  Writec(0X8d);/*set charge pump enable*/\n  Writec(0X14);\n  Writec(0Xdb);//Set VcomH\n  Writec(0X20);\n  Writec(0XAF);//display ON\n}\nvoid fill(unsigned char dat)\n{\n  unsigned char i,j;\n  \n  Writec(0x00);//set lower column address\n  Writec(0x10);//set higher column address\n  Writec(0xB0);//set page address\n  \n  for(j=0;j<8;j++)\n  {\n    Writec(0xB0+j);//set page address\n    Writec(0x00);//set lower column address\n    Writec(0x10);//set higher column address\n    for(i=0;i<128;i++)\n    {\n      Writed(dat);\n    }\n  }\n}\n \nvoid show_string(unsigned char x,unsigned char y,char *s)\n{\n  unsigned char i,j,lower,higher;\n  char *t;\n  t=s;\n  lower=y%16;\n  higher=y/16;\n  if((x>3) || (y>120))\n    return;\n  Writec(0xB0+x*2);//set page address\n  Writec(lower);//set lower column address\n  Writec(0x10+higher);//set higher column address\n  for(j=0;*s!='\\0';j++)\n  {\n    \n    for(i=0;i<8;i++){\n      ch_buf[i] = pgm_read_word(&F8X16[*s-32][i]);\n    }\n    for(i=0;i<8;i++)\n      Writed(ch_buf[i]);\n    s++;\n  }\n  Writec(0xB0+x*2+1);//set page address\n  Writec(lower);//set lower column address\n  Writec(0x10+higher);//set higher column address\n  s=t;\n  for(j=0;*s!='\\0';j++)\n  {\n    for(i=0;i<8;i++){\n      ch_buf[i] = pgm_read_word(&F8X16[*s-32][i+8]);\n    }\n    for(i=0;i<8;i++)\n      Writed(ch_buf[i]);\n    s++;\n  }\n}\n \n \n \nvoid oled_init(void)\n{\n  pinMode(RES,OUTPUT);//RES\n  pinMode(DC,OUTPUT);//D/C#\n  \n  digitalWrite(DC,LOW);\n  Wire.begin();\n  digitalWrite(RES,HIGH);   delay(100);\n  digitalWrite(RES,LOW);    delay(100);\n  digitalWrite(RES,HIGH);   delay(100);\n  SSD1306();\n  fill(0x00);\n}\n \nvoid setup() {\n  oled_init();\n}\n \n \nvoid loop()\n{\n      fill(0x00);\n      show_string(0,12,\"BananaPi\");\n \n      show_string(2,12,\"banana-pi.org\");\n      while(1);\n}\n\n\n</code></pre>\n</details>\n\n输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE  \t会把代码发送给 PicoW-S3 主板。上传完成后，OLED 显示屏会显示“BananaPi banana-pi.org”字样。\n\n### 代码分析\n\n本项目的代码相对于前面的项目较多，主要是基于 I2C 通信对 OLED 显示屏底层寄存器的直接驱动。\n\n```\nvoid Writec(unsigned char COM)\n```\n\n设置寄存器函数，通过 I2C 对 OLED 显示屏设置，I2C 使用方法完全兼容 Arduino。 \n\n```\nvoid Writed(unsigned char DATA)\n```\n\n写数据函数，I2C 使用方法完全兼容 Arduino。 \n\n>注意：PicoW-S3 的 I2C 与 Arduino 完全兼容，主要是调用 Wire 库文件使用。\n\n## 项目五 SPI\n\n在很多传感器中，都使用 SPI 通信，因为 SPI 通信速率相对于 I2C 更快，没有地址冲突的弊端。SPI，是  一种高速的、全双工、同步的通信总线，而 PicoW-S3 的 SPI 可以配置到所有 I/O，您可以阅览底层  代码进行使用（初学者不建议使用）。为了更好的使用体验，PicoW-S3 默认情况下配置了IO35、IO36、IO37 为 SPI 口，在使用上则完全兼容 Arduino。 本项目使用 PicoW-S3，通过 SPI 读取 BME280 温湿度传感器的数据，示例中使用的是BME280 库文件，关于 SPI 驱动您可以阅览 BEM280 库文件，[点击链接](https://github.com/DFRobot/DFRobot_BME280)下载 BME280 库文件。 \n\n### 所需元件 \n\nBME280 温湿度传感器 X 1\n\n![](../assets/images/Lesson5-1.png)\n\n>注意：BME280 传感器本身支持 I2C 和 SPI 通信，这里我们采用 SPI 通信。 \n\n面包板 X 1\n\n![](../assets/images/Lesson3-2.png)\n\nPicoW-S3 主板 X 1\n\n![](../assets/images/PicoW-S3.png)\n\n### 输入代码\n\n打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 （这个程序需要DFRobot_BME280库，需要在[GitHub](https://github.com/DFRobot/DFRobot_BME280)下载，解压到Arduino\\ Library 文件夹下 ）代码如下：\n\n<details>\n<summary>展开查看</summary>\n\n<pre><code>\n/*!\n * read_data_spi.ino\n *\n * Download this demo to test read data from bme280, connect sensor through spi interface\n * Connect cs pin to io 2\n * Data will print on your serial monitor\n *\n * Copyright   [DFRobot](http://www.dfrobot.com), 2016\n * Copyright   GNU Lesser General Public License\n *\n * version  V1.0\n * date  12/03/2019\n */\n\n#include \"DFRobot_BME280.h\"\n#include \"Wire.h\"\n\ntypedef DFRobot_BME280_SPI    BME;    // ******** use abbreviations instead of full names ********\n\n# define PIN_CS   2\n\nBME   bme(&SPI, PIN_CS);   // select TwoWire peripheral and set cs pin id\n\n#define SEA_LEVEL_PRESSURE    1015.0f\n\n// show last sensor operate status\nvoid printLastOperateStatus(BME::eStatus_t eStatus)\n{\n  switch(eStatus) {\n  case BME::eStatusOK:    Serial.println(\"everything ok\"); break;\n  case BME::eStatusErr:   Serial.println(\"unknow error\"); break;\n  case BME::eStatusErrDeviceNotDetected:    Serial.println(\"device not detected\"); break;\n  case BME::eStatusErrParameter:    Serial.println(\"parameter error\"); break;\n  default: Serial.println(\"unknow status\"); break;\n  }\n}\n\nvoid setup()\n{\n  Serial.begin(115200);\n  bme.reset();\n  Serial.println(\"bme read data test\");\n  while(bme.begin() != BME::eStatusOK) {\n    Serial.println(\"bme begin faild\");\n    printLastOperateStatus(bme.lastOperateStatus);\n    delay(2000);\n  }\n  Serial.println(\"bme begin success\");\n  delay(100);\n}\n\nvoid loop()\n{\n  float   temp = bme.getTemperature();\n  uint32_t    press = bme.getPressure();\n  float   alti = bme.calAltitude(SEA_LEVEL_PRESSURE, press);\n  float   humi = bme.getHumidity();\n\n  Serial.println();\n  Serial.println(\"======== start print ========\");\n  Serial.print(\"temperature (unit Celsius): \"); Serial.println(temp);\n  Serial.print(\"pressure (unit pa):         \"); Serial.println(press);\n  Serial.print(\"altitude (unit meter):      \"); Serial.println(alti);\n  Serial.print(\"humidity (unit percent):    \"); Serial.println(humi);\n  Serial.println(\"========  end print  ========\");\n\n  delay(1000);\n}\n\n\n</code></pre>\n</details>\n\n 输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE  会把代码发送给 PicoW-S3 主板。打开 Arduino 串口监视器，可以看到打印信息如下： \n\n![](../assets/images/Lesson5-2.png)\n\n### 代码分析\n\n 本项目采用的是 BME280 库文件，在 Item-5.ino 文件中并没有对 SPI 底层进行操作，不过，PicoW  ESP32-S3 的 SPI 使用完全兼容 Arduino。 \n\n## 项目六 WS2812\n\n PicoW-S3 集成了一个型号为WS2812的RGB彩灯。 本项目是点亮 PicoW-S3 的RGB彩灯的实验，\n\n### 所需元件\n\nLPicoW-S3 主板 X 1\n\n![](../assets/images/PicoW-S3.png)\n\n>注意：该项目不需要连接其他传感器。\n\n### 输入代码\n\n打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。 （这个程序需要Adafruit_NeoPixel库，需要在[GitHub](https://github.com/adafruit/Adafruit_NeoPixel)下载，解压到Arduino\\ Library 文件夹下）代码如下:\n\n<details>\n<summary>展开查看</summary>\n\n<pre><code>\n// NeoPixel Ring simple sketch (c) 2013 Shae Erisson\n// Released under the GPLv3 license to match the rest of the\n// Adafruit NeoPixel library\n\n#include <Adafruit_NeoPixel.h>\n#ifdef __AVR__\n #include <avr/power.h> // Required for 16 MHz Adafruit Trinket\n#endif\n\n// Which pin on the Arduino is connected to the NeoPixels?\n#define PIN        18 // On Trinket or Gemma, suggest changing this to 1\n\n// How many NeoPixels are attached to the Arduino?\n#define NUMPIXELS 1 // Popular NeoPixel ring size\n\n// When setting up the NeoPixel library, we tell it how many pixels,\n// and which pin to use to send signals. Note that for older NeoPixel\n// strips you might need to change the third parameter -- see the\n// strandtest example for more information on possible values.\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\n#define DELAYVAL 500 // Time (in milliseconds) to pause between pixels\n\nvoid setup() {\n  // These lines are specifically to support the Adafruit Trinket 5V 16 MHz.\n  // Any other board, you can remove this part (but no harm leaving it):\n#if defined(__AVR_ATtiny85__) && (F_CPU == 16000000)\n  clock_prescale_set(clock_div_1);\n#endif\n  // END of Trinket-specific code.\n\n  pixels.begin(); // INITIALIZE NeoPixel strip object (REQUIRED)\n}\n\nvoid loop() {\n  pixels.clear(); // Set all pixel colors to 'off'\n\n  // The first NeoPixel in a strand is #0, second is 1, all the way up\n  // to the count of pixels minus one.\n  for(int i=0; i < NUMPIXELS; i++) { // For each pixel...\n\n    // pixels.Color() takes RGB values, from 0,0,0 up to 255,255,255\n    // Here we're using a moderately bright green color:\n    pixels.setPixelColor(i, pixels.Color(0, 150, 0));\n\n    pixels.show();   // Send the updated pixel colors to the hardware.\n\n    delay(DELAYVAL); // Pause before next pass through loop\n  }\n}\n</code></pre>\n</details>\n\n输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE  会把代码发送给 PicoW-S3 主板。复位后WS2812灯会开始亮绿灯，\n\n>注意：如果需要其他颜色，可以修改代码中的RGB值。\n\n### 代码分析\n\n本项目使用 PicoW-S3 集成的WS2812灯，默认GPIO是48。\n\n```\n#define PIN        48\n```\n\n设置GPIO引脚号\n\n```\n#define NUMPIXELS 1 \n```\n\n设置灯的个数，如果您想连接更多WS2812，可以换一个IO，并修改灯的数量。 \n\n## 项目七 触摸传感器\n\nPicoW-S3 提供了多达 14 个电容式传感器 GPIO，能够探测由手指或其他物品直接接触或接近而产生的电容差异。这种低噪声特性和电路的高灵敏度设计适用于较小的触摸板，可以直接用于触摸开关。本项目阐述了如何通过Arduino 代码获取 PicoW-S3 的触摸传感器状态，并打印状态。\n\n### 所需元件\n\nPicoW-S3 主板 X 1\n\n![](../assets/images/PicoW-S3.png)\n\n>注意：该项目不需要连接其他传感器。\n\n### 输入代码\n\n打开 Arduino IDE。尽管可以直接复制代码，我们还是建议您自己手动输入代码熟悉下。  \n\n代码如下:\n\n<details>\n<summary>展开查看</summary>\n\n<pre><code>\n void setup() \n{ \n  Serial.begin(115200); \n      delay(1000); // give me time to bring up serial monitor \n      Serial.println(\"PicoW-S3 Touch Test\");    \n}  \nvoid loop(){ \n  Serial.println(touchRead(T2));  // get value using T0->D9  \n  delay(100); \n} \n\n</code></pre>\n</details>\n\n输入完成后，点击“编译”检查代码有无错误。确保没有错误后就可以开始上传了，点击“上传”之后 IDE  会把代码发送给 PicoW-S3 主板。打开 Arduino IDE 串口监视器，并用手触摸 GPIO2（T2 对应的是GPIO2），可以看到会打印出的数据突然变小，如下图所示： \n\n![](../assets/images/Lesson8-1.png)\n\n### 代码分析\n\n获取触摸传感器的 GPIO 状态，只需要调用 touchRead 函数，函数原型如下：\n\n```\n uint16_t touchRead(uint8_t pin)\n```\n\n返回“0”表示没有触摸，“1”表示触摸。其中 pin 是 T0~T9，对应到 PicoW 的引脚如下表所示：\n\n<table>\n   <tr>\n      <td></td>\n   </tr>\n   <tr>\n      <td>触摸传感器序号 </td>\n      <td>对应的 ESP32 硬件 </td>\n      <td>PicoW-S3</td>\n      <td> </td>\n   </tr>\n   <tr>\n      <td>T1</td>\n      <td>GPIO1</td>\n      <td>IO1</td>\n   </tr>\n   <tr>\n      <td>T2 </td>\n      <td>GPIO2 </td>\n      <td>IO2</td>\n   </tr>\n   <tr>\n      <td>T3 </td>\n      <td>GPIO3</td>\n      <td>IO3</td>\n   </tr>\n   <tr>\n      <td>T4 </td>\n      <td>GPIO4</td>\n      <td>IO4</td>\n   </tr>\n   <tr>\n      <td>T5 </td>\n      <td>GPIO5</td>\n      <td>IO5</td>\n   </tr>\n   <tr>\n      <td>T6 </td>\n      <td>GPIO6</td>\n      <td>IO6</td>\n   </tr>\n   <tr>\n      <td>T7 </td>\n      <td>GPIO7</td>\n      <td>IO7</td>\n   </tr>\n   <tr>\n      <td>T8 </td>\n      <td>GPIO8</td>\n      <td>IO8</td>\n   </tr>\n   <tr>\n      <td>T9 </td>\n      <td>GPIO9</td>\n      <td>IO9</td>\n   </tr>\n   <tr>\n      <td>T10</td>\n      <td>GPIO10</td>\n      <td>IO10</td>\n   </tr>\n   <tr>\n      <td>T11</td>\n      <td>GPIO11</td>\n      <td>IO11</td>\n   </tr>\n   <tr>\n      <td>T12</td>\n      <td>GPIO12</td>\n      <td>IO12</td>\n   </tr>\n   <tr>\n      <td>T13</td>\n      <td>GPIO13</td>\n      <td>IO13</td>\n   </tr>\n   <tr>\n      <td>T14</td>\n      <td>GPIO14</td>\n      <td>IO14</td>\n   </tr>\n   <tr>\n      <td></td>\n   </tr>\n</table>"}, "/PicoW_S3_doc/zh/Arduino/Environment.html": {"title": "环境搭建", "content": "# 环境搭建\n\n由于板型原因，PicoW-S3的Arduino使用会比较复杂，我们不太推荐您使用PicoW-S3学习Arduino。这篇文章将会指引您安装PicoW-S3的Arduino支持。\n![](../assets/images/logo_arduino.png)\n\n> 参考[arduino-esp32 DOC Getting Started » Installing](https://docs.espressif.com/projects/arduino-esp32/en/latest/installing.html)\n\n## 使用Arduino IDE安装支持\n\n这是直接从 Arduino IDE 安装 Arduino-ESP32 的方法。\n\n> 从 Arduino IDE 版本 1.6.4 开始，Arduino 允许使用 Boards Manager（开发板管理器）安装第三方平台包。有适用于 Windows、macOS 和 Linux 的软件包。\n\nArduino IDE 下载地址：https://www.arduino.cc/en/software\n\n> Arduino IDE 2.0与Arduino IDE 1.8.x的UI有些许差异，本文基于1.8.13版本编写，但不影响使用2.0版本的用户参考。\n\n要使用 Boards Managaer（开发板管理器）安装esp32平台包，请执行以下步骤：\n\n- 安装当前上游 Arduino IDE 1.8 或更高版本。\n\n- 启动 Arduino 并打开 File（文件）> Preferences（首选项）窗口，找到Additional Board Manager URLs（附加开发板管理器网址）。\n\n![](../assets/images/install_guide_preferences.png)\n\n- 稳定版链接：\n```\nhttps://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json\n```\n- 开发版链接：\n```\nhttps://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json\n```\n- 在Additional Board Manager URLs后面输入上述发布链接之一。您可以添加多个 URL，一行一个。\n\n![](../assets/images/install_guide_boards_manager_url.png)\n\n从菜单打开 Tools（工具） > Board（开发板）> Board Manager（开发板管理器） 搜索并安装esp32平台。\n\n![](../assets/images/install_guide_boards_manager_esp32.png)\n\n重启arduino IDE之后可以看到在开发板选项中多了ESP32 Arduino选项。\n\n选择 `ESP32S3 Dev Module` 这个型号，再参照下图所示的内容进行配置一遍即可，配置不当是无法使用的，请一定要参照下图所示的内容进行配置！\n\n![](../assets/images/Board_chose.jpg)"}, "/PicoW_S3_doc/zh/CircuitPython/flash_tinyuf2.html": {"title": "烧录tinyUF2固件的方法", "content": "# 烧录tinyUF2固件的方法\n> 所有对flash的操作不可逆，注意提前备份代码等重要文件。\n## 下载tinyUF2固件\n1. 进入[BPI-PicoW-S3 CircuitPython 下载](https://circuitpython.org/board/bpi_picow_s3/)页面。\n2. 在页面底部找到`Install, Repair, or Update UF2 Bootloader`栏目，点击最下方的`DOWNLOAD BOOTLOADER ZIP`按钮下载压缩包。\n3. 在本地解压压缩包，`combined.bin`文件是我们需要的固件。\n## 将开发板置于bootloader模式\n![](../assets/images/picow_s3_circuitpython_download_2.jpg)\n1. 通过USB连接开发板与电脑。\n2. 使用任何导体（如金属引脚或镊子）将BOOT0触点短路，以将EPS32S3芯片置于bootloader模式。\n3. 按一次`Reset`按键。\n4. 松开BOOT0触点。\n## 在浏览器中烧录固件\n> 支持Chrome，Edge浏览器，内核版本需高于89。\n1. 打开[ESP Web Flasher](https://nabucasa.github.io/esp-web-flasher/)页面。\n2. 点击`Connect`按钮，将弹出一个选项栏，选择开发板所在的串口。\n    ![](../assets/images/picow_s3_tinyuf2_download_1.png)\n    ![](../assets/images/picow_s3_tinyuf2_download_2.png)\n3. 正常连接后，点击`Erase`按钮擦除开发板的flash内容，这个过程不可逆。\n   ![](../assets/images/picow_s3_tinyuf2_download_3.jpg)\n4. 点击`Choose a file...`按钮，在弹出的文件选择窗口中跳转到`combined.bin`文件所在的目录，选择此文件并点击确认。\n5. 点击`Program`按钮即可开始烧录固件，大约等待五分钟即可完成。\n6. 完成后，手动按一次`Reset`按键，成功烧录的标志是彩灯为长绿灯，如果没有得到此结果，可以重试前五步，或尝试下一个烧录方法。\n\n## esptool本地烧录固件\n\n1. 打开[Python官网](https://www.python.org/) 。\n\n    对于Windows 系统来说，最便捷的安装包下载方法就是在官网首页点击如下图所示的图标进行下载。\n\n    ![](../assets/images/Micropython_operating_env_1.png)\n\n    其他操作系统或是其他发行版本则可以在 Downloads 选项栏中进行选择。\n\n    建议使用python 3.7以上的版本。\n\n2. 开始安装时一定要记得勾选Add Python 3.x to PATH，这样可以免除再手动添加进PATH。\n\n    ![](../assets/images/Micropython_operating_env_2.png)\n\n    按照安装提示逐步操作即可顺利完成安装 。\n\n3. 以Windows PowerShell的具体操作步骤为例，使用以下命令安装esptool：\n\n   ```shell\n   pip install esptool\n   ```\n\n    如果未来有需要，则可以使用以下命令升级esptool：\n\n   ```shell\n   pip install -U esptool\n   ```\n\n4. 通过命令或其他方法在PowerShell中进入固件所在的目录。\n\n5. 可以在Windows文件夹窗口中以按住shift键再单击右键的方式在此文件夹中打开PowerShell窗口。\n\n6. 此时需要设置开发板为bootloader模式，详见上文。\n\n7. 通过以下命令清除flash，需要修改COM接口为对应的接口，此处为COM22。\n\n   ```shell\n   python -m esptool --chip esp32s3 --port COM22 --baud 460800 erase_flash\n   ```\n\n8. 通过以下命令烧录`combined.bin`固件，需要修改COM接口为对应的接口，此处为COM22。\n\n   ```shell\n   python -m esptool --chip esp32s3 --port COM22 --baud 460800 write_flash -z 0x0 combined.bin\n   ```\n\n9. 完成后，手动按一次`Reset`按键，成功烧录的标志是彩灯为长绿灯，如果没有得到此结果，可以重试前两步命令。"}, "/PicoW_S3_doc/zh/CircuitPython/config_mu-editor.html": {"title": "配置使用环境(Mu编辑器)", "content": "# 配置使用环境(Mu编辑器)\n\n## 下载安装Mu编辑器\n\n1. 进入[**Mu编辑器官网**](https://codewith.mu/)，点击 **Download** 按钮进入新页面。\n![](../assets/images/Download_mu_1.png)\n2. 选择你的电脑当前使用的操作系统，点击对应操作系统的 **Download** 按钮开始下载安装包。\n![](../assets/images/Download_mu_2.png)\n3. 点击对应操作系统的 **Instuctions** 按钮即可查看详细的安装步骤，根据指引安装即可。\n\n## 建立Mu编辑器与开发板的连接\n\n> BPI-PicoW-S3出厂已安装tinyUF2与CircuitPython固件。\n\n1. 启动Mu编辑器，将模式更改为CircuitPython，如果您已正确连接CircuitPython开发板，将提示您是否直接切换到该模式。\n![](../assets/images/Download_mu_3.png)\n\n![](../assets/images/Download_mu_4.png)\n\n2. 点击**Serrial**按钮，然后按任意键即可进入CircuitPython REPL。\n![](../assets/images/Download_mu_5.png)"}, "/PicoW_S3_doc/zh/CircuitPython/Basic.html": {"title": "基础功能使用", "content": "# 基础功能使用\n\n## REPL简单使用\n\n###  Hello World!\n\n1. 确保已在Mu编辑器中正确连接开发板，参考[配置使用环境(Mu编辑器)](config_mu-editor.html)。\n2. 在CircuitPython REPL窗口中通常会出现如下信息，`>>>`符号的出现即代表我们可以开始在其后输入命令与其交互了。\n```\n]0;🐍Wi-Fi: off | Done | 8.0.0-beta.0-49-g14fc4a079\\Auto-reload is on. Simply save files over USB to run them or enter REPL to disable.\n\nPress any key to enter the REPL. Use CTRL-D to reload.\n]0;🐍Wi-Fi: off | Done | 8.0.0-beta.0-49-g14fc4a079\\]0;�Wi-Fi: off | REPL | 8.0.0-beta.0-49-g14fc4a079\\\nAdafruit CircuitPython 8.0.0-beta.0-49-g14fc4a079 on 2022-09-20; BPI-PicoW-S3 with ESP32S3\n>>> \n```\n3. 在`>>>`符号右侧开始输入命令，例如：`print(\"Hello World！\")`。\n> 注意使用英文输入法，中文字符无法被REPL识别。\n```py\n>>> print(\"Hello World!\")\nHello World!\n>>> \n```\n\n### REPL快捷键\n\n1. 复制 `ctrl + shift + c`。\n2. 粘贴 `ctrl + shift + v`。\n   使用鼠标左键在REPL中拖选需要复制的命令，键盘按下复制快捷键，再按下粘贴快捷键即可复制粘贴命令。\n3. 软复位 `ctrl + d`。\n4. 中断 `ctrl + c`, 中断当前正在执行的程序，但不会重启复位。\n\n### 查看内置模块\n\n1. 在REPL中输入 `help(\"modules\")` 将列出当前CircuitPython开发板内所有模块。\n2. 导入模块后可再使用`help()`函数查看该模块内部可用的函数名或变量名，例如查看`board`模块，即可看到开发板所有可用的引脚与外设功能。\n```py\n>>> import board\n>>> help(board)\nobject <module 'board'> is of type module\n  __name__ -- board\n  board_id -- bpi_picow_s3\n  GP0 -- board.GP0\n  GP1 -- board.GP1\n  GP2 -- board.GP2\n  GP3 -- board.GP3\n  GP4 -- board.GP4\n  GP5 -- board.GP5\n  GP6 -- board.GP6\n  GP7 -- board.GP7\n  GP8 -- board.GP8\n  GP9 -- board.GP9\n  GP10 -- board.GP10\n  GP11 -- board.GP11\n  GP12 -- board.GP12\n  GP13 -- board.GP13\n  GP14 -- board.GP14\n  GP15 -- board.GP15\n  GP16 -- board.GP16\n  GP17 -- board.GP17\n  GP18 -- board.GP18\n  GP19 -- board.GP19\n  GP20 -- board.GP20\n  GP21 -- board.GP21\n  GP22 -- board.GP22\n  GP25 -- board.GP25\n  LED -- board.GP25\n  GP26 -- board.GP26\n  GP26_A0 -- board.GP26\n  A0 -- board.GP26\n  GP27 -- board.GP27\n  GP27_A1 -- board.GP27\n  A1 -- board.GP27\n  GP28 -- board.GP28\n  GP28_A2 -- board.GP28\n  A2 -- board.GP28\n  GP29 -- board.GP29\n  GP29_A3 -- board.GP29\n  A3 -- board.GP29\n  NEOPIXEL -- board.NEOPIXEL\n  TX -- board.GP0\n  RX -- board.GP1\n  BOOT0 -- board.BOOT0\n  UART -- <function>\n>>> \n```\n\n## 使WS2812彩灯闪烁\n\n1. 在Mu编辑器中点击**Load**按钮，选择CircuitPython开发板上的 code.py 文件，点击 **打开**，即可开始编辑 code.py 。\n\n2. 在编辑器中输入如下代码：\n\n```python\nimport time\nimport board\nimport neopixel\n\npixels = neopixel.NeoPixel(board.NEOPIXEL, 1, brightness=0.1)\n\nwhile 1:\n    pixels[0] = (255,0,0)\n    pixels.show()\n    time.sleep(0.5)\n    pixels[0] = (0,255,0)\n    pixels.show()\n    time.sleep(0.5)\n    pixels[0] = (0,0,255)\n    pixels.show()\n    time.sleep(0.5)\n    pixels[0] = (255,255,255)\n    pixels.show()\n    time.sleep(0.5)\n```\n\n3. 点击**Save**按钮，编辑的内容将保存到CircuitPython开发板，代码无误的情况下，开发板上的彩色LED将循环闪烁 红绿蓝白。将开发板复位或重新上电，程序将重新开始运行。\n4. 在REPL中使用中断快捷键即可停止程序的运行。\n5. 代码也可直接复制粘贴到REPL中运行。\n\n> 后续所有示例都可如此编辑code.py文件或复制粘贴到REPL中运行。但在code.py文件中的程序代码执行完毕后，开发板会恢复未运行时的状态，不会保留状态，但在REPL中执行则会保留状态。\n\n## 使引脚输出高低电平，控制LED\n\n1. `board.LED`控制着PicoW-S3上的一颗单色LED发光二极管，高电平点亮，低电平熄灭，在REPL中输入以下代码：\n```py\nimport board\nimport digitalio\nledpin = digitalio.DigitalInOut(board.LED)\nledpin.direction = digitalio.Direction.OUTPUT\nledpin.value = True\n```\n\n2. 或者这么做：\n```py\nimport board\nimport digitalio\nledpin = digitalio.DigitalInOut(board.LED)\nledpin.switch_to_output(value=True) # value=1\n```\n\n3. 让LED间隔0.5秒闪烁：\n```py\nimport board\nimport digitalio\nimport time\nledpin = digitalio.DigitalInOut(board.LED)\nwhile True:\n    ledpin.switch_to_output(value=1)\n    time.sleep(0.5)\n    ledpin.switch_to_output(value=0)\n    time.sleep(0.5)\n\n```\n4. 在REPL中使用中断快捷键即可停止程序的运行。\n\n5. 在REPL中输入`import board;help(board)`即可列出所有可控制的引脚。`board.GP25` 与 `board.LED`完全相同。\n\n## PWM输出，控制LED亮度\n\n1. 可通过控制PWM占空比来控制LED灯亮度，控制占空比从0%~100%，采用16位精度，十进制为 0~65535 ，16进制为 0~FFFF 。在REPL中输入以下代码：\n```py\nimport board\nimport pwmio\nledpin = pwmio.PWMOut(board.LED, frequency=25000, duty_cycle=0)\nledpin.duty_cycle = 32768  # mid-point 0-65535 = 50 % duty-cycle\n```\n2. 仅需在REPL中再次输入最后一行代码即可改变PWM占空比，使LED达到最大亮度：\n```py\nledpin.duty_cycle = 65535\n```\n3. 呼吸灯：\n```py\nimport board\nimport pwmio\nimport time\n\nledpin = pwmio.PWMOut(board.LED, frequency=25000, duty_cycle=0)\n\nwhile True:\n    for i in range(0, 65535, 1):\n        ledpin.duty_cycle = i\n    for i in range(65535, 0, -1):\n        ledpin.duty_cycle = i\n```\n\n## PWM输出，控制180度舵机\n\n![](../assets/images/MG90S-Wiring-Diagram.jpg)\n\n以MG90S舵机为例，其他各种舵机参考其对应的使用手册，在以下代码中修改相应的参数。\n\n1. MG90S舵机关键参数：\n   * 控制角度，0° ~ 180°\n   * PWM 占空时长控制，500us ~ 2500us 对应 0° ~ 180°\n   * 工作电压：4.8V 至 6V（典型值为 5V）\n   * 失速扭矩：1.8 kg/cm (4.8V)\n   * 最大失速扭矩：2.2 kg/cm (6V)\n   * 工作速度为 0.1s/60° (4.8V)\n2. 求取任意一个旋转角度所需的占空时长的表达式为：\n   ```\n    设y为占空时长，x为旋转角度\n    y=(2500-500)/180*x+500\n    y=(100*x+4500)/9\n    ```\n3. 根据参数，可以确定舵机角度由PWM波的高电平持续时长所控制，且由于舵机的控制必须由周期性的PWM波形控制，所以一个周期时长必须超过控制此舵机达到180°所需的占空时长，即超过2500us，则PWM频率要低于400hz。\n4. 设定PWM频率为200hz，则周期时长为5000us，对应控制此舵机旋转 0° ~ 180°的占空比为10% ~ 50% 。\n5. circuitpython的PWM占空比控制精度为16bit，100%占空比在 2进制中表达为 1111 1111 1111 1111，16进制表达为 FFFF，10进制表达为 65535。\n6. 求取任意一个旋转角度所需的占空比的表达式为：\n    ```\n    设y为占空比，x为旋转角度\n    y=((50-10)/180*x+10)/100*65535\n    y=(4369*x+196605)/30\n    ```\n7. 舵机与BPI-PicoW-S3的接线方式:\n   > BPI-PicoW-S3的VBS引脚可输出+5V；除GP0以外，所有GP引脚都可以用于输出PWM，仅需在程序中修改到对应引脚即可。\n\n| 舵机 | BPI-PicoW-S3 |\n| :----: | :----: |\n| GND 棕色 | GND |\n| +5V 红色 | VBS |\n| PWM 橙色 | GP0 |\n\n\n8. 根据以上表达式与参数设计一个可以任意控制此舵机旋转角度的程序：\n    ```py\n    import board\n    import pwmio\n    import time\n    servo_1 = pwmio.PWMOut(board.GP0, frequency=200, duty_cycle=0)#200hz, one cycle 5000us\n\n    def get_duty_cycle(x):\n        return int((4369*x+196605)/30)\n\n    servo_1.duty_cycle = get_duty_cycle(90)# 90 degrees\n    ```\n9. 通过一个逻辑分析仪可以读出此程序所控制输出的PWM占空时长，与计算的数值应当相符。\n   ![](../assets/images/MG90S_pulseveiw_2.png)\n   ![](../assets/images/MG90S_pulseveiw_1.png)\n\n10. 使用列表设计一套连续的舵机动作：\n   ```py\n   import board\n   import pwmio\n   import time\n   servo_1 = pwmio.PWMOut(board.GP0, frequency=200, duty_cycle=0)#200hz, one cycle 5000us\n\n   def get_duty_cycle(x):\n       return int((4369*x+196605)/30) \n\n   action_list1 = [0,45,90,135,180,0,180,45,135,90]\n\n   while True:\n       for i in action_list1:\n           servo_1.duty_cycle = get_duty_cycle(i)\n           time.sleep(0.5)\n   ```\n\n## ADC输入，读取双轴摇杆坐标\n\n![](../assets/images/Dual-axis_joystick.jpg)\n\n这是一个常见的双轴XY摇杆模块，使用了两个电位器最为其核心器件，通过芯片的ADC 模/数转换器 读取它们各自的电压数值，即可将读数转化为其在XY坐标轴上的位置。\n\n| 双轴摇杆 | BPI-PicoW-S3 |\n| :----: | :----: |\n| GND  | GND |\n| +5V  | 3V3 |\n| VRx  | GP27_A1 |\n| VRY  | GP26_A0 |\n\n1. 在CircuitPython中提供的ADC精度是16bit，即最大值的16进制表达为 FFFF，10进制表达为 65535，对应的电压量程为0mv ~ 3300mv。BPI-PicoW-S3所使用的EPS32S3芯片实际ADC电压量程为0mv ~ 3100mv，所以实际应用时仅能测量到3100mv。\n\n2. 基础ADC读数，读取两个电位器的数值，转换为电压数值。\n```python\nimport board,analogio,time\n\nx_axis_pin = analogio.AnalogIn(board.A0)\ny_axis_pin = analogio.AnalogIn(board.A1)\n\nwhile True:\n    x_axis = x_axis_pin.value\n    y_axis = y_axis_pin.value\n    # print((x_axis,y_axis))\n    x_value = x_axis / 65535 * 3300\n    y_value = y_axis / 65535 * 3300\n    print(\"{0}mv,{1}mv\".format(x_value,y_value))\n    time.sleep(0.1)\n```\n\n3. 在Mu编辑器中，点击`Plotter`图标即可显示绘图仪，可以实时将REPL输出的数值显示为与时间相关的折线图。\n![](../assets/images/circuitpython_plotter.png)\n   \n4. 以下程序可实现校准坐标零点的功能。开始运行的前五秒，请静止摇杆等待获取零点数值。\n> 注意代码中将xy轴对换了，将双轴摇杆模块逆时针旋转90°即可对应使用。此做法可使摇杆在y轴上移时ADC读数增加，反之减少，符合常见直角坐标系的规律。\n```python\nimport board,analogio,time\n\nx_axis_pin = analogio.AnalogIn(board.A0)\ny_axis_pin = analogio.AnalogIn(board.A1)\n\ndef get_zero(times =500, sleep = 0.01):\n    x_total = 0\n    y_total = 0\n    for i in range (times):\n        x_axis = x_axis_pin.value\n        y_axis = y_axis_pin.value\n        x_total += x_axis\n        y_total += y_axis\n        time.sleep(sleep)\n    x_zero = x_total // times\n    y_zero = y_total // times\n    return (x_zero,y_zero)\n\nzero = get_zero(times =500, sleep = 0.01)\nprint(zero)\n\nwhile True:\n    x_axis = x_axis_pin.value - zero[0]\n    y_axis = y_axis_pin.value - zero[1]\n    print((x_axis,y_axis))\n    time.sleep(0.1)\n```\n5. 以下程序可获取摇杆方向，这是双轴摇杆最常见的应用。\n```python\nimport board,analogio,time\n\nx_axis_pin = analogio.AnalogIn(board.A0)\ny_axis_pin = analogio.AnalogIn(board.A1)\n\ndirection_list = [\"East\",\"Southeast\",\"South\",\"Southwest\",\"West\",\"Northwest\",\"North\",\"Northeast\",\"Centre\"]\n\ndef get_zero(times =500, sleep = 0.01):\n    x_total = 0\n    y_total = 0\n    for i in range (times):\n        x_axis = x_axis_pin.value\n        y_axis = y_axis_pin.value\n        x_total += x_axis\n        y_total += y_axis\n        time.sleep(sleep)\n    x_zero = x_total // times\n    y_zero = y_total // times\n    return (x_zero,y_zero)\n\ndef get_direction(zero = (32767,32767)):\n    x_axis = x_axis_pin.value - zero[0]\n    y_axis = y_axis_pin.value - zero[1]\n    if x_axis >= 10000 and -10000 < y_axis < 10000:\n        return direction_list[0]\n    elif x_axis >= 10000 and y_axis <= -10000:\n        return direction_list[1]\n    elif -10000 < x_axis < 10000 and y_axis <= -10000:\n        return direction_list[2]\n    elif x_axis <= -10000 and y_axis <= -10000:\n        return direction_list[3]\n    elif x_axis <= -10000 and -10000 < y_axis < 10000:\n        return direction_list[4]\n    elif x_axis <= -10000 and y_axis >= 10000:\n        return direction_list[5]\n    elif -10000 < x_axis < 10000 and y_axis >= 10000:\n        return direction_list[6]\n    elif x_axis >=10000 and y_axis >= 10000:\n        return direction_list[7]\n    else :\n        return direction_list[8]\n\nzero = get_zero(times =50, sleep = 0.01)\nprint(zero)\n\nwhile True:\n    x_axis = x_axis_pin.value - zero[0]\n    y_axis = y_axis_pin.value - zero[1]\n    print((x_axis,y_axis))\n    print(get_direction(zero = zero))\n    time.sleep(0.1)\n```\n6. 以下程序可设置坐标精度等级，计算每级跨度，可以按需求消除抖动，增强数据的实用性。\n```python\nimport board,analogio,time\n\nx_axis_pin = analogio.AnalogIn(board.A0)\ny_axis_pin = analogio.AnalogIn(board.A1)\n\ndef get_zero(times =500, sleep = 0.01):\n    x_total = 0\n    y_total = 0\n    for i in range (times):\n        x_axis = x_axis_pin.value\n        y_axis = y_axis_pin.value\n        x_total += x_axis\n        y_total += y_axis\n        time.sleep(sleep)\n    x_zero = x_total // times\n    y_zero = y_total // times\n    return (x_zero,y_zero)\n\ndef get_extremum(times =500, sleep = 0.01):\n    x_list = []\n    y_list = []\n    for i in range (times):\n        x_axis = x_axis_pin.value\n        y_axis = y_axis_pin.value\n        x_list.append(x_axis)\n        y_list.append(y_axis)\n        time.sleep(sleep)\n    x_extremum = (min(x_list),max(x_list))\n    y_extremum = (min(y_list),max(y_list))\n    return (x_extremum,y_extremum)\n    \ndef get_spacing(level = 16 , zero =(32767,32767) ,x_extremum = (0,65535),y_extremum = (0,65535)):\n    x_temp_1 = (zero[0] - x_extremum[0]) // level\n    x_temp_2 = (x_extremum[1] - zero[0] ) // level\n    y_temp_1 = (zero[1] - y_extremum[0]) // level\n    y_temp_2 = (y_extremum[1] - zero[1] ) // level\n    x_spacing = (x_temp_1,x_temp_2)\n    y_spacing = (y_temp_1,y_temp_2)\n    return (x_spacing,y_spacing)\n\ndef get_coordinates(zero = (32767,32767), x_spacing = (2048,2048),y_spacing = (2048,2048)):\n    x_value = x_axis_pin.value - zero[0]\n    y_value = y_axis_pin.value - zero[1]\n    if x_value >= 0:\n        x_axis = x_value // x_spacing[1]\n    else:\n        x_axis = - ((-x_value) // x_spacing[0])\n    if y_value >= 0:\n        y_axis = y_value // y_spacing[1]\n    else:\n        y_axis = - ((-y_value) // y_spacing[0])\n    return (x_axis,y_axis)\n    \nzero = get_zero(times =500, sleep = 0.01)\nprint(zero)\n(x_extremum,y_extremum) = get_extremum(times = 500, sleep = 0.01)\nprint((x_extremum, y_extremum))\n(x_spacing,y_spacing) = get_spacing(level = 128 , zero = zero, x_extremum = x_extremum,y_extremum = y_extremum)\nprint((x_spacing, y_spacing))\n\nwhile True:\n    coordinates = get_coordinates(zero = zero, x_spacing = x_spacing, y_spacing = y_spacing)\n    print(coordinates)\n    time.sleep(0.1)\n```\n\n## 使用增量型旋转编码器\n![](../assets/images/rotary_incremental_encoder_pic.png) ![](../assets/images/rotary_incremental_encoder_pic_1.jpg)\n\n**接线参考**\n\n|**增量型旋转编码器**|**BPI-PicoW-S3**|\n| --- | --- |\n|GND|GND|\n|+|VBUS|\n|SW||\n|DT|GP0|\n|CLK|GP1|\n\n1. 增量型旋转编码器外观粗看与一些常见的旋转电位器相似，其关键的不同之处大致分为三点。\n   1. 微控制器使用ADC外设来读取旋转电位器输出的模拟信号（电压值），确定转轴当前角位；微控制器通过GPIO接收增量型旋转编码器输出的数字信号，可通过软件程序判断信号所对应的转轴动作。\n   2. 微控制器可在一定精度下，确定旋转电位器转轴当前角位，但因为模拟信号的持续性与抗干扰能力差的原因，无法准确判断它是否有动作；增量型旋转编码器仅在转轴运动到一个触点时，向微控制器发出一段动作数字信号，如果一个增量型旋转编码器一周有20个触点，它旋转一周就触发20次动作信号，微控制器可以精确的判断它是否动作，向哪个方向转动，信号触发了多少次。\n   3. 旋转电位器通常不可向任意转向进行无限旋转，会停止在最大或最小限位点；增量型旋转编码器可向任意转向进行无限旋转。\n2. 增量型旋转编码器采用正交编码器生成其A和B的输出信号。从A和B输出发射的脉冲是正交编码的，这意味着当增量编码器以恒定速度运动时，A和B波形是方波，A和B之间存在90度的相位差。最终A和B信号将从两个管脚传输给微控制器。\n    ![](../assets/images/rotary_incremental_encoder_pic_2.gif)\n\n\n3. 理论上，在任何特定时间，对于旋转编码器，A和B信号之间，顺时针旋转的相位差为+90°，逆时针旋转的相位差为−90°，具体则取决于设备内部的正交编码器设计。\n4. A或B输出上的脉冲频率与转轴的速度（位置变化率）成正比。较高的频率表示较快的速度，而较低的频率表示较慢的速度。当转轴静止时，静态、不变的信号输出在A和B上，所以有很多测速方案使用增量型旋转编码器。\n> 参考 [维基百科: 增量编码器](https://en.wikipedia.org/wiki/Incremental_encoder#Quadrature_decoder) 。\n5. 用CircuitPython设计一个程序读取在GP0与GP1引脚上的信号，当其中一个发生变化时同时输出两个引脚当前的值，连接开发板与增量型旋转编码器后运行程序。\n```python\nimport board\nimport digitalio\n\ndt = digitalio.DigitalInOut(board.GP0)\nclk = digitalio.DigitalInOut(board.GP1)\ndt.switch_to_input()\nclk.switch_to_input()\ndt_last_value = 0\nclk_last_value = 0\n\nwhile True:\n    if dt.value != dt_last_value or clk.value != clk_last_value:\n        dt_last_value = int(dt.value)\n        clk_last_value = int(clk.value)\n        print((dt_last_value,clk_last_value))\n```\n6. 逐级转动转轴，观察输出信号，如果有逻辑分析仪或示波器也可接入观察。\n\n   1. 转轴逆时针旋转时，REPL的输出。\n   ```\n   (1, 1)\n   (1, 0)\n   (0, 0)\n   (0, 1)\n   (1, 1)\n   (1, 0)\n   (0, 0)\n   (0, 1)\n   (1, 1)\n   ```\n   2. 转轴逆时针旋转时，逻辑分析仪所观察到的波形。\n   ![](../assets/images/rotary_incremental_encoder_0.png)\n\n   3. 转轴顺时针旋转时，REPL的输出。\n   ```\n   (1, 1)\n   (0, 1)\n   (0, 0)\n   (1, 0)\n   (1, 1)\n   (0, 1)\n   (0, 0)\n   (1, 0)\n   (1, 1)\n   ```\n   4. 转轴逆时针旋转时，逻辑分析仪所观察到的波形。\n   ![](../assets/images/rotary_incremental_encoder_1.png)\n\n\n7. 首先可以观察到的现象是，转轴完成一级动作后，两个引脚上的信号都为1，可以设计程序，当值都变为1时输出一次计数值，计数值可作为判断编码器完成一次动作的依据。\n```python\nimport board\nimport digitalio\n\ndt = digitalio.DigitalInOut(board.GP0)\nclk = digitalio.DigitalInOut(board.GP1)\ndt.switch_to_input()\nclk.switch_to_input()\ndt_last_value = 0\nclk_last_value = 0\ncount = 0\n\nwhile True:\n    if dt.value != dt_last_value or clk.value != clk_last_value:\n        dt_last_value = int(dt.value)\n        clk_last_value = int(clk.value)\n        print((dt_last_value,clk_last_value))\n        if (dt_last_value,clk_last_value) == (1,1):\n            print('--',count_1,'--')\n            count += 1\n```\n8. 再确定编码器顺时针旋转与逆时针旋转的动作，在两个引脚上输出的信号变化的规律与差异。\n  1. 逆时针旋转的规律为(1, 1)>(1, 0)>(0, 0)>(0, 1)>(1, 1)。\n  2. 顺时针旋转的规律为(1, 1)>(0, 1)>(0, 0)>(1, 0)>(1, 1)。\n  由此可设计一个顺时针旋转使计数+1，逆时针旋转使计数-1的程序，并加入消抖除错的功能。\n```python\nimport board\nimport digitalio\nimport time\ndt = digitalio.DigitalInOut(board.GP0)\nclk = digitalio.DigitalInOut(board.GP1)\ndt.switch_to_input()\nclk.switch_to_input()\ndt_last_value = 0\nclk_last_value = 0\ncount = 0\nstart_sign = 0\nclockwise_sign = 0\nwhile True:\n    if dt.value != dt_last_value or clk.value != clk_last_value:\n        dt_last_value = int(dt.value)\n        clk_last_value = int(clk.value)\n        print((dt_last_value,clk_last_value))\n        if start_sign == 0 and (dt_last_value,clk_last_value) == (0,0):\n            start_sign = 1\n        elif start_sign == 1:\n            if (dt_last_value,clk_last_value) == (1, 0):\n                clockwise_sign = 1\n            elif (dt_last_value,clk_last_value) == (0, 1):\n                clockwise_sign = -1\n            elif (dt_last_value,clk_last_value) == (1, 1):\n                count = count + clockwise_sign\n                clockwise_sign = 0\n                start_sign = 0\n                print('--',count,'--')\n```\n9. 此程序中的消抖除错功能的实现，并不是逐步判断验证是否符合信号规律，或许还有更多办法可以实现消抖除错，欢迎讨论。\n10. 另外 CircuitPython 的rotaryio模块可直接实现正反转计数功能。（内部程序有所差异，但最终实现功能基本一致）。\n```python\nimport rotaryio\nimport board\n\nencoder = rotaryio.IncrementalEncoder(board.GP0,board.GP1) \nlast_position = 0\n\nwhile True:\n    position = encoder.position\n    if position != last_position:\n        print(position)\n    last_position = position\n```\n\n## 下载安装CircuitPython库，驱动ssd1306 oled屏幕\n\n![](../assets/images/adafruit_ssd1306_4.jpg)\n\n[CircuitPython库 官网页面](https://circuitpython.org/libraries)\n[Adafruit CircuitPython库 文档页面](https://docs.circuitpython.org/projects/bundle/en/latest/index.html)\n[Adafruit SSD1306 库 文档页面](https://docs.circuitpython.org/projects/ssd1306/en/latest/index.html)\n[Adafruit framebuf 库 文档页面](https://docs.circuitpython.org/projects/framebuf/en/latest/)\n\n本节以ssd1306驱动库与framebuf库为例，指导如何下载安装CircuitPython库。\n\n1. 在新页面打开[Adafruit CircuitPython库 文档页面](https://docs.circuitpython.org/projects/bundle/en/latest/index.html)。\n2. 在页面中找到并打开 **SSD1306 OLED (framebuf)** 项，然后点击左侧的**Download from GitHub**项，跳转到其GitHub releases页面，点击 **adafruit-circuitpython-ssd1306-8.x-mpy-2.12.12.zip** 项将其下载到本地。\n![](../assets/images/adafruit_ssd1306_1.jpg)\n![](../assets/images/adafruit_ssd1306_2.jpg)\n![](../assets/images/adafruit_ssd1306_3.jpg)\n3. 回到Adafruit CircuitPython库 文档页面，在页面中找到并打开 **Framebuf Module** 项，然后点击左侧的**Download from GitHub**项，跳转到其GitHub releases页面，点击 **adafruit-circuitpython-framebuf-8.x-mpy-1.4.14.zip** 项将其下载到本地。\n> 下载最新版本即可。\n4. 将下载的两个压缩包解压，内部文件夹结构如下：\n```\n├─examples\n│  ├─xxx.py\n│  ├─xxx.py\n│  └─......\n├─lib\n│  ├─a.mpy\n│  ├─b.mpy\n│  └─......\n└─requirements\n   ├─a\n   │ └─requirements.txt\n   ├─b\n   │ └─requirements.txt\n   └─......\n```\n5. examples文件夹中的是一些库的使用例程，lib文件夹中扩展名为`.mpy`的即是库文件，requirements文件夹中的 requirements.txt 文件，其中记录了各库文件所依赖的，必要的其他库文件名称，有一些已经包含在CircuitPython固件中，而不在其内的则需另外下载安装。例如 **adafruit_ssd1306** 库绘制图形和文字的方法全部依赖于**adafruit_framebuf** 库，所以我们在第3步中也将其下载到本地。\n6. 将两个lib文件夹中扩展名为`.mpy`的库文件复制到 **CIRCUITPY** 磁盘中的lib文件夹内，即可在程序中调用这两个库。\n7. adafruit_framebuf 库还需将其examples文件夹中的 **font5x8.bin** 文件复制到**CIRCUITPY** 磁盘中的根目录，即 code.py 文件所在的地方。此为字库文件，显示文字需要使用它。\n8. 将一块i2c协议的ssd1306 oled屏幕模块与开发板连接。\n\n**接线参考**\n\n| ssd1306 | BPI-PicoW-S3 |\n| :----: | :----: |\n| GND  | GND |\n| VCC  | 3V3 |\n| SCL  | GP0 |\n| SDA  | GP1 |\n\n1. 编辑 code.py 文件，在其中输入以下代码即可驱动此屏幕模块输出图形和字符。\n    修改代码中的变量 `bgColor`数值为1，即可使显示背景为白色，显示图形为黑色。\n    在两个库的文档中可查找到API参考，配合例程即可快速理解，上手使用ssd1306显示模块。\n```python\nimport board\nimport busio\nimport adafruit_ssd1306\nimport time\n\ni2c = busio.I2C(board.GP0, board.GP1)\ndisplay = adafruit_ssd1306.SSD1306_I2C(128, 64, i2c, addr=0x3C)\nbgColor=0\n\ndisplay.fill(bgColor)\nfor i in range(0,display.height,4):\n    for j in range(0,display.width,4):\n        display.pixel(j, i, not bgColor)\n    display.show()\n\ndisplay.fill(bgColor)\nfor i in range(0,display.height,4):\n    display.hline(0, i,display.width, not bgColor)\n    display.show()\n\ndisplay.fill(bgColor)\nfor i in range(0,display.width,8):\n    display.vline(i, 0,display.height, not bgColor)\n    display.show()\n\ndisplay.fill(bgColor)\nfor i in range(0,display.height,4):\n    display.line(0, 0, display.width, i, not bgColor)\n    display.line(display.width, display.height, 0, display.height-i, not bgColor)\n    display.show()\n\ndisplay.fill(bgColor)\nfor i in range(0,display.width//2,4):\n    display.circle(display.width//2, display.height//2, i, not bgColor)\n    display.show()\n\ndisplay.fill(bgColor)\nfor i in range(0,display.height,16):\n    for j in range(0,display.width,16):\n        display.rect(j, i, 12, 12, not bgColor)\n        display.show()\n\nfor i in range(0,display.height,16):\n    for j in range(0,display.width,16):\n        display.fill_rect(j+2, i+2, 8, 8, not bgColor)\n        display.show()\n\ndisplay.fill(bgColor)\ndisplay.text(\"Hello\", 0, 24, not bgColor, font_name='font5x8.bin', size=2)\ndisplay.show()\ntime.sleep(0.25)\ndisplay.text(\"World!\", 0, 40, not bgColor, font_name='font5x8.bin', size=3)\ndisplay.show()\ntime.sleep(0.25)\ndisplay.text(\">>>\", 60, 0, not bgColor, font_name='font5x8.bin', size=4)\ndisplay.show()\ntime.sleep(1)\n\ndisplay.fill(bgColor)\nchar_width = 6\nchar_height = 8\nchars_per_line = display.width // 6\nfor i in range(255):\n    x = char_width * (i % chars_per_line)\n    y = char_height * (i // chars_per_line)\n    display.text(chr(i), x, y, not bgColor, font_name='font5x8.bin', size=1)\ndisplay.show()\n```\n\n## 实时图形显示双轴摇杆坐标位置\n\n```python\nimport time\nimport board\nimport busio\nimport analogio\nimport adafruit_ssd1306\n\ndef get_zero(times =500, sleep = 0.01):\n    x_total = 0\n    y_total = 0\n    for i in range (times):\n        x_axis = x_axis_pin.value\n        y_axis = y_axis_pin.value\n        x_total += x_axis\n        y_total += y_axis\n        time.sleep(sleep)\n    x_zero = x_total // times\n    y_zero = y_total // times\n    return (x_zero,y_zero)\n\ndef get_extremum(times =500, sleep = 0.01):\n    x_list = []\n    y_list = []\n    for i in range (times):\n        x_axis = x_axis_pin.value\n        y_axis = y_axis_pin.value\n        x_list.append(x_axis)\n        y_list.append(y_axis)\n        time.sleep(sleep)\n    x_extremum = (min(x_list),max(x_list))\n    y_extremum = (min(y_list),max(y_list))\n    return (x_extremum,y_extremum)\n\ndef get_spacing(level = 16 , zero =(32767,32767) ,x_extremum = (0,65535),y_extremum = (0,65535)):\n    x_temp_1 = (zero[0] - x_extremum[0]) // level\n    x_temp_2 = (x_extremum[1] - zero[0] ) // level\n    y_temp_1 = (zero[1] - y_extremum[0]) // level\n    y_temp_2 = (y_extremum[1] - zero[1] ) // level\n    x_spacing = (x_temp_1,x_temp_2)\n    y_spacing = (y_temp_1,y_temp_2)\n    return (x_spacing,y_spacing)\n\ndef get_coordinates(zero = (32767,32767), x_spacing = (2048,2048),y_spacing = (2048,2048)):\n    x_value = x_axis_pin.value - zero[0]\n    y_value = y_axis_pin.value - zero[1]\n    if x_value >= 0:\n        x_axis = x_value // x_spacing[1]\n    else:\n        x_axis = - ((-x_value) // x_spacing[0])\n    if y_value >= 0:\n        y_axis = y_value // y_spacing[1]\n    else:\n        y_axis = - ((-y_value) // y_spacing[0])\n    return (x_axis,y_axis)\n\ni2c = busio.I2C(board.GP0, board.GP1)\ndisplay = adafruit_ssd1306.SSD1306_I2C(128, 64, i2c, addr=0x3C)\ndisplay.fill(0)\ndisplay.show()\n\nx_axis_pin = analogio.AnalogIn(board.A0)\ny_axis_pin = analogio.AnalogIn(board.A1)\n\ndisplay.text('Zero adjustment', 0, 28, 1, font_name='font5x8.bin', size=1)\ndisplay.show()\nzero = get_zero(times =200, sleep = 0.01)\nprint(zero)\ndisplay.fill(0)\ndisplay.text('Extremum adjustment', 0, 28, 1, font_name='font5x8.bin', size=1)\ndisplay.show()\n(x_extremum,y_extremum) = get_extremum(times = 200, sleep = 0.01)\nprint((x_extremum, y_extremum))\n(x_spacing,y_spacing) = get_spacing(level = 32 , zero = zero, x_extremum = x_extremum,y_extremum = y_extremum)\nprint((x_spacing, y_spacing))\ndisplay.fill(0)\ndisplay.text('x=', 70, 16, 1, font_name='font5x8.bin', size=2)\ndisplay.text('y=', 70, 32, 1, font_name='font5x8.bin', size=2)\n(x_axis,y_axis) = (0,0)\n(x_axis_1,y_axis_1) = (0,0)\n(x_axis_2,y_axis_2) = (0,0)\nwhile True:\n    (x_axis,y_axis) = get_coordinates(zero = zero, x_spacing = x_spacing, y_spacing = y_spacing)\n    # print(x_axis,y_axis)\n    if (x_axis,y_axis) == (x_axis_1,y_axis_1):\n        pass\n    else:\n        display.text(str(x_axis_1), 90, 16, 0, font_name='font5x8.bin', size=2)\n        display.text(str(y_axis_1), 90, 32, 0, font_name='font5x8.bin', size=2)\n        display.fill_rect(x_axis_2-3, y_axis_2-3, 6, 6, 0)\n        (x_axis_1,y_axis_1) = (x_axis,y_axis)\n        (x_axis_2,y_axis_2) = (x_axis+32, -y_axis+32)\n        display.fill_rect(x_axis_2-3, y_axis_2-3, 6, 6, 1)\n        display.text(str(x_axis_1), 90, 16, 1, font_name='font5x8.bin', size=2)\n        display.text(str(y_axis_1), 90, 32, 1, font_name='font5x8.bin', size=2)\n        display.show()\n\n\n```"}, "/PicoW_S3_doc/zh/CircuitPython/supported_by_circuitpython.html": {"title": "已得到CircuitPython官方支持", "content": "# 已得到CircuitPython官方支持\n\n1. 已得到adafruit/circuitpython GitHub存储库支持。\n\n    https://github.com/adafruit/circuitpython/pull/7031 分支已合并。\n\n2. 已得到adafruit/tinyuf2 GitHub存储库支持。\n\n    https://github.com/adafruit/tinyuf2/pull/250 分支已合并。\n\n3. 已得到adafruit/circuitpython-org GitHub存储库支持。\n\n    https://github.com/adafruit/circuitpython-org/pull/1070 分支已合并。\n\n    https://github.com/adafruit/circuitpython-org/pull/1077 分支已合并。\n\n4. circuitpython.org 网页已可下载circuitpython固件与tinyuf2固件。\n\n    https://circuitpython.org/board/bpi_picow_s3/"}, "/PicoW_S3_doc/zh/CircuitPython/update_circuitpython.html": {"title": "更新CircuitPython固件的方法", "content": "# 更新CircuitPython固件的方法\n> 出厂已安装 tinyUF2 + CircuitPython固件，升级circuipython仅需双击复位键进入UF2 bootloader模式，无需擦除flash。\n> 本方法适用于已具备tinyUF2固件的开发板，如果开发板的flash被擦除或出现无法进入UF2模式的故障，则需先参考[烧录tinyUF2固件的方法](flash_tinyuf2.html)。\n1. 进入[BPI-PicoW-S3 CircuitPython 下载](https://circuitpython.org/board/bpi_picow_s3/)页面。\n   ![](../assets/images/picow_s3_circuitpython_download.jpg)\n2. 点击DOWNLOAD UF2 NOW 按钮即可下载最新释放的`.uf2`固件。\n3. 通过USB连接开发板与电脑，在此电脑文件管理页面将出现一个名为`CIRCUITPY`的磁盘，此为CircuitPython模式下的磁盘，通过双击开发板上的`Reset`按键的方式，使其变更为UF2模式下的磁盘，以下为具体操作步骤。\n   1. 快速按一次`Reset`按键。\n    ![](../assets/images/picow_s3_circuitpython_download_2.jpg)\n   2. 紫灯亮起时再快速按一次`Reset`按键。\n    ![](../assets/images/picow_s3_circuitpython_download_3.jpg)\n   3. 成功触发的标志是彩灯在片刻红灯后转变为长绿灯，如果没有得到此结果，可以重试前两步。\n    ![](../assets/images/picow_s3_circuitpython_download_4.jpg)\n4. UF2模式下的磁盘名称为`UF2BOOT`，将第1步下载的`.uf2`固件复制到此磁盘中，过程中彩灯会闪烁橙灯，请勿在此过程中断开连接或对开发板进行任何操作。\n5. 完成CircuitPython固件更新后会自动复位，在此电脑文件管理页面将重新出现一个`CIRCUITPY`磁盘，通过REPL可以查看具体的固件版本。"}, "/PicoW_S3_doc/zh/index.html": {"title": "【 BPI-PicoW-S3 开发板 】", "content": "# 【 BPI-PicoW-S3 开发板 】\n\n## 介绍\n\n![](assets/images/BPI-PicoW-S3_banner.png)\n\n香蕉派BPI-PicoW是一款低功耗微控制器，专为物联网开发和Maker DIY设计的开发板。与 Raspberry Pi Pico 板尺寸相同，支持 2.4 GHz Wi-Fi 和 Bluetooth® LE 双模无线通信， 外设兼容低功耗硬件设计，深度睡眠模式下功耗仅为10uA。编程方面，PicoW-S3支持ESP-IDF、Arduino、micropython、CircuitPython 等多种方式。\n\n## 使用 CircuitPython 编程\n\n> BPI-PicoW-S3出厂已安装tinyUF2与CircuitPython固件,推荐通过CircuitPython快速上手BPI-PicoW-S3开发板。\n\n![](assets/images/CircuitPython_Repo_header_logo.jpg)\n\nCircuitPython是旨在简化在单片机开发板上进行编程实验和学习的一种编程语言。\n\n配合Mu编辑器进行CircuitPython编程是最低难度的上手方法，安装软件，连接设备即可开始使用。\n\n## 使用 MicroPython 编程\n\nMicroPython实现了大部分Python 3 特性和语法，易学易上手，验证程序效果无需编译直接下载进芯片运行。\n\n无论是否有编程基础，MicroPython的上手难度绝对远低于其他编程语言，其代码易读性高，且开源社区有多年积累的丰富资源，就如同Python一样拥有极强的生命力与应用价值。\n\n通过烧写 MicroPython 固件，就可以在开发板中使用 Python 语言进行编程。\n\n![](assets/images/Mircopython.png)\n\n## 使用 Arduino 编程\n\n提供了入门 Arduino 的软件工具和最佳示例，降低进入 ESP32 嵌入式专业开发的门槛。\n\n![](assets/images/Arduino_logo_1200x350.png)\n\n>Arduino 将不会阐述过多基础内容，请具备 C/C++ 的语言开发基础。\n\n## 资料与资源\n\n- [官方WIKI](https://wiki.banana-pi.org/BPI-PicoW-S3_%E5%BC%80%E5%8F%91%E6%9D%BF) \n\n- [GitHub: BPI-PicoW-S3 开发板原理图PDF](https://github.com/BPI-STEAM/BPI-PicoW-Doc/blob/main/sch/BPI-PicoW-V0.4.pdf) \n\n- [ESP32-S3 技术规格书](https://www.espressif.com/sites/default/files/documentation/esp32-s3_datasheet_cn.pdf)\n\n- [ESP32-S3 技术参考手册](https://www.espressif.com/sites/default/files/documentation/esp32-s3_technical_reference_manual_cn.pdf)\n\n## 样品购买\n\n- [官方速卖通](https://www.aliexpress.com/item/1005004775634442.html?spm=5261.ProductManageOnline.0.0.15744edfAyCaNk)\n\n- [官方淘宝](https://item.taobao.com/item.htm?spm=a2126o.success.0.0.25b04831CHV1Nc&id=684134360199)\n\n- OEM&OEM 定制服务 ： sales@banana-pi.com"}, "/PicoW_S3_doc/zh/Unboxing/Introduction.html": {"title": "【 开发板介绍 】", "content": "# 【 开发板介绍 】\n\nBPI-PicoW-S3板载ESP32-S3芯片，支持 2.4 GHz Wi-Fi 和低功耗蓝牙 (Bluetooth® LE) 双模无线通信。板子支持USB和IO供电两种供电方式，可实现双电源下自动切换电源功能。体积小巧，接口方便，上手简单，可直接应用于物联网低功耗项目。\n\nBPI-PicoW-S3开发板在软件方面支持ESP-IDF、Arduino、MicroPython等多种方式进行编程开发 。\n\nBPI-PicoW-S3开发板上标记了与芯片对应的所有IO管脚，外形与Raspberry Pico W开发板一致，开发者可根据实际需求，可将Raspberry Pico W支持的外围设备添加到BPI-PicoW-S3上，也可将开发板插在面包板上使用。\n\n## 关键特性\n\n- ESP32-S3，Xtensa® 32 bit LX7\n- 片上外设 PSRAM , 片外 FLASH\n- Ultra-low power 10uA\n- 2.4G WIFI ，Bluetooth 5 ，Bluetooth mesh\n- GPIO , ADC , TOUCH , PWM , I2C , SPI , RMT , I2S , UART , LCD，CAMERA ，USB , JTAG\n- 1 * MicroUSB\n- 1 * 全彩色LED\n\n## 硬件\n\n### 接口示意图\n\n![](../assets/images/PicoW-S3_board.png)\n\n### 硬件规格\n\n<table>\n   <tr>\n      <td>BPI-PicoW-S3 规格表</td>\n   </tr>\n   <tr>\n      <td>SoC主控芯片</td>\n      <td>ESP32-S3，Xtensa® 32 位 LX7 双核处理器</td>\n   </tr>\n   <tr>\n      <td>主频</td>\n      <td>240MHz MAX</td>\n   </tr>\n   <tr>\n      <td>工作温度</td>\n      <td>-40℃~+85℃</td>\n   </tr>\n   <tr>\n      <td>片上 ROM</td>\n      <td>384 KB</td>\n   </tr>\n   <tr>\n      <td>片上 SRAM</td>\n      <td>320 KB</td>\n   </tr>\n   <tr>\n      <td>片外 FLASH ROM</td>\n      <td>8MB</td>\n   </tr>\n   <tr>\n      <td>片上外设 PSRAM</td>\n      <td>2MB</td>\n   </tr>\n   <tr>\n      <td>WIFI</td>\n      <td>IEEE 802.11 b/g/n ，2.4Ghz频带，150Mbps</td>\n   </tr>\n   <tr>\n      <td>蓝牙</td>\n      <td>Bluetooth 5 ，Bluetooth mesh</td>\n   </tr>\n   <tr>\n      <td>GPIO</td>\n      <td>BPI-PicoW-S3已引出27个可用GPIO</td>\n   </tr>\n   <tr>\n      <td>ADC</td>\n      <td>2 × 12 位 SAR ADC，支持 20 个模拟通道输入</td>\n   </tr>\n   <tr>\n      <td>TOUCH 电容式触摸传感器</td>\n      <td>14</td>\n   </tr>\n   <tr>\n      <td>SPI</td>\n      <td>4</td>\n   </tr>\n   <tr>\n      <td>I2C</td>\n      <td>2，支持主机或从机模式</td>\n   </tr>\n   <tr>\n      <td>I2S</td>\n      <td>2，串行立体声数据的输入输出</td>\n   </tr>\n   <tr>\n      <td>LCD</td>\n      <td>1，支持 8 位 ~16 位并行 RGB、I8080、MOTO6800 接口</td>\n   </tr>\n   <tr>\n      <td>CAMERA</td>\n      <td>1，支持 8 位 ~16 位 DVP 图像传感器接口</td>\n   </tr>\n   <tr>\n      <td>UART</td>\n      <td>3 ，支持异步通信（RS232 和RS485）和 IrDA</td>\n   </tr>\n   <tr>\n      <td>PWM</td>\n      <td>8 路独立通道，14位精度</td>\n   </tr>\n   <tr>\n      <td>MCPWM</td>\n      <td>2</td>\n   </tr>\n   <tr>\n      <td>USB</td>\n      <td>1 × 全速USB 2.0 OTG，MicroUSB母口</td>\n   </tr>\n   <tr>\n      <td>USB Serial/JTAG 控制器</td>\n      <td>1，USB 全速标准，CDC-ACM ，JTAG</td>\n   </tr>\n   <tr>\n      <td>温度传感器</td>\n      <td>1，测量范围为–20 °C 到 110 °C，用于监测芯片内部温度</td>\n   </tr>\n   <tr>\n      <td>SD/MMC</td>\n      <td>1 × SDIO主机接口，具有2个卡槽，支持SD卡3.0和3.01，SDIO 3.0，CE-ATA 1.1，MMC 4.41，eMMC 4.5和4.51</td>\n   </tr>\n   <tr>\n      <td>TWAI® 控制器</td>\n      <td>1 ，兼容 ISO11898-1（CAN 规范 2.0）</td>\n   </tr>\n   <tr>\n      <td>通用 DMA 控制器</td>\n      <td>5 个接收通道和 5 个发送通道</td>\n   </tr>\n   <tr>\n      <td>RMT</td>\n      <td>4 通道发射，4通道接收，共享 384 x 32-bit 的 RAM</td>\n   </tr>\n   <tr>\n      <td>脉冲计数器</td>\n      <td>4个脉冲计数控制器（单元），每个单元有2个独立的通道</td>\n   </tr>\n   <tr>\n      <td>定时器</td>\n      <td>4 × 54 位通用定时器，16 位时钟预分频器，1 × 52 位系统定时器，3 × 看门狗定时器</td>\n   </tr>\n   <tr>\n      <td>外部晶振</td>\n      <td>40Mhz</td>\n   </tr>\n   <tr>\n      <td>RTC 和低功耗管理</td>\n      <td>电源管理单元 (PMU)+ 超低功耗协处理器 (ULP)</td>\n   </tr>\n   <tr>\n      <td>低功耗电流</td>\n      <td>10uA</td>\n   </tr>\n   <tr>\n      <td>工作电压</td>\n      <td>3.3V</td>\n   </tr>\n   <tr>\n      <td>输入电压</td>\n      <td>3.3V~5.5V</td>\n   </tr>\n   <tr>\n      <td>最大放电电流</td>\n      <td>2A@3.3V DC/DC</td>\n   </tr>\n   <tr>\n      <td>可控全彩色LED</td>\n      <td>1</td>\n   </tr>\n</table>\n\n\n### 硬件尺寸\n\n\n![](../assets/images/PicoW-S3_board_dimension.png)\n\n<table>\n   <tr>\n      <td>BPI-PicoW-S3 尺寸表</td>\n   </tr>\n   <tr>\n      <td>管脚间距</td>\n      <td>2.54mm</td>\n   </tr>\n   <tr>\n      <td>安装孔间距</td>\n      <td>11.4mm/ 47mm</td>\n   </tr>\n   <tr>\n      <td>安装孔尺寸</td>\n      <td>内径2.1mm/外径3.4mm</td>\n   </tr>\n   <tr>\n      <td>主板尺寸</td>\n      <td>21 × 51.88(mm)/0.83 x 2.04(inches)</td>\n   </tr>\n   <tr>\n      <td>板厚</td>\n      <td>1.2mm</td>\n   </tr>\n   <tr>\n      <td></td>\n   </tr>\n</table>\n\n管脚间距兼容万能板（洞洞板、点阵板），面包板，并且能直接贴在其他PCB上，便于调试应用。\n\n## 资料与资源\n\n- [GitHub: BPI-PicoW-S3 开发板原理图PDF](https://github.com/BPI-STEAM/BPI-PicoW-Doc/blob/main/sch/BPI-PicoW-V0.4.pdf) \n\n- [ESP32-S3 技术规格书](https://www.espressif.com/sites/default/files/documentation/esp32-s3_datasheet_cn.pdf)\n\n- [ESP32-S3 技术参考手册](https://www.espressif.com/sites/default/files/documentation/esp32-s3_technical_reference_manual_cn.pdf)"}}