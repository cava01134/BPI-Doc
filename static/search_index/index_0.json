{"/Q-Car/zh/introduction/hardware.html": {"title": "硬件介绍", "content": "# 硬件介绍\n\n## 产品标配清单\n\n1. 小车本体×1（出厂已安装好电机，车轮，支撑轮）\n2. 超声波模块×1\n\n## 硬件参数\n\n* 供电电压：3.6V~3.7V DC(3.6V~3.7V锂电池)\n* 红外巡线传感器(高低电平)×2 (P1 P2)\n* 蜂鸣器×1 (P0)\n* 红外发射×1 (P8)\n* 红外接收(NEC编码)×1 (P15)\n* RGB氛围灯（全彩1600万色）×10 (P16)\n* SR04、SR04P超声波接口(5V)×1 (Trig:P12 Echo:P14)\n* I2C接口(3.3V/5V切换）×1\n* 舵机专用接口 ×4 (S5 S6 S7 S8)\n* IO扩展口 ×2 (P3 P4 P9 P10)\n* N20金属减速电机×2 (S5 S6 S7 S8)\n* 电机减速比：1：100\n* 电机最大转速：133转/分\n* 电机驱动方式：PWM电机驱动\n* 保护盖及扩展M3螺丝孔×6\n* 编程方式：makecode图形化编程、Mind+图形化编程（Webduino）、MicroPython编程\n* 产品尺寸：宽9.77mm×长12.09mm×高1.23mm（不含micro:bit主板高度）\n* 产品重量：125.5g（不含micro:bit主板及周边配件）\n\n## 硬件接口示意\n\n![](../assets/Q-Car_IO_Front.png)\n![](../assets/Q-Car_IO_Back.png)\n\n## 功能引脚定义\n| Function | Web:Bit GPIO |\n| :----: | :----: |\n| IR-Receive | P15 |\n| IR-Emission | P8 |\n| RGB | P16 |\n| I2C | (Address:0x40) |\n| Wheel(Left) | I2C(LED0 LED1) |\n| Wheel(Right) | I2C(LED2 LED3) |\n| Line Following(Left) | P2 |\n| Line Following(Right) | P1 |\n| Speed Detection(Left) | P11 |\n| Speed Detection(Right) | P5 |\n\n\n<!-- ## 原理图 -->"}, "/Q-Car/zh/index.html": {"title": "Q-Car", "content": "# Q-Car\nBPI Steam 的 Q-Car 是一款专注于教育用途的机器人，集成了各式各样的设备，适用场景更加丰富。\n\nQ-Car 同时兼容web:bit和micro:bit两款开发板。从图形编程到较复杂的代码编程，从简单电机控制到多种人机交互综合应用，Q-Car 提供的丰富设备与高扩展性能持续满足使用者在学习中对实机验证的需求。\n\n![](assets/Q-Car_Front.png)\n\n## 关键特性\n\n* 支持MakeCode图形化编程(与micro:bit配合)，支持Webduino图形化编程（与web:bit配合）及MicroPython编程（micro:bit 与web:bit）\n\n* 机身小巧，整体性强\n\n* N20微型减速电机\n\n* HC-SR04超声波测距模块\n\n* 红外发射器、红外接收器、巡线传感器、测速传感器、可编程RGB氛围灯、蜂鸣器\n\n* I2C接口（支持3.3V和5V切换）、超声波接口、舵机接口、排针扩展口\n\n* 兼容乐高积木的扩展螺孔"}, "/Q-Car/zh/microbit_tutorial/ultrasonic_ranging2.html": {"title": "详解超声波测距", "content": "# 详解超声波测距\n\n**声波** 在1个标准大气压和15℃的条件下在空气中的传导速度约为340m/s。当一段声波从声源发出，到遇到障碍物而被反射传回声源所在的位置，声源与障碍物之间的距离，就是这段声波从发出到返回时所用总时间乘以声速除以2。\n\n超声波具有指向性强，能量消耗缓慢，在介质中传播的距离较远的特点，在精度要求不是特别严苛且在非真空的条件下，很适合用于测量直线距离，设备成本也相对低廉。\n\n<div align=center>\n<img src=\"../assets/ultrasounic_Transducer.png\"/>\n</div>\n\n压电式超声波发生器实际上是利用压电晶体的谐振来工作的，它有两个压电晶片和一个共振板。\n\n当它的两极外加脉冲信号，其频率等于压电晶片的固有振荡频率时，压电晶片将会发生共振，并带动共振板振动，便产生超声波。\n\n反之，如果两电极间未外加电压，当共振板接收到超声波时，将压迫压电晶片作振动，将机械能转换为电信号，这时它就成为超声波接收器了。\n\n在一个超声波测距模块上测得发射时与接收时的两段电信号之间的时间差，即为这个超声波测距模块此次发出的超声波的传播时间，进而可以计算出超声波发射源与障碍物之间的距离。\n\n\n## 例程\n\n<div align=center>\n<img src=\"../assets/Q-car_Ultrasonic_ranging.png\" width=\"700\"/>\n</div>\n\n[在Github上的例程项目文件](https://github.com/Wind-stormger/Makecode/blob/master/microbit-Q-car_Ultrasonic_ranging.hex)\n\n> 项目文件下载到本地后可导入MakeCode中查看和再编辑，也可直接通过USB烧录到Micro:Bit中运行。\n\n## 设计说明\n\n采集P13引脚的高电平持续时间并赋值给变量\"Ultrasonic_time\"，此处时间单位是us微秒，经过换算在15℃标准大气压下声速为0.034cm/us,而25℃标准大气压下声速为0.0346cm/us, 我们选择后者用于距离计算。\n\n变量\"Ultrasonic_time\"乘以0.0346除以2再赋值给变量\"Distance\"，此时得到的变量数值即为超声波发射源与障碍物之间的距离，单位是cm。\n\n最后用一个if条件判断进行消噪，小于等于0和大于500的数值都做归零处理。\n\n程序上设计间隔0.1s运行一次超声波测距程序用以防止发射信号对回响信号的干扰，micro:bit通过USB串口间隔1s输出1次超声波传感器检测到的距离。"}, "/Q-Car/zh/microbit_tutorial/photoelectric_counter.html": {"title": "设计光电计数器", "content": "# 设计光电计数器\n\n## 红外对管与编码盘\n\n在Q-Car上有一对D字轴橡胶车轮，各带有12线编码盘，在电路板底部紧贴编码盘的位置放置了红外对管。\n\n<div align=center>\n<img src=\"../assets/Q-car_wheel_1.jpg\" width=\"500\"/>\n</div>\n\n<div align=center>\n<img src=\"../assets/Q-car_wheel_2.jpg\" width=\"500\"/>\n</div>\n\n<div align=center>\n<img src=\"../assets/Infrared_tube_pair.png\" width=\"200\"/>\n</div>\n\n红外对管一侧发射红外光，一侧接收红外光，接收端将反射回的光线强弱的信息转化为电压高低的信号。\n\n## 光电开关\n\nmicro:bit的P11引脚为高电平时Q-Car上的红外对管才会通电工作。\n\n与右车轮的编码盘紧贴的红外对管与micro:bit的P5引脚相连，而左车轮的编码盘紧贴的红外对管与micro:bit的P11引脚相连。\n\n以右轮为例，可以制作一个测试程序，检测右轮编码盘对应的红外对管向P5引脚输出的高低电平信号，例程如下图。\n\n<div align=center>\n<img src=\"../assets/Q-Car_Photoelectric_switch_test.png\" width=\"600\"/>\n</div>\n\n[在Github上的例程项目文件](https://github.com/Wind-stormger/Makecode/blob/master/microbit-Photoelectric_switch_test.hex)\n\n> 项目文件下载到本地后可导入MakeCode中查看和再编辑，也可直接通过USB烧录到Micro:Bit中运行。\n\n将程序下载进micro:bit，然后保持USB串口连接，将micro:bit插入Q-Car的插槽，旋转右轮使编码盘的凹槽对向红外对管，此时micro:bit显示0，即表明此时红外对管输出给P5引脚的是低电平信号。\n\n<div align=center>\n<img src=\"../assets/Q-car_wheel_3.jpg\" width=\"600\"/>\n</div>\n\n<div align=center>\n<img src=\"../assets/microbit-show-0.png\" width=\"250\"/>\n</div>\n\n旋转右轮使编码盘的凸块对向红外对管，此时micro:bit显示1，即表明此时红外对管输出给P5引脚的是高电平信号。\n\n<div align=center>\n<img src=\"../assets/Q-car_wheel_4.jpg\" width=\"600\"/>\n</div>\n\n<div align=center>\n<img src=\"../assets/microbit-show-1.png\" width=\"250\"/>\n</div>\n\n凸块因为距离近所以使红外反射增强，凹槽因为距离远所以使红外反射减弱，这犹如一个物理开关的接通与关断两个状态，编码盘与红外对管的组合，构成了一套光电开关。\n\n## 用光电开关来制作计数器\n\n从光电开关的特性来看，每当检测到从高电平变为低电平，或者从低电平变为高电平的时候，在程序里使一个变量加1，即为一个计数器了。\n\n<div align=center>\n<img src=\"../assets/microbit-Photoelectric_counter2.png\" width=\"350\"/>\n</div>\n\n[在Github上的例程项目文件](https://github.com/Wind-stormger/Makecode/blob/master/microbit-Photoelectric_counter2.hex)\n\n> 项目文件下载到本地后可导入MakeCode中查看和再编辑，也可直接通过USB烧录到Micro:Bit中运行。\n\non pin P5 pulsed low 积木在检测到P5引脚从高电平变为低电平时会触发执行内部的积木，即使变量自加1。\n\nevery 1000 ms积木每过1000ms就执行一次内部的积木，即显示一次计数值。"}, "/Q-Car/zh/microbit_tutorial/ultrasonic_ranging.html": {"title": "超声波测距的简单应用", "content": "# 超声波测距的简单应用\n\n## 例程\n\n<div align=center>\n<img src=\"../assets/Q-car_Ultrasonic_ranging2.png\" width=\"400\"/>\n</div>\n\n[在Github上的例程项目文件](https://github.com/Wind-stormger/Makecode/blob/master/microbit-Q-car_Ultrasonic_ranging2.hex)\n\n> 项目文件下载到本地后可导入MakeCode中查看和再编辑，也可直接通过USB烧录到Micro:Bit中运行。\n\n## 设计说明\n\n1. 将超声波测距模块的“VCC,Trig,Echo,GND”引脚与Q-Car的“V,T,E,G”四个排针槽位对应连接，接通Q-Car的电源。\n\n2. Micro:Bit将显示测距数值的整数，单位为cm。\n\n关于超声波模块的工作原理将在后续文中提到。"}, "/Q-Car/zh/microbit_tutorial/music_arrangement.html": {"title": "编曲并用蜂鸣器播放", "content": "# 编曲并用蜂鸣器播放\n\n## 音乐积木\n\n在MakeCode编辑器中，除了能使蜂鸣器播放预设乐曲的音乐积木外，还有能进行简单编曲的积木可供使用，能模拟36键电子琴。\n\n<div align=center>\n<img src=\"../assets/Music_Arrangement1.png\" width=\"300\"/>\n</div>\n\n## 简谱入门\n\n下表为简谱中数字对应的音阶与唱名。\n\n<table>\n<tbody>\n  <tr>\n    <th>音阶</th>\n    <td>C</td>\n    <td>D</td>\n    <td>E</td>\n    <td>F</td>\n    <td>G</td>\n    <td>A</td>\n    <td>B</td>\n  </tr>\n  <tr>\n    <th>唱名</th>\n    <td>do</td>\n    <td>re</td>\n    <td>mi</td>\n    <td>fa</td>\n    <td>sol</td>\n    <td>la</td>\n    <td>Si</td>\n  </tr>\n  <tr>\n    <th>数字</th>\n    <td>1</td>\n    <td>2</td>\n    <td>3</td>\n    <td>4</td>\n    <td>5</td>\n    <td>6</td>\n    <td>7</td>\n  </tr>\n</tbody>\n</table>\n\n如果是高一个八度，就会在数字上方加上一点。如果是低一个八度，就会数字下方加上一点。在中间的那一个八度就什么也不用加。这三个八度对应音乐积木中的三个八度，即从低C 音阶(Low C)到 高B 音阶(High B)。\n\n通常只有数字的是四分音符。数字下加一条横线，就可令四分音符的长度减半，即成为八分音符；两条横线可令八分音符的长度减半，即成为十六分音符，以此类推；简单来说，下加横线数目与五线谱的符尾数目相对应。数字后方的横线延长音符，每加一条横线延长一个四分音符的长度。\n\n全音符占4个节拍，二分音符占2个节拍，四分音符占1个节拍，八分音符占1/2个节拍,十六分音符占1/4个节拍，依此类推。\n\n> 可以继续参考[维基百科：简谱](https://zh.wikipedia.org/wiki/%E7%B0%A1%E8%AD%9C)，或者检索其他相关的文献资料。\n\n\n## 将一小段简谱编排到程序中\n\n<div align=center>\n<img src=\"../assets/Music_Arrangement2.png\"/>\n</div>\n\n这是一首曲名为《Weight of the World》的简谱的前奏。[曲谱原始链接](http://www.qupu123.com/puyou/jipu/p289352.html)\n\n以第一个简谱音符为例，6指 A音阶，数字下方有一点，即指 低一个八度的 低A音阶(Low A)，数字下加了一条横线，即为八分音符，占1/2个节拍。\n\n用积木表示即为：\n\n<div align=center>\n<img src=\"../assets/Music_Arrangement3.png\" width=\"400\"/>\n</div>\n\n## 例程\n\n<div align=center>\n<img src=\"../assets/Q-car_Music_Arrangement.png\" width=\"500\"/>\n</div>\n\n[在Github上的例程项目文件](https://github.com/Wind-stormger/Makecode/blob/master/microbit-Q-car_Music_Arrangement.hex)\n\n> 项目文件下载到本地后可导入MakeCode中查看和再编辑，也可直接通过USB烧录到Micro:Bit中运行。\n\n## 设计说明\n\nfunction 函数内的积木会在调用call function积木时执行，可以给这个函数自定义命名，方便人的使用与理解。更多用法及其作用会在后续文中提到。\n\nset tempo to(bpm) 积木用于设置节拍，调节整体节奏快慢，这里设置的 80 来源于原曲谱所示的节拍速度。\n\n按一次A按钮，即可循环播放两次，会从Q-Car的蜂鸣器中发出有很足的电子游戏音乐风格的乐声。\n\n可以依照此法将任何你想听的曲子转录到程序中。"}, "/Q-Car/zh/microbit_tutorial/first_meeting.html": {"title": "初识 micro:bit", "content": "# 初识 micro:bit\n\n[micro:bit](https://microbit.org/) 是一款由英国广播电视公司为青少年编程教育设计，并由微软，三星，ARM，英国兰卡斯特大学等合作伙伴共同完成开发的微型电脑，目前推出V1，V2两款，后者较比前者性能稍强。\n\n![](../assets/microbit.png)\n\n## MakeCode编辑器\nMakeCode 是微软所推行的应用于编程教育的图形编程语言，也是 micro:bit 目前主流应用的编程语言，无需下载安装任何本地应用，在浏览器中打开网页即可在线编程。\n\n[micro:bit-MakeCode 网页链接](https://makecode.microbit.org/#)\n\n在MakeCode编辑器中可以在零编程基础的情况下通过搭建图形积木的方式入门，更有将实现比较复杂的程序封装起来的扩展积木可以使用，进一步降低门槛，对多国语言的本地化支持也是其重要的优势。\n\n其编辑器主要由三个部分组成，图形化积木（blocks）编辑器，仿真模拟器，图形化积木所对应的JavaScript代码编辑器。\n\n![](../assets/microbit-MakeCode.png)\n\n## MicroPython编辑器\n\nMicroPython是相对进阶但也并不难上手学习的编程语言，micro:bit 更有提供较为易用的模块来降低对其编程难度，其相对图形编程最大的不同就是转变为抽象的字符代码。\n\n[micro:bit-micropython 网页链接](https://python.microbit.org/v/2)\n\n如其名所述，它是 Python 3 编程语言的一个精简高效的实现，它包含了 Python 标准库的一小部分子集，并且经过优化，可以在微控制器上和受限环境中运行。\n\n如果曾经学过python，那将会相当容易上手，反之在开发板上学习了MicroPython后，也能几乎无障碍地切换到python做进一步的学习或开发应用。\n\n![](../assets/microbit-micropython.png)"}, "/Q-Car/zh/microbit_tutorial/RPM_measurement.html": {"title": "利用光电计数器进行转速测量", "content": "# 利用光电计数器进行转速测量\n\n## RPM转速的定义\n\n每分钟转速，或称之每分钟回转数，英文RPM，全写是Revolution(s) Per Minute，是转动性物体在转动速度上的一种衡量单位，所指的是一个物体在一分钟内的旋转圈数，一圈即是指一次的绕周转动，若以数学上的角度单位来衡量即是转动了360度。\n\n## 推理与设计\n\n现在我们有几个可以明确采集到的条件：\n\n1. 12线编码轮，12道凹槽，12道凸块。\n2. 编码轮与红外对管相对处，由凸转凹时，光电计数器程序的计数值加1，车轮带动编码轮向某一方向持续旋转一周，计数值加12。\n3. RPM转速为一个物体在一分钟内的旋转圈数。\n\n通过这些已知条件，RPM转速值可以这么计算出来：\n\n**一分钟总计数值 ÷ 12 = RPM**\n\n这个方程式中的 RPM 单位时间是 **旋转圈数/每分钟** ，也可以是 **旋转圈数/每60秒** 。\n\n那么方程式也可以换成这样的：\n\n**60秒总计数值 ÷ 12 = RPM**\n\n这个方程式可以明确，采集60秒的计数值即可算出RPM，如果我们想尽快算出转速值呢？\n\n试试仅采集5秒的计数值，为了保持等式依旧成立，即需要这么做：\n\n**(5秒总计数值 × 12) ÷ 12 = RPM**\n\n**5秒总计数值 = RPM**\n\n采集5秒的总计数值恰好等于 RPM数值，若是仅采集1秒呢？\n\n**1秒总计数值  × 5 = RPM**\n\n至此我们对如何着手设计程序就会很明了了，仅需在光电计数器程序的基础上改进即可。\n\n### 例程1\n\n<div align=center>\n<img src=\"../assets/microbit-RPM_measurement_1-2.png\" width=\"500\"/>\n</div>\n\n[在Github上的例程项目文件](https://github.com/Wind-stormger/Makecode/blob/master/microbit-RPM_measurement_1-2.hex)\n\n> 项目文件下载到本地后可导入MakeCode中查看和再编辑，也可直接通过USB烧录到Micro:Bit中运行。\n\n### 设计说明\n\n在程序开始时使用扩展积木初始化PCA9685芯片，使右轮电机全速运行。\n\nevery 1000ms 积木即间隔1S执行一次，设置一个变量将计数值通过计算后算出的转速储存起来以便显示，再使计数值清零。\n\n## 换向推理\n\n前文中方程式：\n\n**60秒总计数值 ÷ 12 = RPM**\n\n这其中 **总计数值** 是一个变量，具体多少需要采集60秒钟的计数值才可得知，而时间是我们人为设置且确定的数值。\n\n假设我们将变量设为时间呢？例如我们人为设置一个计数值 24 ，即旋转 2 圈，而从0一直计数到24所需要花费的时间，则设为变量。我们再一次确定 RPM 为单位时间60秒内物体旋转的圈数，那么将有以下方程式：\n\n**计数到24所需要花费的时间 ÷ (24 ÷ 12) = 60秒 ÷ RPM**\n\n等式左边是为了计算出 这段时间内平均每旋转一圈所需要的时间，而等式右边则是为了计算出在这个转速每旋转一圈所需要的时间，等式左右所计算出的时间一定相等。\n\n将方程式转化：\n\n**RPM = 60秒 ÷ (计数到24所需要花费的时间 ÷ (24 ÷ 12))**\n\n**RPM = 60秒 ÷ (计数到24所需要花费的时间 ÷ 2)**\n\n**RPM = 60秒 ÷ 计数到24所需要花费的时间 × 2**\n\n**RPM = 120秒 ÷ 计数到24所需要花费的时间**\n\n此时若改变计数值，即计数到12，那么方程式将如下：\n\n**RPM = 60秒 ÷ 计数到12所需要花费的时间**\n\n依据此方程式，我们需要在程序中添加能采集到时间的积木才可实现功能，即需要采集到计数值为0时的开始时间，和计数值达到12时的结束时间。\n\n### 例程2 \n\n<div align=center>\n<img src=\"../assets/microbit-RPM_measurement_2-2.png\" width=\"700\"/>\n</div>\n\n[在Github上的例程项目文件](https://github.com/Wind-stormger/Makecode/blob/master/microbit-RPM_measurement_2-2.hex)\n\n> 项目文件下载到本地后可导入MakeCode中查看和再编辑，也可直接通过USB烧录到Micro:Bit中运行。\n\n### 设计说明\n\nrunning time(ms) 积木将会获取从程序启动以来至读取这个积木为止的时间，单位为毫秒。\n\n设计一个变量储存计数值为0时的开始时间，而在计数值达到12时，用在那一刻由running time(ms) 积木获取的时间减去变量储存的开始时间，即可得到计数到12所需要花费的时间。\n\nround 积木使计算值化为整数以便显示。\n\n## 总结与发散性思考\n\n我们会发现例程2的程序所算得的RPM转速值比例程1的程序所算得的精度更高一些，如果不进行取整，还能有更高的精度。\n\n这样的差异来源于我们设计所要采集的自变量的信息精度不同。\n\n因为编码盘仅有12线，例程1中每1秒所采集的次数都可能因为凹槽与凸块存在实际物理间距而产生误差，最小精度也就仅局限在 5 ，计算的数值都是 5 的倍数。\n\n而例程2采集的自变量信息为时间，其精度受限于micro:bit的时钟精度，但也能做到1ms，这样相对于我们最终计算的RPM的单位 分钟（min）则已经相当精准了，所以这样设计出的程序所能计算出的结果自然有更高的精度。\n\n但我们的程序还有完善的空间，例如万一中途停转，而计数值仍旧卡在0-12中间，那么上一次存储的开始时间就会一直得不到清零，经过很长时间，再到下一次电机开始运行，这样的问题会导致这个时候的第一圈所算得的转速有极大的错误，该如何改善？\n\n除了 **转速** 这一个物理量以外，还有一个很重要的 **加速度** ，又该如何设计程序？"}, "/Q-Car/zh/microbit_tutorial/new_project.html": {"title": "创建MakeCode项目", "content": "# 创建MakeCode项目\n\n1.打开网页链接：\n\n[micro:bit-MakeCode 网页链接](https://makecode.microbit.org/#)\n\n2.可以选择点击网页右上角的齿轮图标，再点击Language即可切换简体中文。但此处还是建议尽量直接使用**英文**，MakeCode 中绝大部分积木名称都与由英文字符组成的程序代码中的各种基础语法单词相对应,这将有利于未来过渡到使用代码编程。\n\n<div align=center>\n<img src=\"../assets/makecode-language.png\" width=\"150\"/>\n</div>\n\n3.点击 New Projects 新建项目，随后给项目取个名字即可。\n\n<div align=center>\n<img src=\"../assets/makecode-new.png\" width=\"150\"/>\n</div>\n\n4.除了将项目保存为一个 `.hex` 文件，还可以作为一个Github项目保存，这需要准备一个[Github](https://github.com/)账户，并与MakeCode关联登录。\n\n<div align=center>\n<img src=\"../assets/makecode-save.png\" width=\"300\"/>\n</div>\n\n5.后续所有例程提供的链接都是 `.hex` 文件的链接，下载它们不需要登录Github账户。在链接所打开的网页中，鼠标右键点击 `Download` 按钮，再点击 `将链接另存为` 即可将`.hex`文件下载至计算机本地硬盘中。\n\n<div align=center>\n<img src=\"../assets/makecode-save_2.png\" width=\"600\"/>\n</div>"}, "/Q-Car/zh/microbit_tutorial/button_control-1.html": {"title": "用microbit按钮控制电机", "content": "# 用microbit按钮控制电机\n\n## 例程\n\n\n<div align=center>\n<img src=\"../assets/Q-Car_Motor_control_module2.png\" width=\"400\"/>\n</div>\n\n[在Github上的例程项目文件](https://github.com/Wind-stormger/Makecode/blob/master/microbit-Qcar-demo-button_control-1.hex)\n\n> 项目文件下载到本地后可导入MakeCode中查看和再编辑，也可直接通过USB烧录到Micro:Bit中运行。\n\n## 设计说明\n\n1. 按下A按钮，Q-Car向前行驶。\n2. 按下B按钮，Q-Car向后行驶。\n3. 同时按下AB按钮，Q-Car停车。\n\n在 on start 积木中加入的 init the motor 积木是用于初始化控制两个电机的PCA9685 芯片，这将在后续文中提到。"}, "/Q-Car/zh/microbit_tutorial/ultrasonic_ranging3.html": {"title": "利用超声波测距使Q-Car自动保持距离", "content": "# 利用超声波测距使Q-Car自动保持距离\n\n## 自动控制\n\n自动控制是相对人工控制这一概念而言的，例如为了保持车与物体之间的间距，人眼在看到车与物体的间距小于一个范围时，需要手动控制车后退拉开距离，\n\n接收到\"车与物体的间距小于一个范围\"这个信息的是人，对收集的信息产生需要如何控制的想法的是人，最后去控制车改变状态的也是人，即是人工控制。\n\n相对的，让设备例如超声波测距传感器接收信息，将信息转化为电讯号传递给处理器，处理器按照既定的程序将与收集到的信息对应该发出的控制信号发给电机驱动模块，\n\n进而改变车的状态使车后退拉开距离，人除了编程和启动这套控制系统以外，再不参与接收信息并反馈控制，这套控制系统即为自动控制系统。\n\n## 例程\n\n<div align=center>\n<img src=\"../assets/microbit-Qcar-demo_ultrasonic1..png\" width=\"700\"/>\n</div>\n\n[在Github上的例程项目文件](https://github.com/Wind-stormger/Makecode/blob/master/microbit-Qcar-demo_ultrasonic1.hex)\n\n> 项目文件下载到本地后可导入MakeCode中查看和再编辑，也可直接通过USB烧录到Micro:Bit中运行。\n\n## 设计说明\n\n在循环中最开始读取一次超声波测距的数值并赋值给一个变量，然后进行关于这个变量的判断：\n\n1. 大于30cm停车\n2. 小于等于30cm且大于10cm则以20%转速前进\n3. 小于等于10cm且大于等于9cm则停车\n4. 小于9cm则以20%转速后退\n\n这有些类似于“自动倒车系统”。"}, "/Q-Car/zh/microbit_tutorial/import_extension.html": {"title": "导入扩展积木", "content": "# 导入扩展积木\n\n1.在MakeCode编辑器中，点击网页右上角的齿轮图标，点击 Extensions 扩展。\n\n<div align=center>\n<img src=\"../assets/makecode-extensions_1.png\" width=\"200\"/>\n</div>\n\n2.进入一个检索各式各样的扩展积木的页面。\n\n<div align=center>\n<img src=\"../assets/makecode-extensions_2.png\" width=\"500\"/>\n</div>\n\n3.在上方搜索栏中输入此链接：`https://github.com/Q-car/Qcar-pxt` 即可看到专用于 Q-Car 的扩展积木。\n\n<div align=center>\n<img src=\"../assets/makecode-extensions_3.png\" width=\"500\"/>\n</div>\n\n4.点击即可添加进项目中，在MakeCode编辑器的积木列表里即可看到几块扩展积木。\n\n<div align=center>\n<img src=\"../assets/makecode-extensions_4.png\" width=\"500\"/>\n</div>"}, "/Q-Car/zh/microbit_tutorial/line_tracking.html": {"title": "巡线行驶（综合应用）", "content": "# 巡线行驶（综合应用）\n\n## 红外对管与白纸上的黑色线路\n\n在Q-Car前轮左右侧各有一个 ITR20001/T24 红外对管。\n\n关于红外对管的特性，在前文“设计光电计数器”章节中已经提到过，红外对管一侧发射红外光，一侧接收红外光，接收端将反射回的光线强弱的信息转化为电压高低的信号。\n\n除了利用编码盘的凸块与凹槽相对红外对管距离的不同来改变电压，也可以利用不同颜色或材质的物体表面对红外光反射率的不同来改变电压。\n\n例如，一张纯白色的纸，其红外光反射率相对较高，用纯黑色油墨印刷上一条黑线，这条黑线的红外光反射率则相对白纸而言较低了。\n\n<div align=center>\n<img src=\"../assets/Infrared_tube_pair_2.png\" width=\"350\"/>\n</div>\n\n利用这样的关系，我们可以通过不断收集两个红外对管的电压高低信息来判断Q-Car相对线路偏左还是偏右，进而不断修正方向达到巡线行驶的目的。\n\n> 关于红外光反射率绝非肉眼在可见光谱中看见的颜色深浅能简单决定的，更深入的相关学科知识可以继续参考[维基百科：吸收光谱学](https://zh.wikipedia.org/wiki/%E5%90%B8%E6%94%B6%E5%85%89%E8%B0%B1%E5%AD%A6)中的内容或是其他相关的文献资料。\n\n## 简单的控制Q-Car巡线\n\nmicro:bit对引脚上电压模拟量的分辨率为10比特，即1024级，对应电压0~3.3v。假设检测电压为 x (0≤x≤3.3)，则micro:bit读取到的模拟量数值为：\n\nf(x) = x ÷ 3.3 × 1024\n\n在黑色线路上方，micro:bit从红外对管读取到的模拟量数值将低于在白色路面上方的数值。\n\n为了实现巡线行驶，我们需要对控制逻辑进行简单分析。\n\n1. 行驶方向偏左时，左侧红外对管在白色路面上方，右侧红外对管在黑色线路上方，需要控制左轮转速大于右轮转速，达到向右修正的目的。\n2. 行驶方向偏右时，右侧红外对管在白色路面上方，左侧红外对管在黑色线路上方，需要控制右轮转速大于左轮转速，达到向左修正的目的。\n3. 行驶方向与线路重合，左右侧红外对管都在白色路面上方，需要控制左右轮转速相等，保持直行。\n\n### 例程1\n\n<div align=center>\n<img src=\"../assets/microbit-Q-car_Line_tracking_easy.png\" width=\"600\"/>\n</div>\n\n[在Github上的例程项目文件](https://github.com/Wind-stormger/Makecode/blob/master/microbit-Q-car_Line_tracking_easy.hex)\n\n> 项目文件下载到本地后可导入MakeCode中查看和再编辑，也可直接通过USB烧录到Micro:Bit中运行。\n\n#### 设计说明\n\n1. 程序开始运行时需要首先进行初始化电机控制，设置红外对管为启动状态。\n2. 例程中设置 700 为参考数值，以此判断红外对管此时是否在黑色线路上方。\n3. 将从两个红外对管采集到的模拟量数值分别进行if判断，右侧的数值小于700则使右电机停转，else为上述条件以外的情况，此处即为右侧的数值大于或等于700时，使右电机全速正转；左侧的数值判断同理。\n\n## 综合应用\n\n### 设计自动校准程序\n\n在例程1中，直接人为给定了一个模拟量数值 700，当检测到红外对管的电压模拟量小于此数值时判断此时在黑色线路上方。\n\n但在实际应用中，最终决定此数值的是物体表面的红外光反射率，即使是肉眼看起来都是白色的纸，不同原材料制成的，甚至是不同的粗糙程度，其红外光反射率都可能有较大差异。\n\n当然，肉眼看起来是黑色的也是如此，只是在日常常见的纸张和黑色油墨中，被黑色油墨涂过的纸确实相对比没涂过的纸的反射率要低一些。\n\n所以我们可以设计一套程序，自动校准例程1中用判断的模拟量数值，以适应不同的条件。\n\n<div align=center>\n<img src=\"../assets/microbit-Q-car_Line_tracking_2.png\"/>\n</div>\n\n#### 设计说明\n\n重复对两个红外对管模拟量采样20次，间隔100ms，各自累加并存储到对应的一个变量中，再除以20以求平均值，取此平均值的四分之三作为后续巡线程序的判断数值。\n\n四分之三也是一个人为设定的数值，一方面我们判断巡线过程中，路面的红外光反射率变化不会使数值低于采样平均值的四分之三，另一方面则是判断黑色线路的红外光反射率变化不会使数值高于于采样平均值的四分之三。\n\n### 将遇障停车加入程序\n\n假如巡线路上被障碍物阻挡，而电机依旧在转动驱使撞向障碍物Q-Car，这不是我们愿意看到的，超声波测距模块的加入也正是为了解决这一问题。\n\n\n<div align=center>\n<img src=\"../assets/microbit-Q-car_Line_tracking_3.png\"/>\n</div>\n\n<div align=center>\n<img src=\"../assets/microbit-Q-car_Line_tracking_4.png\"/>\n</div>\n\n#### 设计说明\n\n当检测到前方物体距离小于等于10cm时将停车。\n\n设计了相对比较保守的消噪策略，仅采纳5~500cm以内的数值，确保电机不会因噪声扰动而意外停车或是停车时意外启动。\n\n### 设计限制措施以保障运行\n\n在仅需要实现少数而简单的功能时，我们的程序并不需要太多限制措施，简简单单，通电即用。\n\n当我们想在程序中实现多种功能时，我们不得不面对一些很少去思考的问题，什么功能的程序先执行？如果多个功能的程序一同循环执行，该如何安排优先度？如果需要在运行某些程序时锁定其他的程序使它们不执行，又该如何设计？\n\n我们可以加入额外的判断条件来做限制，以安排程序执行的先后顺序。\n\n例如在开始巡线行驶之前，我们想先执行完校准程序在开始巡线，且限制一定要先完成这个功能，就可以设计一个变量和一个while循环，变量初始值设为False，以变量值为False作为此while循环的条件，在判断校准完成后使此变量值设为True，即可退出此循环执行巡线行驶的程序了。\n\n而多个功能的程序一同循环执行（俗称**多工**），则可以通过定时器来设置优先级，优先度高的循环执行间隔时间短，优先度低的循环执行间隔时间长，这样可以有效分配处理器的运算资源，保证了高时效性的程序的运算资源需求。\n\n### 例程2\n\n<div align=center>\n<img src=\"../assets/microbit-Q-car_Line_tracking.png\"/>\n</div>\n\n[在Github上的例程项目文件](https://github.com/Wind-stormger/Makecode/blob/master/microbit-Q-car_Line_tracking.hex)\n\n> 项目文件下载到本地后可导入MakeCode中查看和再编辑，也可直接通过USB烧录到Micro:Bit中运行。\n\n#### 设计说明\n\n加入了按键控制。开机运行后，当A按钮被按下且判断未完成校准时，执行自动校准程序，执行完成后使IR_corrected变量值设为为True，再按A按钮则不会重复执行自动校准程序，而这之后再按下B按钮，将使Start_tracking变量值设为True，退出此while循环。\n\n三个Every [ ]ms事件处理程序内都有if判断，当Start_tracking变量值为True时才会循环执行内部的程序。而巡线程序的循环时间为1ms，超声波测距程序的循环时间为100ms，串口输出信息程序的循环时间为1000ms，优先级十分明了。"}, "/Q-Car/zh/microbit_tutorial/PCA9685-PWM.html": {"title": "PCA9685芯片的PWM调速", "content": "# PCA9685芯片的PWM调速\n\n## 简述PCA9685芯片\n\nPCA9685是一款基于I²C总线通信的12位精度16通道PWM波输出的芯片，该芯片最初由NXP推出时主要面向LED开关调光，同样可用于控制舵机、电机等任何可以适用PWM控制的电气设备。\n\n利用I²C总线通信的功能特性，使其常用于拓展主控芯片的控制能力，因为其仅需两根线同主机芯片建立I²C通信，即可替代主控芯片的GPIO引脚来输出PWM波，节省主控芯片资源，这项特点在需要控制的设备数量超过主控芯片的可用GPIO引脚数量时将尤为突出。\n\n<div align=center>\n<img src=\"../assets/PCA9685BS.png\" width=\"300\"/>\n</div>\n\n> 想要深入了解即需要参考[PCA9685芯片数据手册](https://www.nxp.com.cn/docs/en/data-sheet/PCA9685.pdf)\n\n\n## 简述I²C\n\nI²C（Inter-Integrated Circuit）字面上的意思是集成电路之间，它其实是I²C Bus简称，所以中文应该叫集成电路总线，它是一种串行通信总线，使用多主从架构，由飞利浦公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展。\n\n<div align=center>\n<img src=\"../assets/I2C-bus-logo.png\" width=\"200\"/>\n</div>\n\nI²C只使用两条双向漏极开路（Open Drain）线，其中一条线为传输数据的串行数据线（SDA），另一条线是启动或停止传输以及发送时钟序列的串行时钟线（SCL），这两条线上都有上拉电阻。I²C允许相当大的工作电压范围，但典型的电压准位为+3.3V或+5v。\n\nI²C的参考设计使用一个7比特长度的地址空间(2^7＝128)，但保留了16个地址，所以在一组总线最多可和112个节点通信。虽然最大的节点数目是被地址空间所限制住，但实际上也会被总线上的总电容所限制住，一般而言为400 pF，这限制了实际通信时的线路长度只有几米。\n\n> 可以继续参考[百度百科：I²C](https://baike.baidu.com/item/I2C%E6%80%BB%E7%BA%BF/918424?fr=aladdin)与[维基百科：I²C](https://zh.wikipedia.org/wiki/I%C2%B2C)中的内容或是其他相关的文献资料，也可直接参考 [I2C总线规范和用户手册](https://www.nxp.com.cn/docs/en/user-guide/UM10204.pdf) 来更深入的了解其原理。\n\n## 在Q-Car上与PCA9685连接应用\n\nmicro:bit I²C总线的串行时钟线（SCL）由P19引脚引出，串行资料线（SDA）由P20引脚引出。当我们将 micro:bit 与 Q-Car 连接，PCA9685芯片也就与 micro:bit 的I²C总线建立了连接。\n\n在MakeCode编辑器中，可以搜素并添加PCA9685扩展积木：\n<div align=center>\n<img src=\"../assets/makecode-extensions-pca9685.png\" width=\"200\"/>\n</div>\n\n### 例程1\n\n<div align=center>\n<img src=\"../assets/Q-Car_Motor_control_module.png\" width=\"600\"/>\n</div>\n\n[在Github上的例程项目文件](https://github.com/Wind-stormger/Makecode/blob/master/microbit-Q-Car_Motor_control_module.hex)\n\n> 项目文件下载到本地后可导入MakeCode中查看和再编辑，也可直接通过USB烧录到Micro:Bit中运行。\n\n### 设计说明\n\n在例程中主要应用了PCA9685扩展积木中的三个积木。\n\ninit [1][2] 积木用于初始化PCA9685芯片，设置I²C从机的地址与工作频率。\n\nchip adddress[ ] 积木 中填入的是16进制的I²C从机的地址，不用这个积木的话直接填在\ninit [1][2] 积木的[1]空格中的是10进制的。\n\nset pin pulse range[1][2][3][4]积木中[1]选项栏选择PCA9685芯片的引脚编号，[2]空格中填入的是PWM波起始位值，[3]空格中填入的是PWM波终止位值，因为精度为12位，所以[2][3]可填入数值范围为0-4095，[4]空格填入10进制的I²C从机的地址，插入chip adddress[ ] 积木即可填入16进制的。\n\n若设定在[2][3]空格中依次填入x、y值，则大致会有以下四种PWM波形\n\n1. x=0, 0 < y < 4095 时，占空比为y/4095 ![](../assets/PWM-1.png)\n2. 0 < x < 4095,y=4095 时，占空比为(4095-x)/4095 ![](../assets/PWM-2.png)\n3. x < y,0 < x < 4095,0 < y < 4095时，占空比为(y-x)/4095 ![](../assets/PWM-3.png)\n3. y < x,0 < x < 4095,0 < y < 4095时，占空比为(4095-x+y)/4095 ![](../assets/PWM-4.png)\n\n在Q-Car上对电机调速需要的就是对控制电机的PWM波的占空比进行调整，而例程中采取的即是第1种波形来控制占空比。\n\n连接右电机正极的是PCA9685的P0，负极是P1，左电机正极是P3，负极是P2。\n\n所以在例程中，按一下A按钮，左右电机将同时正转2s，同时反转2s，右电机单独正转2s，左电机单独正转2s，最后两电机都停转。\n\n## Q-Car扩展积木的PWM调速\n\n在例程1中的PCA9685扩展积木相对原始的展示了该芯片如何输出与调整PWM的。而在Q-Car扩展积木中将用于控制两个电机转速与转向的程序一起封装为1个积木以便使用，这其实也近似于例程1中使用的 function函数积木，都是将程序装入内部然后提供一些可供外部调整的变量，以便在其他程序中有效利用，区别就是不再将内部程序用图形积木来展示。\n\n> 事实上所有的积木都是对程序的一种“封装”，在MakeCode编辑器中切换至JavaScript代码编辑器即可看到它们的代码。\n\n### 例程2\n\n<div align=center>\n<img src=\"../assets/microbit-Qcar-demo-button_control-2.png\" width=\"400\"/>\n</div>\n\n[在Github上的例程项目文件](https://github.com/Wind-stormger/Makecode/blob/master/microbit-Qcar-demo-button_control-2.hex)\n\n> 项目文件下载到本地后可导入MakeCode中查看和再编辑，也可直接通过USB烧录到Micro:Bit中运行。\n\n### 设计说明\n\nQ-Car 的电机调速扩展积木可选左右两轮分别调整其正反转，以及100级PWM占空比，每1级对应增加1%占空比。\n\n按一次A按钮将增加变量值使占空比增加10%，到达100%占空比后再按一次A按钮将通过 if 判断置零。\n\nmicro:bit将循环显示当前占空比数值。\n\n我们可以应用类似的思路，在其他任何程序中通过控制变量的方式来调整电机转速。"}}