{"/WebBit_doc/zh/micropython/pythonStd/uzlib.html": {"title": "uzlib - zlib解压缩", "content": "uzlib - zlib解压缩\n==================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [zlib](https://docs.python.org/zh-cn/3/library/zlib.html#module-zlib)\n\n该模块允许解压用DEFLATE算法（常用于zlib库和gzip压缩程序）压缩的二进制数据。压缩尚未实现。\n\n函数\n---------\n\n```python\nuzlib.decompress(data, wbits=0, bufsize=0)\n```\n   将解压缩数据返回为字节。 *wbits* 是压缩时使用的DEFLATE字典窗口大小（8-15，字典的大小为该数值的2次幂）。\n   另外，若该值为正， *data* 则被假定为zlib流（带有zlib首标）。否则，若该值为负，\n   则假定为原始DEFLATE流。 *bufsize* 参数是为与CPython兼容，此处忽略。\n\n```python\nuzlib.DecompIO(stream, wbits=0)\n```\n   创建一个流装饰器，该装饰器允许在另一个流中进行压缩数据的透明解压。\n   这允许使用大于可用堆大小的数据处理压缩流。除 `decompress()` 中所述的值外， *wbits* 可能取值24..31 (16 + 8..15)，这也就意味着输入流带有gzip首标。\n\n> 与CPython区别\n该类为MicroPython的扩展，暂时使用该类，在后续版本中可能会进行较大的修改或删除。"}, "/WebBit_doc/zh/micropython/pythonStd/math.html": {"title": "math - 数学运算函数", "content": "math - 数学运算函数\n=====================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档:[math](https://docs.python.org/zh-cn/3/library/math.html#module-math).\n\n该 ``math`` 模块提供了一些处理浮点数的基本数学函数.\n\n*注意:* 在pyboard上，浮点数具有32位精度.\n\n\nFunctions\n---------\n\n```python\nacos(x)\n```\n  返回的反余弦值 ``x``.\n\n```python\nacosh(x)\n```\n   返回反双曲余弦值 ``x``.\n\n```python\nasin(x)\n```\n   R返回反正弦 ``x``.\n\n```python\nasinh(x)\n```\n   返回反双曲正弦 ``x``.\n\n```python\natan(x)\n```\n   返回反正切 ``x``.\n\n```python\natan2(y, x)\n```\n   返回反正切的主值 ``y/x``.\n\n```python\natanh(x)\n```\n  返回反双曲正切值 ``x``.\n\n```python\nceil(x)\n```\n   返回一个整数， ``x`` 向正无穷大舍入.\n   \n\n```python\ncopysign(x, y)\n```\n   回来 ``x`` 的标志 ``y`` .\n\n```python\ncos(x)\n```\n   返回余弦 ``x``.\n\n```python\ncosh(x)\n```\n   返回的双曲余弦值 ``x``.\n\n```python\ndegrees(x)\n```\n   返回弧度 ``x`` 转换为度数.\n\n```python\nerf(x)\n```\n   返回错误函数 ``x``\n\n```python\nerfc(x)\n```\n   返回互补误差函数  ``x``.\n\n```python\nexp(x)\n```\n   返回指数 ``x``.\n\n```python\nexpm1(x)\n```\n   返回 ``exp(x) - 1``.\n\n```python\nfabs(x)\n```\n   返回绝对值 ``x``.\n\n```python\nfloor(x)\n```\n   返回一个整数， ``x`` 向负无穷大舍入。\n\n```python\nfmod(x, y)\n```\n   归还剩下的 ``x/y``.\n\n```python\nfrexp(x)\n```\n将浮点数分解为尾数和指数。返回的值是元组 ``(m, e)`` 这样 ``x == m * 2**e`` \n完全正确。如果 ``x == 0`` ，则函数返回 ``(0.0,0)`` ，否则``0.5 <= abs(m) < 1``.\n\n```python\ngamma(x)\n```\n   返回的伽玛函数 ``x``.\n\n```python\nisfinite(x)\n```\n   如果 ``x`` 是有限,则返回 ``True``.\n\n```python\nisinf(x)\n```\n   如果 ``x`` 是无限,则返回 ``True``.\n\n```python\nisnan(x)\n```\n   如果 ``x`` 不是数字,则返回 ``True``.\n\n```python\nldexp(x, exp)\n```\n   返回 ``x * (2**exp)``.\n\n```python\nlgamma(x)\n```\n   返回伽玛函数的自然对数 ``x``.\n\n```python\nlog(x)\n```\n   返回自然对数 ``x``.\n\n```python\nlog10(x)\n```\n  返回基数为10的对数 ``x``.\n\n```python\nlog2(x)\n```\n  返回基数为2的对数 ``x``.\n\n```python\nmodf(x)\n```\n   返回一个由两个浮点数组成的元组，它是数字的分数和不可分割的部分 `` x`` .两个返回值都具有相同的符号 ``x`` .\n\n```python\npow(x, y)\n```\n   返回  ``x `` 的 ``y`` 次方.\n\n```python\nradians(x)\n```\n   返回 ``x`` 度转换为弧度.\n\n```python\nsin(x)\n```\n   回归正弦 ``x``.\n\n```python\nsinh(x)\n```\n  返回双曲线的正弦曲线 ``x``.\n\n```python\nsqrt(x)\n```\n  返回平方根  ``x``.\n\n```python\ntan(x)\n```\n   返回正切值 ``x``.\n\n```python\ntanh(x)\n```\n   返回双曲正切值 ``x``.\n\n```python\ntrunc(x)\n```\n  返回一个整数， ``x`` 向0舍入.\n\nConstants\n---------\n\n``e`` 自然对数的底\n\n``pi`` 圆周长与直径之比"}, "/WebBit_doc/zh/micropython/pythonStd/ure.html": {"title": "ure - 正则表达式", "content": "ure - 正则表达式\n========================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [re](https://docs.python.org/zh-cn/3/library/re.html#module-re)\n\n该模块实现正则表达式操作。支持的正则表达式语法是CPython re 模块的一个子集（实际上是POSIX扩展正则表达式的子集）。\n\n支持的操作符和特殊序列是:\n\n``.``\n匹配任何字符。\n\n``[···]``\n匹配字符集。支持单个字符和范围，包括负集(例如 [^a-c])。\n\n``^``\n匹配字符串的开头。\n\n``$``\n匹配字符串的结尾。\n\n``?``\n匹配零个或前面的子模式之一。\n\n``*``\n匹配零个或多个先前的子模式。\n\n``+``\n匹配一个或多个先前的子模式。\n\n``??``\nNon-greedy版本的 ? ，匹配0或1，偏好零。\n``*?``\nNon-greedy版本的 * ，匹配零个或多个，并偏好最短的匹配。\n``+?``\nNon-greedy版本的 + ，匹配一个或多个，并偏好最短的匹配。\n``(···)``\n分组。每个组都在捕获(它捕获的子字符串可以通过`match.group()`方法访问)。\n\n`\\d`\n\n数字匹配。相当于 `[0-9]` 。\n\n`\\D`\n\n非数字匹配。相当于 `[^0-9]` 。\n\n`\\s`\n\n匹配空格。相当于 `[ \\t-\\r]` 。\n\n`\\S`\n\n匹配非空格。相当于 `[^ \\t-\\r]` 。\n\n`\\w`\n\n匹配”单词字符” (仅限ASCII)。\\[相当于 `[A-Za-z0-9_]` 。\n\n`\\W`\n\n匹配非“单词字符”（仅限ASCII）。相当于 `[^A-Za-z0-9_]` 。\n\n`\\`\n\n转义字符。反斜杠后的任何其他字符（上面列出的字符除外）均按字面意义使用。例如，`\\*` 是相当于文本 `*``（不作为 ``*` 运算符处理）。 请注意，`\\r`, `\\n` 等没有特别处理，将相当于字面字母 `r`, `n` 等。因此不建议将原始Python字符串（ `r\"\"` ）用于常规表达。 例如，`r\"\\r\\n\"` 用作常规表达式等价于 `\"rn\"` 。若要匹配后跟LF的CR字符，请使用 `\"\\r\\n\"` 。\n\n**不支持**：\n\n*   重复次数 (`{m,n}`)\n    \n*   命名组 (`(?P<name>...)`)\n    \n*   非捕获组(`(?:...)`)\n    \n*   更高级的断言(`\\b`, `\\B`)\n    \n*   特殊字符转义，如 `\\r`, `\\n` \\- 改用Python自己的转义\n    \n*   等等。\n\n例子:\n```python\nimport ure\n\n# As ure doesn't support escapes itself, use of r\"\" strings is not recommended.\n# 由于ure本身不支持转义，所以不推荐使用r\"\"字符串\n\nregex = ure.compile(\"[\\r\\n]\")\n\nregex.split(\"line1\\rline2\\nline3\\r\\n\")\n\n# 结果:\n# ['line1', 'line2', 'line3', '', '']\n```\n\n函数\n---------\n\n```python\nure.compile(regex_str)\n```\n编译正则表达式，返回 `正则表达式对象`。\n\n```python\nmatch(regex_str, string)\n```\n将 正则表达式对象 与 `string` 匹配。匹配通常从字符串的起始位置进行。\n\n```python\nure.search(regex_str, string)\n```\n在 `string` 中搜索 正则表达式对象 。与 `match` 不同，这将首先搜索与正则表达式相匹配的字符串（若正则表达式固定，则字符串为0）。\n\n```python\nure.sub(regex_str, replace, string, count=0, flags=0)\n```\n编译 regex_str 并在 string 中搜索它，用 replace 替换所有匹配项，然后返回新字符串。\n\nreplace 可以是字符串或函数。如果是字符串，则可以使用格式为 `\\<number>` 和 `\\g<number>` 的转义序列扩展到相应的组（对于不匹配的组，则为空字符串）。 如果 replace 是一个函数，则它必须采用单个参数（匹配项）并应返回替换字符串。\n\n如果指定了 count ，并且非零，那么在进行了相应次数的替换之后，替换将停止。忽略 flags 参数。\n\n注意：此方法的可用性取决于 `MicroPython port` 。\n\n```python\nure.DEBUG\n```\n\n标记值，显示有关已编译表达式的调试信息。\n\n\n\n正则表达式对象\n-------------\n\n编译正则表达式。该类实例使用`ure.compile()`创建。\n\n```python\nregex.match(string)\nregex.search(string)\nregex.sub(replace, string, count\\=0, flags\\=0)\n```\n与模块级函数 `match()` 和 `search()` 相似。若将同一正则表达式应用于多个字符串，则使用该方法会大大提高效率。\n\n```python\nregex.split(string, max\\_split\\=\\- 1)\n```\n使用正则表达式拆分字符串。若给定，则指定将拆分的最大数量。返回字符串列表（若指定，则可能会有多达 max\\_split+1 个元素）。\n\n## Match 对象\n\n匹配由 `match()` 和 `search()` 方法返回的对象。 并传递给 `sub()` 中的替换函数。\n\n```python\nmatch.group(index)\n```\n返回匹配（子）字符串。若完全匹配 index 为0， 对于每个捕获组为1或更多。 仅支持数字组。\n\n```python\nmatch.groups()\n```\n返回一个包含该匹配组的所有子字符串的元组。\n\n注意：此方法的可用性取决于 `MicroPython port` 。\n\n```python\nmatch.start(\\[index\\])\nmatch.end(\\[index\\])\n```\n返回匹配的子字符串组的起始或结束的原始字符串中的索引。index 默认为整个组，否则将选择一个组。\n\n注意：这些方法的可用性取决于 `MicroPython port` 。\n\n```python\nmatch.span(\\[index\\])\n```\n返回2元组 `(match.start(index), match.end(index))` 。\n\n注意：此方法的可用性取决于 `MicroPython port` 。"}, "/WebBit_doc/zh/micropython/pythonStd/uheapq.html": {"title": "uheapq - 堆队列算法", "content": "uheapq - 堆队列算法\n=====================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [heapq](https://docs.python.org/zh-cn/3/library/heapq.html#module-heapq)\n\nT该模块实现堆队列算法。\n\n堆队列只是一个以某种方式存储其元素的列表。\n\n函数\n---------\n\n```python\nheappush(heap, item)\n```\n将 ``item`` 载入 ``heap`` 中。\n\n```python\nheappop(heap)\n```\n从 ``heap`` 中提取首个项，并返回。若堆为空，则引发Index错误。\n\n```python\nheapify(x)\n```\n将列表 ``x`` 转换为一个堆。此为就地操作。"}, "/WebBit_doc/zh/micropython/pythonStd/ucollections.html": {"title": "ucollections - 容器数据类型", "content": "ucollections - 容器数据类型\n=====================================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [collections](https://docs.python.org/zh-cn/3/library/collections.html#module-collections)\n\n此模块实现高级集合和容器类型以保存/累积各种对象。\n\n类\n-------\n\n```python\nubinascii.deque(iterable, maxlen[, flags])\n```\nDeques（双端队列）是一个类似列表的容器，支持O（1）追加并从双端队列的任一侧弹出。使用以下参数创建新的deques：\n\n* iterable必须是空元组，并且新的deque创建为空。\n* 必须指定maxlen并将双端队列限制为此最大长度。一旦双端队列已满，添加的任何新项目将丢弃对方的项目。\n* 添加项目时，可选标志可以为1以检查溢出。\n\n除了支持 ``bool`` 和 ``len`` deque对象还有以下方法：\n\n```python\nubinascii.deque.append(x)\n```\n在deque的右边加上x。如果启用溢出检查，并且没有剩余的空间，则会引发索引错误。\n\n```python\nubinascii.deque.popleft()\n```\n从deque的左侧移除并返回一个项目。如果没有项出现，就会引起索引错误。\n\n\n```python\nubinascii.namedtuple(name, fields)\n```\n这是工厂功能，用于创建一个具有特定名称和一组字段的新的namedtuple类型。\n一个namedtuple是元组的子类，它允许不仅通过数字索引来访问它的字段，而且使用符号字段名称的属性访问语法。\n字段是指定字段名称的字符串序列。为了与CPython兼容，它也可以是一个名为空格分隔字段的字符串（但效率较低）。\n\n使用示例:\n```python\nfrom ucollections import namedtuple\n\nMyTuple = namedtuple(\"MyTuple\", (\"id\", \"name\"))\nt1 = MyTuple(1, \"foo\")\nt2 = MyTuple(2, \"bar\")  \nprint(t1.name)\nassert t2.name == t2[1]\n```\n\n```python\nubinascii.OrderedDict(...)\n```\n``dict`` 类型子类，它能记住和保留添加的keys的顺序。当遍历有序字典时，keys/items按照添加的顺序返回::\n```python\nfrom ucollections import OrderedDict\n\n# To make benefit of ordered keys, OrderedDict should be initialized\n# from sequence of (key, value) pairs.\nd = OrderedDict([(\"z\", 1), (\"a\", 2)])\n# More items can be added as usual\nd[\"w\"] = 5\nd[\"b\"] = 3\nfor k, v in d.items():\n   print(k, v)\n```\n\nOutput:\n```\nz 1\na 2\nw 5\nb 3\n```"}, "/WebBit_doc/zh/micropython/pythonStd/sys.html": {"title": "sys - 系统特定功能", "content": "sys - 系统特定功能\n=======================================\n\nsys模块中提供了与MicroPython运行环境有关的函数和变量。\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [sys](https://docs.python.org/zh-cn/3/library/sys.html#module-sys)\n\n\nFunctions\n---------\n\n```python\nsys.exit(retval=0)\n```\n   使用给定的退出代码终止当前程序。在此基础上，此功能提升为 ``SystemExit`` 。如果给出一个参数，则将其值作为参数给出 ``SystemExit``  。\n\n```python\nsys.print_exception(exc, file=sys.stdout)\n```\n\n通过回溯到类文件对象文件（或 ``sys.stdout`` 默认情况下）来打印异常。\n\n> 与CPython的区别\n> 这是 ``traceback``  CPython模块中出现的函数的简化版本 。与 ``traceback.print_exception()`` 此不同，此函数仅使用异常值而不是异常类型，异常值和回溯对象; file参数应该是位置的; 不支持其他参数。\n> ``traceback``  可以找到CPython兼容 模块 ``micropython-lib`` 。\n\n常量\n---------\n\n```python\nsys.argv\n```\n当前程序启动的可变参数列表。\n\n```python\nsys.byteorder\n```\n系统的字节顺序（ ``little`` 或 ``big`` ）。\n\n```python\nsys.implementation\n```\n包含有关当前Python实现的信息的对象。对于MicroPython，它具有以下属性：\n\n* *name* - 字符串 \"micropython\"\n* *version* - 元组 (major, minor, micro), e.g. (1, 7, 0)\n\n这个方法推荐用来识别不同平台的MicroPython。\n\n\n示例:\n```\n>>> print(sys.implementation)\n(name='micropython', version=(1, 9, 1))\n```\n\n```python\nsys.maxsize\n```\n本机整数类型可以在当前平台上保存的最大值，或MicroPython整数类型可表示的最大值，如果它小于平台最大值\n（对于没有长int支持的MicroPython端口的情况）。\n\n此属性对于检测平台的“位数”（32位与64位等）非常有用。建议不要直接将此属性与某个值进行比较，而是计算其中的位数:\n\n```python\nbits = 0\nv = sys.maxsize\nwhile v:\n   bits += 1\n   v >>= 1\nif bits > 32:\n   # 64-bit (or more) platform\n   ...\nelse:\n   # 32-bit (or less) platform\n   # Note that on 32-bit platform, value of bits may be less than 32\n   # (e.g. 31) due to peculiarities described above, so use \"> 16\",\n   # \"> 32\", \"> 64\" style of comparisons.\n```\n\n```python\nsys.modules\n```\n已载入模块字典。在某些移植版中，它可能不包含在内建模块中。\n\n```python\nsys.path\n```\n用于搜索导入模块的可变目录列表。\n\n```python\nsys.platform\n```\n   获取MicroPython运行的平台。\n\n```python\nsys.stderr\n```\n  标准错误 ``stream``\n\n```python\nsys.stdin\n```\n   标准输入 ``stream``\n\n```python\nsys.stdout\n```\n   标准输出 ``stream``\n\n```python\nsys.version\n```\n返回 MicroPython 语言版本，字符串\n\n```python\nsys.version_info\n```\n   返回 MicroPython 语言版本，整形元组"}, "/WebBit_doc/zh/micropython/pythonStd/ustruct.html": {"title": "ustruct - 打包和解压缩原始数据类型", "content": "ustruct - 打包和解压缩原始数据类型\n======================================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [struct](https://docs.python.org/zh-cn/3/library/struct.html#module-struct)\n\n\n支持的大小/字节顺序前缀: ``@``, ``<``, ``>``, ``!``.\n\n支持的格式编码: ``b``, ``B``, ``h``, ``H``, ``i``, ``I``, ``l``,\n``L``, ``q``, ``Q``, ``s``, ``P``, ``f``, ``d`` 后两个取决于浮点支持）。\n\n函数\n---------\n\n```python\nustruct.calcsize(fmt)\n```\n   返回需存入给定 *fmt* 的字节数量。\n\n```python\nustruct.pack(fmt, v1, v2, ...)\n```\n   根据格式字符串fmt，打包 *v1, v2, ...* 值。返回值为一个解码该值的字节对象。\n\n```python\nustruct.pack_into(fmt, buffer, offset, v1, v2, ...)\n```\n   根据格式字符串fmt，将 *v1, v2, ...* 值打包进从 *offset* 开始的缓冲区。从缓冲区的末端计数， *offset* 可能为负值。\n\n```python\nustruct.unpack(fmt, data)\n```\n   根据格式字符串 *fmt* 对数据进行解压。返回值为一个解压值元组。\n\n```python\nustruct.unpack_from(fmt, data, offset=0)\n```\n   根据格式字符串 *fmt* 解压从 *offset* 开始的数据。从缓冲区的末端计数， *offset* 可能为负值。返回值是一个解压值元组。"}, "/WebBit_doc/zh/micropython/pythonStd/index.html": {"title": "Python 标准库", "content": "Python 标准库\n===========\n\n标准的Python库被 “微型化”后，就是micropython标准库。它们仅仅提供了该模块的核心功能。一些模块没有直接使用标准的Python的名字，而是冠以\"u\"，例如 ``ujson`` 代替 ``json`` 。也就是说micropython标准库（=微型库），只实现了一部分模块功能。\n通过他们的名字不同，用户有选择的去写一个Python级模块扩展功能，也是为实现更好的兼容性。。\n\n在嵌入式平台上，可添加Python级别封装库从而实现命名兼容CPython，微模块即可调用他们的u-name，也可以调用non-u-name。\n根据non-u-name包路径的文件可重写。\n\n例如，``import json`` 的话，首先搜索一个 ``json.py`` 文件或 ``json`` 目录进行加载。\n如果没有找到，它回退到加载内置 ``ujson`` 模块。\n\n> CPython是用C语言实现的Python解释器，也是官方的并且是最广泛使用的Python解释器。除了CPython以外，还有用JAVA实现的Jython和用.NET实现的IronPython，使Python方便地和JAVA程序、.NET程序集成。另外还有一些实验性的Python解释器比如PyPy，使用Python再把Python实现了一遍。\n> CPython是使用字节码的解释器，任何程序源代码在执行之前先要编译成字节码。它还有和几种其它语言（包括C语言）交互的外部函数接口。\n> [Python标准库文档](https://docs.python.org/zh-cn/3/library/index.html) - CPython文档\n\n- builtin – 内建函数\n- array – 数值数组\n- gc – 回收内存碎片\n- math – 数学运算函数\n- sys – 系统特定功能\n- ubinascii – 二进制/ ASCII转换\n- ucollections – 容器数据类型\n- uerrno – 系统错误代码\n- uhashlib – 散列算法\n- uheapq – 堆队列算法\n- uio – 输入/输出流\n- ujson – JSON 编码和解码\n- os – 操作系统\n- ure – 正则表达式\n- select – 等待流事件\n- usocket – socket 模块\n- ussl – SSL/TLS 模块\n- ustruct – 打包和解压缩原始数据类型\n- time – 时间相关函数\n- uzlib – zlib解压缩"}, "/WebBit_doc/zh/micropython/pythonStd/uhashlib.html": {"title": "uhashlib - 散列算法", "content": "uhashlib - 散列算法\n=====================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [hashlib](https://docs.python.org/zh-cn/3/library/hashlib.html#module-hashlib)\n\n该模块实现二进制数据散列算法。可用算法的确切清单取决于board。在可以实现的算法中：\n\n* SHA256 -  当前一代的现代哈希算法（SHA2系列）。它适用于加密安全目的。除非具有特定的代码大小限制，否则建议使用MicroPython内核和任何板提供此功能。\n\n* SHA1 - 上一代算法。不建议用于新用途，但SHA1是许多Internet标准和现有应用程序的一部分，因此针对网络连接和互操作性的板将尝试提供此功能。\n\n* MD5 - 遗留算法，不被认为是加密安全的。只有选定的电路板才能实现与传统应用的互操作性。\n\n构建对象\n------------\n\n```python\nclass uhashlib.sha256([data])\n```\n创建一个SHA256哈希对象，并可选择 ``data`` 输入其中。\nCreate an SHA256 hasher object and optionally feed ``data`` into it.\n\n```python\nclass uhashlib.sha1([data])\n```\n创建一个SHA1哈希对象，并可选择 ``data`` 将其输入其中。\n\n```python\nclass uhashlib.md5([data])\n```\n创建MD5哈希对象并可选择 ``data`` 将其输入其中。\n\n方法\n-------\n\n```python\nhash.update(data)\n```\n将更多的二进制数据馈入散列\n\n```python\nhash.digest()\n```\n返回通过哈希传递的所有数据的散列，作为字节对象。调用此方法后，无法再将更多的数据送入散列。\n\n```python\nhash.hexdigest()\n```\n此方法未实现。使用 ``ubinascii.hexlify(hash.digest())`` 来达到类似的效果。"}, "/WebBit_doc/zh/micropython/pythonStd/builtins.html": {"title": "builtin - 内建函数", "content": "builtin - 内建函数\n================================\n\n此处描述了所有内置函数和异常。它们也可通过 ``builtins`` 模块获取。\n\nFunctions and types\n-------------------\n\n```python\nabs()\n\nall()\n\nany()\n\nbin()\n\nclass bool()\n\nclass bytearray()\n\nclass bytes()\n#参考CPython文档：https://docs.python.org/zh-cn/3/library/functions.html#bytes\n\ncallable()\n\nchr()\n\nclassmethod()\n\ncompile()\n\nclass complex()\n\ndelattr(obj, name)\n#参数名应该是一个string，这个函数从obj给出的对象中删除命名属性.\n\nclass dict()\n\ndir()\n\ndivmod()\n\nenumerate()\n\neval()\n\nexec()\n\nfilter()\n\nclass float()\n\nclass frozenset()\n\ngetattr()\n\nglobals()\n\nhasattr()\n\nhash()\n\nhex()\n\nid()\n\ninput()\n\nclass int()\n    from_bytes(bytes, byteorder)\n    #在MicroPython中， `byteorder` 参数必须是位置的（这与CPython兼容）\n\n\n    to_bytes(size, byteorder)\n    #在MicroPython中， `byteorder` 参数必须是位置的（这与CPython兼容）\n    \n\nisinstance()\n\nissubclass()\n\niter()\n\nlen()\n\nclass list()\n\nlocals()\n\nmap()\n\nmax()\n\nclass memoryview()\n\nmin()\n\nnext()\n\nclass object()\n\noct()\n\nopen()\n\nord()\n\npow()\n\nprint()\n\nproperty()\n\nrange()\n\nrepr()\n\nreversed()\n\nround()\n\nclass set()\n\nsetattr()\n\nclass slice()\n#slice内置函数是slice对象的类型.\n\nsorted()\n\nstaticmethod()\n\nclass str()\n\nsum()\n\nsuper()\n\nclass tuple()\n\ntype()\n\nzip()\n```\n\nExceptions\n----------\n\n```python\nexception AssertionError\n\nexception AttributeError\n\nexception Exception\n\nexception ImportError\n\nexception IndexError\n\nexception KeyboardInterrupt\n\nexception KeyError\n\nexception MemoryError\n\nexception NameError\n\nexception NotImplementedError\n\nexception OSError\n#参考CPython文档： ``OSError`` . MicroPython不实现 ``errno``  属性，而是使用标准方式访问异常参数： ``exc.args[0]`` .\n\nexception RuntimeError\n\nexception StopIteration\n\nexception SyntaxError\n\nexception SystemExit\n#参考CPython文档： ``SystemExit`` .\n\nexception TypeError\n#参考CPython文档： ``SystemExit`` .\n\nexception ValueError\n\nexception ZeroDivisionError\n```"}, "/WebBit_doc/zh/micropython/pythonStd/uselect.html": {"title": "select - 等待流事件", "content": "select - 等待流事件\n========================================================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [select](https://docs.python.org/zh-cn/3/library/select.html#module-select)\n\n该模块提供了有效等待多个 :term:`stream` （选择可用于操作的流）上的事件的功能。\n\n函数\n---------\n\n```python\nuselect.poll()\n```\n创建轮询实例。\n\n```python\nuselect.select(rlist, wlist, xlist[, timeout])\n```\n监控对象何时可读或可写，一旦监控的对象状态改变，返回结果（阻塞线程）。\n这个函数是为了兼容，效率不高，推荐用 poll 函数。\n\n- ``rlist``：等待读就绪的文件描述符数组\n- ``wlist``：等待写就绪的文件描述符数组\n- ``xlist``：等待异常的数组\n- ``timeout``：等待时间（单位：秒）\n\n\n类 Poll\n--------------\n\n方法\n\n```python\npoll.register(obj, flag)\n```\n注册一个用以监控的对象，并设置被监控对象的监控标志位flag。\n\n- ``obj`` :被监控的对象\n- ``flag`` :被监控的标志\n\n - ``select.POLLIN``  - 读取可用数据\n - ``select.POLLOUT`` - 写入更多数据\n - ``select.POLLERR`` - 发生错误\n - ``select.POLLHUP`` - 流结束/连接终止检测\n\n``flag`` 默认为 ``select.POLLIN | select.POLLOUT``.\n\n```python\npoll.unregister(obj)\n```\n\n解除监控的对象``obj`` 的注册。\n\n```python\npoll.modify(obj, flag)\n```\n\n修改已注册的对象 ``obj`` 监控标志 ``flag`` 。\n\n```python\npoll.poll([timeout])\n```\n等待至少一个注册对象准备就绪。返回（``obj`` , ``event`` , …）元组的列表， ``event`` 元素指定使用流发生的事件，\n并且是 ``select.POLL*``  上述常量的组合。在tuple中可能还有其他元素，具体取决于平台和版本，因此不要认为它的大小是2.\n如果超时，返回一个空列表。\n\n超时是毫秒。\n\n> 与CPython区别\n> 如上所述，返回的元组可能包括多于2个元素。\n\n```python\npoll.ipoll([timeout])\n```\n与 `poll.poll` 类似，但是返回一个产生被调用函数所有元组的迭代器。该函数提供高效的、无位置的在流中进行轮询的方法。\n\n\n> 与CPython区别\n> 该函数是MicroPython的扩展。"}, "/WebBit_doc/zh/micropython/pythonStd/uio.html": {"title": "uio - 输入/输出流", "content": "uio - 输入/输出流\n==================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [io](https://docs.python.org/zh-cn/3/library/io.html#module-io)\n\n此模块包含其他类型的stream（类文件）对象和帮助程序函数。\n\n概念层次\n--------------------\n\n> 与CPython的区别\n> 如本节所述，MicroPython中简化了流基类的概念层次结构。\n\n正如在本部分中所述，流基类的概念层次结构在MicroPython中简化。\n\n（摘要）基流类作为所有具体类行为的基础，在CPython中保持较少的二排序（两两排序法）。在MicroPython中，基流类被简化并隐藏以提高效率和节省资源。\n\nCPython中一个重要的二分法是无缓冲对缓冲流。在MicroPython 中，所有流目前都未缓冲。这是因为所有现代操作系统， 甚至许多实时操作系统和文件系统驱动程序都已在侧面执行了缓冲。添加另一缓冲层会产生相反效果（称为“缓冲过满”的问题）， 且需占用宝贵的内存。注意：在某些情况下，缓冲可能有用，因此我们会在后面介绍一些可供选择的缓冲支持。\n\n但是在CPython中，另一个重要二分法是与“缓冲性”联系在一起的，即流是否会引发短读/短写。短读即当用户从流中请求10个字节时， 但是所得少于该数量，短写与之相似。在CPython中，未缓冲流会自动进行短操作，而缓冲是对其的保证。非短读/写是一个重要特性， 由此我们得以开发更简洁高效的程序—非常适合MicroPython的程序。因此，尽管MicroPython不支持缓冲流，但仍适合非短操作流。 是否有短操作取决于每个特定类的需求，但是出于上述原因，强烈建议开发人员支持非短操作的行为。例如： MicroPython套接字就确保避免短 读/写。实际上，此时在核心中并无短操作流类的示例，一例是特定于端口的类，在这种情况下需由硬件特性来控制需求。\n\n非短操作行为在非阻塞流情况会很棘手，阻塞对非阻塞的行为为CPython的另一种二分法，并受MicroPython完全支持。 非阻塞流不会等待数据到达或写入—而会读取/写入任何可能的数据或标记数据的缺乏（或写入数据的能力）。显而易见， 这与“非短操作”的方法相矛盾。的确，在CPython中，非阻塞缓冲流的情况非常复杂。在某些地方，这种结合是被禁止的； 在某些地方，未给出明定义或没有文档说明；在某些情况下。会引发较为复杂的异常。在MicroPython中，情况就简单多了： 非阻塞流对高效的异步操作至关重要，因此这一特性在“非短期操作”中占优先地位。所以，阻塞流会在任何情况下都尽可能避免短读/短写 （短读仅在到达文件末尾或发产生误差时出现（但是误差不会返回短数据，而会引发异常）），非阻塞流会产生短数据以避免阻碍操作。\n\n最后一种二分法是二进制vs文本流。MicroPython支持这两种形式，但是在CPython中，文本流本质上就是缓冲的，它们并不在MicroPython中。（实际上，这就是我们引入缓冲支持的情况之一。）\n\n注意：为提高效率，MicroPython不提供与以上层次结构相对应的抽象基类，并且不可能实现纯Python中的流类或将之归入子类。\n\n函数\n---------\n\n```python\nuio.open(name, mode='r', **kwargs)\n```\n   打开一个文件。内置open()函数是此函数的别名。\n\n类\n-------\n\n```python\nclass FileIO(...)\n```\n这是以二进制模式打开的文件类型，例如使用 ``open(name, \"rb\")`` \n您不应该直接实例化这个类。\n\n```python\nclass TextIOWrapper(...)\n```\n这是在文本模式下打开的文件类型，例如使用 ``open(name, \"rt\")`` 。\n您不应该直接实例化这个类。\n\n```python\nclass StringIO([string])\n```\n```python\nclass BytesIO([string])\n```\n\n用于输入/输出的内存文件类对象。 ``StringIO`` 用于文本模式I / O（类似于使用“t”修饰符打开的普通文件）。``BytesIO`` 用于二进制模式I ​​/ O（类似于使用“b”修饰符打开的普通文件）。可以使用字符串参数指定类文件对象的初始内容（应为普通字符串StringIO或字节对象BytesIO）。\n所有常见的文件的方法，如 ``read()`` ， ``write()`` ， ``seek()`` ， ``flush()`` ， ``close()``  在这些对象上可用以下的方法:\n\n```python\ngetvalue()\n```\n获取保存数据的底层缓冲区的当前内容。"}, "/WebBit_doc/zh/micropython/pythonStd/utime.html": {"title": "time - 时间相关函数", "content": "time - 时间相关函数\n======================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [time](https://docs.python.org/zh-cn/3/library/time.html#module-time)\n\n``time`` 模块提供用于获取当前时间和日期、测量时间间隔和延迟的函数。\n\n**Time Epoch**: Unix端口使用1970-01-01 00:00-00:00 UTC的POSIX系统时间的标准。但是，内嵌端口使用2000-01-01 00:00:00 UTC的时间。\n\n\n**维护实际日历日期/时间**: 这需要实时通信（RTC）。在具备底层OS的系统中，RTC可能是隐式的。设置和维护实际日历时间应是OS/RTOS的职能，\n且在MicroPython之外完成，只使用OS API查询日期/时间。在baremetal端口中，系统时间取决于 ``machine.RTC()`` 对象。\n当前日历时间可能使用 ``machine.RTC().datetime(tuple)`` 函数来设置，并通过以下方式维护:\n\n* 由一个备用电池（对于特定板而言，可能是一个额外的可选组件）。\n* 使用网络时间协议（需要通过一个端口/用户安装）。\n* 每次开启电源都进行手动设置（许多板通过硬复位维护RTC时间，尽管有些可能需要在此情况下重新设置）。\n\n若实际日历时间未使用系统/MicroPython RTC 维护，需引用当前绝对时间的函数可能与预期不符。\n\n函数\n---------\n\n```python\ntime.localtime([secs])\n```\n将一个以秒计的时间转换为一个包含下列内容的8元组：（年、月、日、小时、分钟、秒、一周中某日、一年中某日）。若未提供秒或为None，则使用RTC时间。\n\n* 年包括世纪（例如2014）\n* 月为 1-12\n* 日为 1-31\n* 小时为 0-23\n* 分钟为 0-59\n* 秒钟 0-59\n* 周中某日为 0-6 （对应周一到周日）\n* 年中某日为 1-366\n\n```python\ntime.mktime()\n```\n此为 ``localtime()`` 的逆函数，其参数为一个表示本地时间的8元组。返回一个表示2000年1月1日以来的秒钟的整数。\n\n```python\ntime.sleep(seconds)\n```\n休眠给定秒数的时间。秒钟数可为一个表示休眠时间的浮点数。注意：其他端口可能不接受浮点参数，为满足兼容性，使用 `sleep_ms()` 和 `sleep_us()` 函数。 \n\n```python\ntime.sleep_ms(ms)\n```\n延迟给定毫秒数，应为Positive或0。\n\n```python\ntime.sleep_us(us)\n```\n延迟给定的微秒数，应为Positive或0。\n\n```python\ntime.ticks_ms()\n```\n用在某些值（未指定）后结束后的任意引用点返回一个递增的毫秒计数器。该值应被视为不透明的，且仅适用于ticks_diff()。\n\n自动换行值未显式显示，但为简化讨论，我将其称为 *TICKS_MAX* 。 该值的周期为  *TICKS_PERIOD = TICKS_MAX + 1* 。\n*TICKS_PERIOD* 须为2的幂，但也会因端口不同而不同。同一周期值用于 `ticks_ms()` 、 `ticks_us()` 、\n `ticks_cpu()` 函数（为简单起见）。因此，这些函数将返回一个介于 *[0 .. TICKS_MAX]* 的值，包括 *TICKS_PERIOD* 值。\n注意：仅使用非负值。多数情况下，您应将这些函数返回的值视为透明。对之唯一可用的操作为下述的 `ticks_diff()` 和 `ticks_add()` 函数。\n\n注意：在这些值上直接执行标准的数学操作(+, -)或关系运算符(<, <=, >, >=)将导致无效的结果。\n执行数字操作，并将结果作为参数传递给 ``ticks_diff()`` 或 ``ticks_add()`` 将导致后一个函数的无效结果。\n\n```python\ntime.ticks_us()\n```\n正如上述的 ``ticks_ms`` ，但以微秒为单位。\n\n```python\ntime.ticks_cpu()\n```\n与 ``ticks_ms`` 和 ``ticks_us`` 相似，但有更高的分辨率（通常CPU时钟）。\n\n这通常是CPU时钟，这也就是该函数如此命名的原因。但是并非必须为CPU时钟，系统中其他可用的定时源\n（例如高分辨率计时器）也可作为替代。该函数确切的定时单元（分辨率）未在 ``time`` 模块层指定，\n但是特定端口的文档可能提供更多具体信息。此函数设计用于非常精细的基准测试或非常紧凑的实时循环。请避免在可移植的程序编码中使用。\n\n可用性：并非每个端口都可以实现该函数。\n\n\n```python\ntime.ticks_add(ticks, delta)\n```\n用一个给定数字来抵消ticks值，该数字可为正或负。给定一个 *ticks* 值，该函数允许计算之前或之后的ticks value  *delta*  ticks，\n并遵循ticks值的模块化算术定义（见上 `ticks_ms()` ）。Ticks参数须为调用 `ticks_ms()` 、 `ticks_us()` 、 `ticks_cpu()` 函数\n（或先前调用的 `ticks_add()` ）的直接结果。但是，delta可为一个任意整数或一个数字表达。 `ticks_add()` 对计算事件/任务的截止时间非常有用。\n（注意：您必须使用 `ticks_diff()` 函数来处理截止时间。） \n\n示例:\n```python\n# Find out what ticks value there was 100ms ago 找到100ms前的ticks值\nprint(ticks_add(time.ticks_ms(), -100))\n\n# Calculate deadline for operation and test for it 计算操作和测试的截止时间\ndeadline = ticks_add(time.ticks_ms(), 200)\nwhile ticks_diff(deadline, time.ticks_ms()) > 0:\n   do_a_little_of_something()\n\n# Find out TICKS_MAX used by this port 找到该端口使用的TICKS_MAX\nprint(ticks_add(0, -1))\n```\n\n```python\ntime.ticks_diff(ticks1, ticks2)\n```\n测量连续调用ticks_ms()、ticks_us()、icks_cpu()间的周期。\n由这些函数返回的值可能在任何时间停止，因此并不支持直接减去这些值，应使用ticks_diff()。 \n“旧”值实际上应及时覆盖“新”值，否则结果将未定义。该函数不应用于测量任意周期长的时间（因为ticks_*()函数包括且通常有短周期）。\n预期使用模式是使用超时实现事件轮询：\n\n\n参数顺序与减法操作符相同， ``ticks_diff(ticks1, ticks2)`` 与 ``ticks1 - ticks2`` 意义相同。\n但是，函数可能会围绕由 `ticks_ms()` 返回的值，因此在此使用减法将会产生错误结果。于是 `ticks_diff()` 应运而生，\n即使在环绕值情况下，它也能实现模块化（或者更确切地说，ring）算法生成正确值（只要它们之间的距离不太远，见下）。\n该函数返回介于[ *-TICKS_PERIOD/2 ..TICKS_PERIOD/2-1* ]的有符号整数值（这是两个互补的二进制整数的典型范围定义）。\n若该结果为负，则意味着 *ticks1* 发生在 *ticks2* 之前。否则，则意味着 *ticks1* 发生在 *ticks2* 之后。\n这只在距离彼此不超过 *TICKS_PERIOD/2-1*  ticks时成立。若未成立，则将返回错误结果。特别地，\n若两个tick值距离 *TICKS_PERIOD/2-1 ticks* ，则该值将由此函数返回。但是，若在其之间传递实时ticks的 *TICKS_PERIOD/2* ，\n该函数会返回 *TICKS_PERIOD/2* ，也就是说，结果值将会绕到可能值的负范围内。\n\n上述限制的常用原理：假设您被锁在一个房间里，只有一个标准12级时钟来记录时间进程。若您现在看一下表，\n并在接下来的13个小时中不再查看时间（例如您可能睡了很久），然后当您再次看表时，对您来说只过了1小时。\n为避免这种错误，请定时查看时间。您的应用程序也应如此。“睡太久”的比喻直接影射应用程序的行为：\n请勿让您的应用程序运行单一程序过久。按步骤运行任务，并在步骤进行时计时。\n\n`ticks_diff()` 设计适用于各种使用模式，其中包括:\n\n* 使用超时轮询。在此种情况下，事件顺序已知，您只需处理 `ticks_diff()` 的正结果:\n```python\n# Wait for GPIO pin to be asserted, but at most 500us 等待GPIO注脚确认，单最多等待500us\nstart = time.ticks_us()\nwhile pin.value() == 0:\n   if time.ticks_diff(time.ticks_us(), start) > 500:\n      raise TimeoutError\n```\n\n* 安排事件。在此种情况下，若某一事件超期，则 `ticks_diff()` 的结果可能为负:\n```python\n# This code snippet is not optimized 这一代码片段没有经过优化\nnow = time.ticks_ms()\nscheduled_time = task.scheduled_time()\nif ticks_diff(now, scheduled_time) > 0:\n   print(\"Too early, let's nap\")\n   sleep_ms(ticks_diff(now, scheduled_time))\n   task.run()\nelif ticks_diff(now, scheduled_time) == 0:\n   print(\"Right at time!\")\n   task.run()\nelif ticks_diff(now, scheduled_time) < 0:\n   print(\"Oops, running late, tell task to run faster!\")\n   task.run(run_faster=true)\n```\n\n注意：请勿将 `time()` 值传递给 `ticks_diff()` ，您应在此使用正常的数学运算。但是请注意 `time()` 可能（且将会）溢出。这被称为 [2038年问题](https://zh.wikipedia.org/wiki/2038%E5%B9%B4%E9%97%AE%E9%A2%98) .\n\n\n```python\ntime.time()\n```\n假设底层RTC是按照上述设置和维护的，则返回整数形式的秒钟数。若RTC未设定，该函数将返回一个特定于端口的引用点的秒数\n（对无电池支持的RTC的嵌入式电路板而言，通常在电源启动或复位后）。若您想开发可移植的MicroPython应用程序，\n您不应依赖该函数来提供高于第二精度的结果。若您需要更高精度，请使用 ``ticks_ms()`` 和 ``ticks_us()`` 函数。\n若您需要日历时间，无参数的 ``localtime()`` 不失为佳选。\n\n> 与CPython区别\n在CPython中，该函数返回自Unix时刻，即1970-01-01 00:00 UTC始的浮点数形式的秒数，\n其精度通常可达微秒。使用MicroPython时，只有Unix端口使用相同时刻，若浮点精度允许，\n则返回次秒级精度。嵌入式硬件通常不具有浮点精度，可表示长时间范围和次秒级秒精度，\n因此它们使用具有第二精度的整数值。某些嵌入式硬件也缺乏电池供电的RTC，\n因此，返回自上次接通电源后或其他相关的制定硬件点的秒数（例：重置）。"}, "/WebBit_doc/zh/micropython/pythonStd/array.html": {"title": "array - 数值数组", "content": "array - 数值数组\n======================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [array](https://docs.python.org/zh-cn/3/library/array.html#module-array)\n\n支持的格式的代码： ``b``, ``B``, ``h``, ``H``, ``i``, ``I``, ``l``,``L``, ``q``, ``Q``, ``f``, ``d`` (后者2取决于浮点支持).\n\nClasses\n-------\n\n```python\nclass array.array(typecode, [iterable])\n#使用给定类型的元素创建数组。数组的初始内容由 `iterable` 给出。如果未提供，则创建空数组。\n\nappend(val)\n#将新元素val附加到数组的末尾，使其增长.\n\nextend(iterable)\n#将迭代中包含的新元素追加到数组的末尾，增长它.\n\n```"}, "/WebBit_doc/zh/micropython/pythonStd/uerrno.html": {"title": "uerrno - 系统错误代码", "content": "uerrno - 系统错误代码\n===================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [errno](https://docs.python.org/zh-cn/3/library/errno.html#module-errno)\n\n此模块提供访问符号错误代码以进行`OSError` 异常。特定的代码清单依赖于 `MicroPython port`.\n\n\n常量\n---------\n\n``EEXIST, EAGAIN, etc.``\n\n错误代码，基于ANSI C/POSIX标准。所有错误代码开头都有“E”。错误通常可以访问为 ``exc.args[0]`` ，其中 ``exc`` 是 ``OSError`` 的一个实例\n\n示例:\n```python\ntry:\n   uos.mkdir(\"my_dir\")\nexcept OSError as exc:\n   if exc.args[0] == uerrno.EEXIST:\n      print(\"Directory already exists\")\n```\n\n```\nuerrno.errorcode\n```\n字典将数字错误代码映射到带有符号错误代码的字符串（参考上文）::\n\n```\n>>> print(uerrno.errorcode[uerrno.EEXIST])\nEEXIST\n```"}, "/WebBit_doc/zh/micropython/pythonStd/gc.html": {"title": "gc - 回收内存碎片", "content": "gc - 回收内存碎片\n==========================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档:[module-gc](https://docs.python.org/zh-cn/3/library/gc.html#module-gc).\n\nFunctions\n---------\n\n```python\ngc.enable()\n```\n   启用自动回收内存碎片。\n\n```python\ngc.disable()\n```\n  禁用自动回收。堆内存仍然可以分配，但可以通过 :meth:`gc.collect` 函数进行手动回收内存碎片。\n\n\n```python\ngc.collect()\n```\n   回收内存碎片。\n\n```python\ngc.mem_alloc()\n```\n返回分配的堆RAM的字节数.\n> 与CPython的区别:\n> 此功能是MicroPython扩展.\n\n```python\ngc.mem_free()\n```\n   返回可用堆RAM的字节数，如果此数量未知，则返回-1.\n\n> 与CPython的区别:\n> 此功能是MicroPython扩展.\n\n```python\ngc.isenabled()\n```\n  判断是否启动自动内存碎片收集。\n\n```python\ngc.threshold([amount])\n```\n   设置或查询其他GC分配阈值。通常，只有在无法满足新分配时，即在内存不足（OOM）条件下才会触发集合。\n   如果调用此函数，除了OOM之外，每次分配了大量字节后都会触发一个集合（总共，因为上一次分配了这么多的字节）。\n   amount通常被指定为小于完整堆大小，意图在堆耗尽之前触发集合，并希望早期集合可以防止过多的内存碎片。\n   这是一种启发式度量，其效果因应用程序而异，以及量参数的最佳值。\n\n   不带参数调用函数将返回阈值的当前值。值-1表示禁用的分配阈值。\n\n> 与CPython的区别:\n> 函数是MicroPython扩展。CPython具有类似的功能 - ``set_threshold()`` 但由于不同的GC实现，它的签名和语义是不同的。"}, "/WebBit_doc/zh/micropython/pythonStd/usocket.html": {"title": "usocket - socket 模块", "content": "usocket - socket 模块\n======================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [socket](https://docs.python.org/zh-cn/3/library/socket.html#module-socket)\n\n该模块提供BSD socket接口的访问。\n\n> 与CPython区别\n> 为提高效率与一致性，MicroPython中的套接字对象直接实现流（类文件）接口。在CPython中，\n> 需使用 ``makefile()`` 方法来将socket转换为类文件对象。该方法仍由MicroPython（但是是无操作）支持，\n> 所以在CPython的兼容性问题上，请一定使用该方法。\n\nSocket地址格式\n------------------------\n\n下面函数使用 (ipv4_address, port) 网络地址, ipv4_address 是由点和数字组成的字符串，如 ``\"8.8.8.8\"`` ，\n端口是 1-65535 的数字。注意不能使用域名做为 ipv4_address，域名需要先用 ``socket.getaddrinfo()`` 进行解析。\n\n``usocket`` 模块的本机套接字地址格式是一个由 ``getaddrinfo`` 函数返回的不透明数据类型，\n须用其来解析文本地址（包括数字型地址）:\n\n```python\nsockaddr = usocket.getaddrinfo('www.micropython.org', 80)[0][-1]\n# You must use getaddrinfo() even for numeric addresses 您必须使用getaddrinfo()，即使是用于数字型地址\nsockaddr = usocket.getaddrinfo('127.0.0.1', 80)[0][-1]\n# Now you can use that address 现在您可以使用这一地址了\nsock.connect(addr)\n```\n\n使用 ``getaddrinfo`` 是处理地址最有效（在内存和处理能力方面皆是如此）且最便捷的方式。\n\n\n函数\n---------\n\n```python\nsocket.socket(af=AF_INET, type=SOCK_STREAM, proto=IPPROTO_TCP)\n```\n  - ``af`` ：地址\n\n    - ``socket.AF_INET``:=2 — TCP/IP – IPv4\n    - ``socket.AF_INET6`` :=10 — TCP/IP – IPv6\n\n  - ``type`` ：socket类型\n\n    - ``socket.SOCK_STREAM``:=1 — TCP流\n    - ``socket.SOCK_DGRAM``:=2 — UDP数据报\n    - ``socket.SOCK_RAW`` :=3 — 原始套接字\n    - ``socket.SO_REUSEADDR`` : =4 — socket可重用\n\n  - ``proto`` ：协议号\n\n    - ``socket.IPPROTO_TCP`` =6\n    - ``socket.IPPROTO_UDP`` =17 \n\n\n一般不指定proto参数，因为有些MicroPython固件提供默认参数:\n```\n  >>> s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n  >>> print(s)\n  <socket>\n```\n\n```python\nsocket.getaddrinfo(host, port)\n```\n将主机域名（host）和端口（port）转换为用于创建套接字的5元组序列。元组列表的结构如下:\n```\n  (family, type, proto, canonname, sockaddr)\n```\n\n下面显示了怎样连接到一个网址:\n```python\n  s = usocket.socket()\n  s.connect(usocket.getaddrinfo('www.micropython.org', 80)[0][-1])\n```\n\n> 与CPython区别\n该函数发生错误时，会引发一个 ``socket.gaierror`` 异常（ ``OSError`` 子类）。 \nMicroPython并不具有 ``socket.gaierror`` ，会直接引发OSError。 \n注意： ``getaddrinfo()`` 的错误数量组成一个单独的名称空间，\n可能与 ``uerrno`` 系统错误代码模块中的错误数量不匹配。\n为区分 ``getaddrinfo()`` 错误，该错误使用负数标记，标准系统错误为正数（错误数可通过使用异常对象的 e.args[0] 特性访问）。\n暂时使用负数，未来可能改变。\n\n\n\nsocket类\n============\n\n方法\n-------\n\n```python\nsocket.close()\n```\n关闭socket。一旦关闭后，socket所有的功能都将失效。远端将接收不到任何数据 (清理队列数据后)。\n内存碎片回收时socket会自动关闭，但还是推荐在必要时用 close() 去关闭\n\n```python\nsocket.bind(address)\n```\n以列表或元组的方式绑定地址和端口号。\n\n  - ``address`` ：一个包含地址和端口号的列表或元组。\n\n示例:\n```python\n  addr = (\"127.0.0.1\",10000)\n  s.bind(addr)\n```\n\n\n\n```python\nsocket.listen([backlog])\n```\n监听socket，使服务器能够接收连接。如果指定了 ``backlog`` ，它不能小于0 (如果小于0将自动设置为0)；\n超出后系统将拒绝新的连接。如果没有指定，将使用默认值。\n\n  -  ``backlog`` ：接受套接字的最大个数，至少为0，如果没有指定，则默认一个合理值。\n\n   \n\n```python\nsocket.accept()\n```\n\n接收连接请求。socket需要指定地址并监听连接。返回值是 (conn, address)，\n其中conn是用来接收和发送数据的套接字，address是绑定到另一端的套接字。\n  \n  - ``conn``：新的套接字对象，可以用来收发消息\n  - ``address``：连接到服务器的客户端地址\n\n> 只能在绑定地址端口号和监听后调用，返回conn和address。\n\n\n\n```python\nsocket.connect(address)\n```\n连接到指定地址的服务器。\n\n  - ``address``：服务器地址和端口号的元组或列表\n\n示例:\n```python\nhost = \"192.168.3.147\"\nport = 100\nsocket.connect((host, port))\n```\n\n```python\nsocket.send(bytes)\n```\n发送数据，并返回发送的字节数。\n\n  - ``bytes``：bytes类型数据\n\n```python\nsocket.sendall(bytes)\n```\n与send(）函数类似，区别是sendall()函数通过数据块连续发送数据。\n\n  - ``bytes``：bytes类型数据\n\n\n\n```python\nsocket.recv(bufsize)\n```\n接收数据，返回接收到的数据对象。\n\n  - ``bufsize``：指定一次接收的最大数据量\n\n示例:\n```python\ndata = conn.recv(1024)\n```\n\n\n```python\nsocket.sendto(bytes, address)\n```\n发送数据，目标由address决定，用于UDP通信，返回发送的数据大小。\n\n  - ``bytes``：bytes类型数据\n  - ``address``：目标地址和端口号的元组\n\n\n```python\nsocket.recvfrom(bufsize)\n```\n接收数据，用于UDP通信，并返回接收到的数据对象和对象的地址。\n\n  - ``bufsize``：指定一次接收的最大数据量\n\n```python\nsocket.setsockopt(level, optname, value)\n```\n根据选项值设置socket。\n\n  - ``level``：套接字选项级别\n  - ``optname``：socket 选项\n  - ``value``：可以是一个整数，也可以是一个表示缓冲区的bytes类对象。\n\n示例:\n```python\nsocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n```\n\n```python\nsocket.settimeout(value)\n```\n设置超时时间，单位：秒。 \n\n示例:\n```python\nsocket.settimeout(2)\n```\n\n```python\nsocket.setblocking(flag)\n```\n设置socket的阻塞或非阻塞模式：若标记为false，则将该socket设置为非阻塞模式，而非阻塞模式。\n\n该方法为某些settimeout()调用的简写:\n\n* ``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``\n* ``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0)``\n\n```python\nsocket.makefile(mode='rb', buffering=0)\n```\n返回一个与socket相关联的文件对象。具体的返回类型取决于给定makefile()的参数。该支持仅限于二进制模式（‘rb’和‘wb’）.\n\nCPython的参数为：不支持 encoding 、 errors 、 newline 。\n\nSocket须为阻塞模式；允许超时存在，但若出现超时，文件对象的内部缓冲区可能会以不一致状态结束。\n\n> 与CPython区别\n> * 由于MicroPython不支持缓冲流，则将忽略缓冲参数的值，且将按照该值为0（未缓冲）时处理。\n> * 关闭所有由makefile()返回的文件对象，同样将关闭原始socket。\n\n```python\nsocket.read([size])\n```\n从socket中读取size字节。返回一个字节对象。若未给定 ``size`` ，则按照类似 `socket.readall()` 的模式运行，见下。\n\n\n```python\nsocket.readinto(buf[, nbytes])\n```\n\n将字节读取入缓冲区。若指定 nbytes ，则最多读取该数量的字节。否则，最多读取 len(buf) 数量的字节。\n正如 ``read()`` ，该方法遵循“no short reads”方法。\n\n返回值：读取并存入缓冲区的字节数量\n\n\n```python\nsocket.readline()\n```\n接收一行数据，遇换行符结束，并返回接收数据的对象 。\n\n\n```python\nsocket.write(buf)\n```\n\n向字节缓冲区写入socket，并返回写入数据的大小。\n\n\n\n常数\n------\n```\nAF_INET\nAF_INET6\n```\n地址簇\n\n```\nSOCK_STREAM\nSOCK_DGRAM\n```\n套接字类型\n\n```\nIPPROTO_UDP\nIPPROTO_TCP\n```\nIP协议号\n\n```\nSOL_SOCKET\n```\nsocket选项级别,默认=4095"}, "/WebBit_doc/zh/micropython/pythonStd/ujson.html": {"title": "ujson - JSON 编码和解码", "content": "ujson - JSON 编码和解码\n==========================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [json](https://docs.python.org/zh-cn/3/library/json.html#module-json)\n\n该模块提供json数据格式的转换。\n\n函数\n---------\n\n```python\nujson.dumps(obj)\n```\n将dict类型的数据转换成str，因为如果直接将dict类型的数据写入json文件中会发生报错，因此在将数据写入时需要用到该函数。\n\n- ``obj`` 要转换的对象\n\n示例:\n```\n>>> obj = {1:2, 3:4, \"a\":6}\n>>> print(type(obj), obj) #原来为dict类型\n<class 'dict'> {3: 4, 1: 2, 'a': 6}\n>>> jsObj = ujson.dumps(obj) #将dict类型转换成str\n>>> print(type(jsObj), jsObj)\n<class 'str'> {3: 4, 1: 2, \"a\": 6}\n```\n\n```python\nujson.loads(str)\n```\n解析 JSON 字符串并返回对象。如果字符串格式错误将引发 ValueError 异常。 \n\n示例:\n```\n>>> obj = {1:2, 3:4, \"a\":6}\n>>> jsDumps = ujson.dumps(obj)\n>>> jsLoads = ujson.loads(jsDumps)\n>>> print(type(obj), obj)\n<class 'dict'> {3: 4, 1: 2, 'a': 6}\n>>> print(type(jsDumps), jsDumps)\n<class 'str'> {3: 4, 1: 2, \"a\": 6}\n>>> print(type(jsLoads), jsLoads)\n<class 'dict'> {'a': 6, 1: 2, 3: 4}\n```"}, "/WebBit_doc/zh/micropython/pythonStd/uos.html": {"title": "os - 操作系统", "content": "os - 操作系统\n===============================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [os](https://docs.python.org/zh-cn/3/library/os.html#module-os)\n\n``os`` 模块包含文件系统访问和 ``urandom`` 功能\n\n一般功能\n---------\n\n```python\nos.uname()\n```\n返回一个元组(可能是一个命名元组)，其中包含关于底层和/或其操作系统的信息。元组有五个字段，每个字段的顺序如下:\n\n* ``sysname`` -- 底层系统的名称\n* ``nodename`` -- 网络名称（和sysname相同）\n* ``release`` -- 底层系统的版本\n* ``version`` -- MiroPython版本和构建日期\n* ``machine`` --底层硬件的标识符(eg board, CPU)\n\n示例:\n```\n>>> import os\n>>> os.uname()\n(sysname='esp32', nodename='esp32', release='1.9.1', version='v1.9.1-224-g83d3f3f-dirty on 2017-12-12', machine='ESP32 module with ESP32')\n```\n\n```python\nos.urandom(n)\n```\n返回一个带有n个随机字节的字节对象。它是由硬件随机数生成器生成。\n\n示例:\n```\n>>> os.urandom(20)\nb'f\\x92\\x85t28\\xa1\\xf0\\xaf3\\xf5\\xd9\\xcdx\\xc3\\n\\xedm\\xf8\\xb7'\n```\n\n文件系统访问\n---------\n\n```python\nos.getcwd()\n```\n获取当前目录。\n\n```python\nos.chdir(path)\n```\n更改当前目录。\n\n示例:\n```\n>>> os.getcwd()\n'/'\n>>> os.chdir(\"./lib\")\n>>> os.getcwd()\n'/lib'\n>>> os.chdir(\"..\")\n>>> os.getcwd()\n'/'\n```\n\n```python\nos.ilistdir([dir])\n```\n此函数返回一个迭代器，然后生成与列出的目录中的条目对应的元组。没有参数，它列出了当前目录，否则它列出了dir给出的目录。\n\nThe 3-tuples have the form *(name, type, inode)*:\n\n- *name* 是一个字符串（如果dir是一个字节对象，则为字节），并且是条目的名称;\n- *type* 是一个整数，指定条目的类型，目录为0x4000，常规文件为0x8000;\n- *inode* 是对应于文件inode的整数，对于没有这种概念的文件系统可以是0。\n\n目前条目的含义目前尚未定义。\n\n```python\nos.listdir([dir])\n```\n如果没有参数，请列出当前目录。否则列出给定目录。\n\n示例:\n```\n>>> os.listdir()\n['boot.py', 'lib']\n>>> os.listdir(\"./lib\")\n['test.py']\n```\n\n```python\nos.mkdir(path)\n```\n创建目录，path为创建目录的路径。 \n\n示例:\n```\n>>> os.listdir()\n['boot.py']\n>>> path = \"./lib\"\n>>> os.mkdir(path)\n>>> os.listdir()\n['boot.py', 'lib']\n```\n\n```python\nos.rmdir(path)\n```\n删除目录。\n\n示例:\n```\n>>> os.listdir()\n['boot.py', 'lib']\n>>> os.rmdir(\"./lib\")\n>>> os.listdir()\n['boot.py']\n```\n\n```python\nos.remove(path)\n```\n删除文件。 \n\n示例:\n```\n>>> os.listdir(\"./lib\")\n['test.py']\n>>> os.remove(\"./lib/test.py\")\n>>> os.listdir(\"./lib\")\n[]\n```\n\n\n```python\nos.rename(old_path, new_path)\n```\n重命名文件。 \n\n示例:\n```\n>>> os.listdir(os.getcwd())\n['test.py']\n>>> os.rename(\"test.py\", \"mytest.py\")\n>>> os.listdir(os.getcwd())\n['mytest.py']\n```\n\n```python\nos.stat(path)\n```\n获取文件或目录的状态。 \n\n示例:\n```\n>>> os.stat(\"./lib\")\n(16384, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n>>> os.stat(\"./lib/test.py\")\n(32768, 0, 0, 0, 0, 0, 1, 0, 0, 0)\n```\n\n```python\nos.statvfs(path)\n```\n获取文件系统的状态。\n\n返回包含以下顺序的文件系统信息的元组：\n\n* ``f_bsize`` -- 文件系统块大小\n* ``f_frsize`` -- 片段大小\n* ``f_blocks`` --f_frsize单位的fs大小\n* ``f_bfree`` -- free blocks数量\n* ``f_bavail`` -- number of free blocks for unpriviliged users\n* ``f_files`` -- inodes数量\n* ``f_ffree`` -- number of free inodes\n* ``f_favail`` -- number of free inodes for unpriviliged users\n* ``f_flag`` -- mount flags\n* ``f_namemax`` -- 最大文件名长度\n\n相关信息节点参数： ``f_files`` ，``f_ffree`` ，``f_avail`` 和 ``f_flags`` 参数可能会返回0。\n\n```python\nos.sync()\n```\n同步所有文件系统。\n\n```python\nos.dupterm(stream_object, index=0)\n```\n复制或切换给定类似stream对象上的MicroPython终端（REPL）。该stream_object参数必须实现 ``readinto()`` 和 `` write()`` 方法。\n流应处于非阻塞模式，如果没有可用于读取的数据， ``readinto()`` 则应返回 ``None`` 。\n\n调用此函数后，将在此流上重复所有终端输出，并且流上可用的任何输入都将传递到终端输入。\n\n所述索引参数应该是哪个复制时隙设置一个非负整数，并且指定。给定端口可以实现多个槽（槽0将始终可用），\n并且在这种情况下，终端输入和输出在所有设置的槽上复制。\n\n如果 ``None`` 作为 ``stream_object`` 传递，则在索引给出的槽上取消复制。\n\n该函数返回给定槽中的上一个类似流的对象。"}, "/WebBit_doc/zh/micropython/pythonStd/ussl.html": {"title": "ussl - SSL/TLS 模块", "content": "ussl - SSL/TLS 模块\n=============================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [ssl](https://docs.python.org/zh-cn/3/library/ssl.html#module-ssl)\n\n此模块提供对客户端和服务器端网络套接字的传输层安全性（以前称为“安全套接字层”）加密和对等身份验证工具的访问。\n\n函数\n---------\n\n```python\nssl.wrap_socket(sock, server_side=False, keyfile=None, certfile=None, cert_reqs=CERT_NONE, ca_certs=None)\n```\n\n采用流sock（通常是SOCK_STREAM类型的usocket.socket实例），并返回ssl.SSLSocket的实例，该实例将基础流包装在SSL上下文中。\n返回的对象具有通常的流接口方法，如 read()，write()等。\n在MicroPython中，返回的对象不公开套接字接口和方法，如recv()，send()。\n特别是，应该从accept()非SSL侦听服务器套接字上返回的普通套接字创建服务器端SSL 套接字。\n\n> 模块的某些实现不验证服务器证书，这使得建立的SSL连接容易发生中间人攻击。\n\n异常\n----------\n\n```python\nssl.SSLError\n```\n此异常不存在。而是使用它的基类OSError。\n\n常量\n---------\n\n```python\nssl.CERT_NONE\nssl.CERT_OPTIONAL\nsl.CERT_REQUIRED\n```\ncert_reqs参数支持的值。"}, "/WebBit_doc/zh/micropython/pythonStd/ubinascii.html": {"title": "ubinascii - 二进制/ ASCII转换", "content": "ubinascii - 二进制/ ASCII转换\n============================================\n\n这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [binascii](https://docs.python.org/zh-cn/3/library/binascii.html#module-binascii)\n\n该模块实现了二进制数据与各种ASCII编码之间的转换(双向).\n\nFunctions\n---------\n\n```python\nubinascii.hexlify(data, [sep])\n```\n将字符串转换为十六进制表示的字符串。 \n\n> 与CPython的区别:\n> 如果提供了附加参数sep，则它将用作十六进制值之间的分隔符。\n   \n没有sep参数:\n\n```\n>>> ubinascii.hexlify('\\x11\\x22123')\nb'1122313233'\n>>> ubinascii.hexlify('abcdfg')\nb'616263646667'\n```\n\n如果指定了第二个参数sep，它将用于分隔两个十六进制数:\n\n```\n>>> ubinascii.hexlify('\\x11\\x22123', ' ')\nb'11 22 31 32 33'\n>>> ubinascii.hexlify('\\x11\\x22123', ',')\nb'11,22,31,32,33'\n```\n\n```python\nubinascii.unhexlify(data)\n```\n转换十六进制字符串为二进制字符串，功能和 hexlify 相反。\n\n示例:\n```\n>>> ubinascii.unhexlify('313233')\nb'123'\n```\n\n\n```python\nubinascii.a2b_base64(data)\n```\n解码base64编码的数据，忽略输入中的无效字符。符合  [RFC 2045 s.6.8](https://tools.ietf.org/html/rfc2045#section-6.8) 。返回一个 ``bytes`` 对象。\n\n\n```python\nubinascii.b2a_base64(data)\n```\n以base64格式编码二进制数据，如 [RFC 3548](https://tools.ietf.org/html/rfc3548.html) 中所述。返回编码数据，后跟换行符，作为 ``bytes`` 对象。"}, "/WebBit_doc/zh/micropython/basic/image.html": {"title": "LED矩阵显示图像", "content": "LED矩阵显示图像\n============\n\n在开始项目之前，你可以知道 MicroPython 已经了内置的许多图片，如果你想要显示一个笑脸的话，那你只需要运行以下列代码。\n\n```python\nfrom microbit import *\ndisplay.show(Image.HAPPY)\n```\n\n运行效果如下\n\n![](../../assets/micropython/basic/images/emoj.jpg)\n\n通过先前的章节，我们想你应该知道了第一行的用途，那么第二行就是指通过了display 模块来显示内置的 Image 图片，我们展示的这个笑脸图案其实只是Image 的一部分，而它的名字叫做 Happy，并且我们要通过 show 并将它放置在括弧内，以使得它显示出来，所以写成 `display.show(Image.HAPPY)`，动手试试吧。\n\n内置的图片列表\n--------------\n\n```python\n-   Image.HEART\n-   Image.HEART\\_SMALL\n-   Image.HAPPY\n-   Image.SMILE\n-   Image.SAD\n-   Image.CONFUSED\n-   Image.ANGRY\n-   Image.ASLEEP\n-   Image.SURPRISED\n-   Image.SILLY\n-   Image.FABULOUS\n-   Image.MEH\n-   Image.YES\n-   Image.NO\n-   Image.CLOCK12, Image.CLOCK11, Image.CLOCK10, Image.CLOCK9,\n    Image.CLOCK8, Image.CLOCK7, Image.CLOCK6, Image.CLOCK5,\n    Image.CLOCK4, Image.CLOCK3, Image.CLOCK2, Image.CLOCK1\n-   Image.ARROW\\_N, Image.ARROW\\_NE, Image.ARROW\\_E, Image.ARROW\\_SE,\n    Image.ARROW\\_S, Image.ARROW\\_SW, Image.ARROW\\_W, Image.ARROW\\_NW\n-   Image.TRIANGLE\n-   Image.TRIANGLE\\_LEFT\n-   Image.CHESSBOARD\n-   Image.DIAMOND\n-   Image.DIAMOND\\_SMALL\n-   Image.SQUARE\n-   Image.SQUARE\\_SMALL\n-   Image.RABBIT\n-   Image.COW\n-   Image.MUSIC\\_CROTCHET\n-   Image.MUSIC\\_QUAVER\n-   Image.MUSIC\\_QUAVERS\n-   Image.PITCHFORK\n-   Image.XMAS\n-   Image.PACMAN\n-   Image.TARGET\n-   Image.TSHIRT\n-   Image.ROLLERSKATE\n-   Image.DUCK\n-   Image.HOUSE\n-   Image.TORTOISE\n-   Image.BUTTERFLY\n-   Image.STICKFIGURE\n-   Image.GHOST\n-   Image.SWORD\n-   Image.GIRAFFE\n-   Image.SKULL\n-   Image.UMBRELLA\n-   Image.SNAKE\n```\n\n可见数量十分之多，看到这里，我们想你也可以多多尝试一下其他图片，玩的开心。\n\n试试 DIY 图片吧\n---------------\n\n当然，你肯定不会止步于此，那么如何更进一步呢？比如创造自己的图片？\n\nSo Easy!!!\n\n在每一个 LED 在物理显示上可以被设置为一个值，类似于高低电平，比如某个像素点被设置成 0 ，那么它的亮度就是 0 .然而如果它被设置成 9，那么它就是指灯的亮度为 9 。所以记住这句话，从 0 到 9，亮度依次递增! 基于此，我们就可以很容易创造一个我们想要的新图片。\n\n```python\nfrom microbit import *\n\nboat = Image(\"05050:\"\n             \"05050:\"\n             \"05050:\"\n             \"99999:\"\n             \"09990\")\n\ndisplay.show(boat)\n```\n\n![](../../assets/micropython/basic/images/emoj2.jpg)\n\n> 运行时，你应该可以看到一张这样的图片！！\n\n那么现在你已经了解如何画图，你应该注意到每一行的结尾有一个：然后于此同时二边被附上了双引号,里面仅仅是数值表示的亮度而已，所以创建一张image就是如此简单。\n\n> 但实际上，你也并不需要写多行，如果你能保证每一行不出错，你也可以这样写。\n\n```python\nboat = Image(\"05050:05050:05050:99999:09990\")\n```\n\n制作简单的动画\n--------------\n\n静态图片固然有趣，但是更多的乐趣是让它们动起来，这个是令人兴奋但在 Python 中很容易做到，仅仅是使用图片的列表\\~！\n\n假如这里有一些购物清单：\n\n[Eggs, Bacon, Tomatoes]\n\n然后你需要用一种方式在 Python 中表示这些玩意 XD。\n\n```python\nshopping = [\"Eggs\", \"Bacon\", \"Tomatoes\" ]\n```\n\n这种方式叫 list ，也就是列表，我们简单地创造了一个叫 shopping 的列表，然后它包含了3个元素，Python 知道它是一个列表，因为它有一对括号[]，在列表中的元素被逗号分隔，然后在这个实例中，items包含了三个字符串，“Eggs”.“Bacon”以及“Tomatoes”。我们要知道，它们都是字符串对象，因为它们用“”进行分割。\n\n你可以用list在python中储存任何玩意，下面的案例将教会大家如何用列表创建数字。\n\n然后你需要用一种方式在 Python 中表示这些玩意\n\n```python\nshopping = [2, 3, 5，11 ]\n```\n\n列表同样存放许多不同类型的变量：\n\n```python\nmixed_up_list = [\"hello!\", 1.234, Image.HAPPY]\n```\n\n注意到最后一个元素没有，它是一个 Image 对象，所以我们可以告诉 Python 去存放一个Image的list，不过在内置的方法中，有已经做好的二个对象。他们叫 Image.ALL\\_CLOCKS 和 Image.ALL\\_ARROWS。\n\n```python\nfrom microbit import *\ndisplay.show(Image.ALL_CLOCKS, loop=True, delay=100)\n```\n\n和单张 image 一样，我们使用 display.show 让它在设备上显示，然而，我们告诉 Python 使用 Image.ALL\\_CLOCKS 这个列表，然后它会理解并按顺序展示这个 list 所有元素， 我们也可以告诉 Python 保持循环状态，通过 `loop=True` ，另外，我们也可以设置这个动画切换图片的时间。通过下面一条代码。`delay=100`。\n\n现在你知道怎么创造一个动画了吧，以及你了解如何避免一直循环下去了吗？包括如何改变动画播放的速度了么？如果你都理解了，就来试一试吧！\\~\n\n让我们创造一个自己的动画列表（list），在这个案例中，我们将制作一个小船下沉到底部的动画。\n\n```python\nfrom microbit import *\n\nboat1 = Image(\"05050:\"\n              \"05050:\"\n              \"05050:\"\n              \"99999:\"\n              \"09990\")\n\nboat2 = Image(\"00000:\"\n              \"05050:\"\n              \"05050:\"\n              \"05050:\"\n              \"99999\")\n\nboat3 = Image(\"00000:\"\n              \"00000:\"\n              \"05050:\"\n              \"05050:\"\n              \"05050\")\n\nboat4 = Image(\"00000:\"\n              \"00000:\"\n              \"00000:\"\n              \"05050:\"\n              \"05050\")\n\nboat5 = Image(\"00000:\"\n              \"00000:\"\n              \"00000:\"\n              \"00000:\"\n              \"05050\")\n\nboat6 = Image(\"00000:\"\n              \"00000:\"\n              \"00000:\"\n              \"00000:\"\n              \"00000\")\n\nall_boats = [boat1, boat2, boat3, boat4, boat5, boat6]\ndisplay.show(all_boats, delay=500, loop=True)\n```\n\n运行效果：\n\n![](../../assets/micropython/basic/images/running.gif)\n\n修改图片的颜色\n--------------\n\n我们在前面的章节中修改字符了显示的颜色，那么怎么修改图片的显示颜色？让我们接着往下面看。\n\n```python\nfrom microbit import *\nfrom display import *\ndisplay.show(Image.ALL_CLOCKS, color=Blue, loop=True, delay=100)\n```\n\n我们这里还是利用上面那个例子，通过简单的修改来改变它的颜色。我们可以看到与前面代码示例最大的不同就是在 show() 函数中添加了 color=Blue 。 这段代码要添加到Image的后面，也就是 show() 的第二个参数的位置。此时显示的颜色已经被我们修改了。\n\n![](../../assets/micropython/basic/images/blue.gif)\n\n在前面的章节了也讲过了，我们如果要使用内置的颜色就要导入 display 模块，我们这里使用了内置的颜色Blue，所以在一开始就通过 from display import \\* 导入display模块。\n\n当然，如果内置的几种颜色不符合要求怎么办呢？同样可以参考我们上一章节中讲到的内容，我们可以自定义一个颜色。\n\n```python\nfrom microbit import *\nmycolor = [3, 1, 1]\ndisplay.show(Image.ALL_CLOCKS, color=mycolor, loop=True, delay=500)\n```\n\n![](../../assets/micropython/basic/images/mycolor.gif)\n\n那么最后就来解释一下代码是如何工作的吧。\n-   首先代码是创造了 6 个船的 image。\n-   然后用一个 list 存储了它们。\n-   接着用 display 去显示这些图片，并设置延迟为 500 毫秒\n-   最后，设置了 loop=True ,所以这这艘船会反复下沉。"}, "/WebBit_doc/zh/micropython/basic/random.html": {"title": "随机数生成器", "content": "随机数生成器\n==========\n\n随机性\n------\n\n什么是随机性呢？\n\n随机性意味着无法预测，真正的随机性只存在于自然世界中。什么地方有闪电是随机的；如果有个地方正在酝酿风暴，可以相当确定那里会有闪电，但无法精确预测具体位置一所以不要站在树下。又比如老师想让同学起来回答问题，但是没有一个同学举手起来回答问题，这时候老师就随便喊了一个座位号，这个座位号也具有随机性。\n\nMicroPython 附带了一个随机数模块，可以很容易地在代码中引入随机数。例如，下面是如何在屏幕上滚动一个随机名称的例子:\n\n```python\nfrom microbit import *\nimport random\n\nnames = [\"Mary\", \"Yolanda\", \"Damien\", \"Alia\", \"Kushal\", \"Mei Xiu\",\"Zoltan\" ]\n\ndisplay.scroll(random.choice(names))\n```\n\n列表(names)包含7个不同的名字的字符串。使用 random.choice 方法将列表(names)作为参数，并返回随机选择的项。这个项(随机选择的名称)作为 display.scroll 的参数。效果就是你可以在led显示面板上面看到被随机选中的名字\n\n随机数\n------\n\n随机数非常有用。它们在游戏中很常见，比如说骰子。 MicroPython 提供了一些有用的随机数方法。那就让我来制作一个简单的骰子吧，示例代码：\n\n```python\nfrom microbit import *\nimport random\n\ndisplay.show(str(random.randint(1, 6)))\n```\n\n板子每次执行这段函数，它都会显示 1 到 6 之间的数字。 random.randint() 在两个参数1和6之间返回一个整数(包括6)。注意因为 show函数显示时需要一个字符，所以这里使用 str 函数将数值转换为字符(例如，我们将 6 通过 str(6) 转换为“6”)。如果你想要一个介于 0 和 N 之间的数字，那么就用 random.randrange() 函数。如果你给它一个参数，它会返回随机整数，但不包括参数 N 的值(这与random.randint()不同)。有时你需要有小数点的数字。这些被称为浮点数，那怎么产生随机的浮点数呢？这时候就要使用random.random(),这个函数只会返回0.0到1.0之间的浮点数。那么如何产生大一些的浮点数呢，聪明的你心中应该有答案了吧, 那就是同时使用 random.randrange 和 random.random 。\n\n```python\nfrom microbit import *\nimport random\n\nanswer = random.randrange(100) + random.random()\ndisplay.scroll(str(answer))\n```\n\n种子随机数\n----------\n\n计算机使用的随机数生成器并不是真正的随机数生成器。它们只是通过随机种子生成的一个数。那这个种子数是怎么来的呢？通常来自时间或传感器读数，如内置在芯片中的定时器和温度计。\n\n有时你想要具有可重复的随机行为:一种可重复的随机来源。比如说每次掷骰子都需要相同的随机值。通过设置种子值很容易做到这一点。给定一个已知的种子，随机数生成器将创建相同的随机数集。种子是人为设置的，这个版本的骰子程序总是产生相同的结果。\n\n```python\nfrom microbit import *\nimport random\n\nrandom.seed(1337)\nwhile True:\n    if button_a.was_pressed():\n        display.show(str(random.randint(1, 6)))\n```\n\n运行上面的程序我们总是得到相同的结果，在led面板上显示’5’,因为在这里我们给定的种子是一个固定的值所以这个程序总是产生一个固定的数"}, "/WebBit_doc/zh/micropython/basic/flash_mpy.html": {"title": "刷入 MicroPython 固件", "content": "刷入 MicroPython 固件\n=====================\n\n第一次使用，请先烧入 MicroPython 固件，如果不烧录就没有 MicroPython编程环境。\n\n> 使用请确认已经安装驱动，且已经得知自己的硬件串口名称，例如：COM5、ttyUSB0。\n\n在 Windows 下\n-------------\n\n-   从[BPI-BIT-MicroPython/release](https://github.com/BPI-STEAM/BPI-BIT-MicroPython/releases/tag/FlashTool)中获取烧写工具的链接，附有国内微云网盘分流。\n-   下载后打开 FlashMicroPython-\\*.zip 压缩包，然后运行里面的Flashtool.exe 工具即可。\n\n![](../../assets/micropython/basic/flash_mpy/flash_mpy.png)\n\n-   请先插入硬件后打开软件，这个软件会自动运行烧写，你也可以直接点击 Flash 按钮烧写。\n-   你也可以自己选择串口烧录，升级固件只需要替换压缩包中的 firmware.bin 重新烧入即可。\n\n在其他系统下\n--------------\n\n请参照其他网络教程，如果有特别的需求，可以到 社区 提交问题 或 开 issue。\n\n> 有问题可以到 [中文社区](https://forum.banana-pi.org.cn/c/bpi-bit)反馈。"}, "/WebBit_doc/zh/micropython/basic/display.html": {"title": "LED矩阵显示字符", "content": "LED矩阵显示字符\n=============\n\n以一门新语言开始编程的传统方式是让计算机打印出“Hello，World！”。\n\n![](../../assets/micropython/basic/images/scroll-hello.gif)\n\n这对于 MicroPython 来说很容易的 :\n\n```python\nfrom microbit import *\ndisplay.scroll(\"Hello, World!\")\n```\n\n以上代码每一行都有其作用。\n\n` from microbit import * `\n\n告知 MicroPython 获取它所需的所有信息用于 BPI-BIT。所有这些都置于microbit模块中（一个模块是一个预先存在的代码库）。当你输入某信息时，就是在告诉MicroPython你要使用该信息。\n\n另外，\\* 是Python表示 所有信息 的方式。因此， from microbit import \\*的意思是，我需要使用 microbit 代码库中的所有内容。\n\n` display.scroll(\"Hello, World!\") `\n\n告诉 MicroPython 使用 display 命令去滚动 string 的 “helloworld”字符号，这个 display 是在 microbit中的一个模块，代表设备物理上的显示，显示的内容在引号之中（'）。\n\n将 “Hello, World!”的相关代码复制进编辑器，并让设备显示这些字符。你可以试着改变一下显示的内容。\n\n何不自己亲自试试呢？\n\n![](../../assets/micropython/basic/images/scroll.gif)\n\n报错与除错\n------------\n\n你写的代码可能会出错。但 MicroPython 会提供帮助。出现错误时，REPL会滚动显示一些错误信息，如果可以，它将会显示出错的行号。\n\nPython 要求输入 完全 正确的信息。比如，对 Python 来说， Bpibit、bpibit 和 bpiBit 都是不同的东西。若 MicroPython 显示 NameError的错误注释，可能是因为输入的信息不准确。就像 “Nicholas” 和“Nicolas”，虽然名字很相似，却表示两个不同的人。\n\n若 MicroPython 提示 SyntaxError ，这是因为你输入了 MicroPython无法识别的代码。检查下你是否忘了输入像 \" 或者 : 一类的字符。这就像是在一个句子中间输入了句号，句子的意思就变得难以理解。\n\n板子可能会停止响应：新的代码对它不起作用，没办法将新的命令输入到 REPL。如果发生这种情况，重启试试。拔掉USB线，如果连接了电源线，则需要同时拔掉电源线，然后重新插一下。你可能还需要退出并重新启动代码编辑器。\n\n修改字符颜色\n------------\n\n相比于 microbit，bpibit 的 led 面板采用的是可编程的 RGB 灯(ws2812b)。\n\n![](../../assets/micropython/basic/images/ws2812.png)\n\n这种RGB灯通过编程理论上可以显示 255 \\* 255 \\* 255 种颜色的，也就是 1600万种颜色，是不是有点难以置信呢，那就让我们来开始我们的色彩 show 吧。\n\n想要改变字体的颜色是很简单的，在固件中已经预置了8种颜色。\n\n```python\nblack = [0, 0, 0]\nRed = [2, 0, 0]\nOrange = [2, 1, 0]\nYellow = [2, 2, 0]\nGreen = [0, 2, 0]\nBlue = [0, 0, 2]\nIndigo = [0, 2, 2]\nPurple = [2, 0, 2]\n```\n\n分别是黑（灯熄灭）、红、橙、黄、绿、蓝、靛、紫。有了这几种基本的颜色就可以来修改我们的字体颜色了。\n\n```python\nfrom display import*\ndisplay = Display()\ndisplay.scroll(\"Hello, World!\", Yellow)\n```\n\n![](../../assets/micropython/basic/images/yellow.gif)\n\n板子默认显示的颜色是红色，只要在字符串(也就是上面的“Hello,World!”)后面添加其他颜色，就可以修改显示的字符的颜色。从上面那个图可以看到我们字符的颜色已经变为黄色了。到这里可能有的同学会发出疑问了?\n\n那怎么让显示的每个字符的颜色都不一样呢？让我们来看一下下面的操作。\n\n```python\nfrom display import*\ndisplay = Display()\ncolor = [Red, Orange, Yellow, Green, Blue, Indigo, Purple]\ndisplay.scroll(\"ROYGBIP\", color)\n```\n\n![](../../assets/micropython/basic/images/color.gif)\n\n我们新建了一个列表 color，里面按顺序存放着每个字符所需要的颜色，然后在scroll 函数的后面把 color添加进去就可以了，这样每个字符的颜色就不一样了。\n\n自定义颜色\n----------\n\n到这里聪明的同学又要发问了，不是说好有 1600多万种颜色吗，怎么就这几种呢，嗯，不急，容我们慢慢道来。\n\n说了那么久的 RGB ，那什么是 RGB呢？RGB色彩就是常说的三原色，R代表Red（红色），G代表Green（绿色），B代表Blue（蓝色）。自然界中肉眼所能看到的任何色彩都可以由这三种色彩混合叠加而成。在电脑中，RGB的所谓“多少”就是指亮度，并使用整数来表示。通常情况下，RGB各有256级亮度，用数字表示为从0、1、2…直到255 。注意虽然数字最高是 255，但0也是数值之一，因此共256级。按照计算，256级的RGB色彩总共能组合出约1678万种色彩，即256×256×256=16777216。通常也被简称为1600万色或千万色。也称为24位色(2的24次方)。在led领域利用三合一点阵全彩技术，即在一个发光单元里由RGB三色晶片组成全彩像素。随着这一技术的不断成熟，led显示技术会给人们带来更加丰富真实的色彩感受。\n\n回到正题，我们要怎么控制我们的板子显示我们想要的颜色呢，前面我们用列表的方式来保存颜色的信息：\n\n```python\nRed = [2, 0, 0]\n```\n\n这里我们同样也可以按照这样的方式来定义我们的颜色。\n\n那么Red为什么是[2, 0,0]呢，实际上列表中的三个数分别对应的就是我们R（红色）G（绿色）B（蓝色）的亮度，在前面有提到了每种颜色有256个级别的亮度，显而易见[2,\n0 , 0]表示的就是红色的亮度是 2 ，绿色的亮度是 0 ，蓝色的亮度是 0。由此就可以推出其他颜色列表的含义。\n\n下面我们来定义一个 mycolor = [1 , 2 , 3] 看看显示的效果：\n\n```python\nfrom display import *\ndisplay = Display()\nmycolor = [3,3,3]\ndisplay.scroll(\"hello\",mycolor)\n```\n\n![](../../assets/micropython/basic/images/mycolor.gif)\n\n是不是很有趣，相信此时你会有很多有趣的想法，那就赶紧来尝试一下吧。\n\n> 每个颜色的亮度都有0- 255 总共256个数值可以选择，所以最小就是[0 , 0 , 0],最大就是[ 255 , 255 , 255 ] 亮度不要调得太高，太亮容易伤害眼睛。"}, "/WebBit_doc/zh/micropython/basic/simple_use.html": {"title": "点亮开发板", "content": "点亮开发板\n============\n\n工欲善其事，必先利其器\n---------------------\n\n\n请确保你已经准备好 BPI-BIT ，且已经 刷入 MicroPython 固件。\n\n并从这里获取最简单的 MicroPython 编辑器 [mpy-editor](https://github.com/BPI-STEAM/mpy-editor)。\n\nMicroPython是 Python 3 语言的精简实现 ，包括Python标准库的一小部分，经过优化可在微控制器和受限环境中运行。\n\n如果你从没学过 Python3，建议你先在[Python 3 菜鸟教程](https://www.runoob.com/python3/python3-tutorial.html)进行学习 Python3 的软件基础知识，再过度到硬件部分会比较好。\n\n\n在 Windows 下连接设备\n---------------------\n\n当你插入设备，打开软件后会提示你选择设备串口，如图点击 COM4 即可，如果断开设备了，你也可以继续点击 Connect（连接设备） 图标重连。\n\n![](../../assets/micropython/basic/simple_use/ready.png)\n\n确认连接后，运行代码\n--------------------\n\n复制粘贴到编辑框中，点击 Run（运行），即可让板子显示笑脸:\n\n```python\n    from microbit import *\n    display.show(Image.HAPPY)\n```\n如你所见，板子显示了一个笑脸，我已经成功了运行 MicroPython 代码。\n\n![](../../assets/micropython/basic/simple_use/display.png)\n\n\n> 固件已经兼容了 microbit 的 Python 代码，所以你可以直接调用大部分 microbit 功能。\n\n本文展示了你如何使用工具进行编程，但还仅仅只是刚刚开始，还有很多基础要学，例如：学习使用更多的案例，或是改善所用的编程工具。"}, "/WebBit_doc/zh/micropython/basic/repl.html": {"title": "初识 REPL", "content": "初识 REPL\n=========\n\n使用 MicroPython 的一个主要的优点是交互式的 REPL，REPL（read-evaluate-print loop）代表读取﹣求值﹣输出循环。 \n\nREPL 对于学习一门新的编程语言具有很大的帮助，因为它能对初学者写的程序立刻做出回应，这意味着你执行代码，并能马上查看结果，而无需经过先编译再上传的繁琐步骤。\n\n先连接串口\n----------\n\n要通过 USB-serial 访问，您需要使用串口终端软件。在 Windows 上如 MobaXterm 、 xshell 都是不错的选择。串口波特率设置为 115200，就可以开始玩 MicroPython 了。\n\n通过串行端口建立连接后，您可以通过按几次 Enter键来测试它是否正常工作，如果正常工作，就能到看 Python REPL提示符 `>>>` 。\n\n使用 REPL\n---------\n\n一旦有提示，您就可以开始尝试了！按Enter键后，可在提示符处键入任何内容。MicroPython将运行您输入的代码并打印结果（如果有的话）；如果输入的文本出错，则会打印出错误消息。\n\n尝试在提示符下输入以下内容:\n\n```\n    >>> print('hello MicroPython')\n    hello MicroPython\n```\n\n无需键入 `>>>` 箭头，它们表示应在此提示符后键入文本，其下一行是响应的内容。\n\n> 实际上 mpy-editor 下方面黑框就是 repl 区域，可以在其中进行交互。\n\n![](../../assets/micropython/basic/images/editor_repl.png)\n\n如果你已经了解了一些python，现在可以尝试一些基本命令。例如:\n\n```\n    >>> 1+2\n    3\n    >>> 1/2\n    0.5\n    >>> 12*34\n    408\n```\n不妨实践试试？\n\n![](../../assets/micropython/basic/images/test_repl.png)\n\n输入行编辑\n----------\n\n你可以使用 向左 和 向右 箭头键 移动光标 来编辑当前输入的行；按 Home 键或 ctrl-A 将光标移动到行的开头，按 End 或 ctrl-E 移动到行的末尾；Delete 键或 退格键 用来删除。"}, "/WebBit_doc/zh/micropython/basic/accelerometer.html": {"title": "板子姿态检测", "content": "板子姿态检测\n============\n\n这个模块可以让你获得板子当前的九轴姿态，分别是加速度、重力、磁感应的（X、Y）的方向状态值。\n\n最基本的功能是获取它们当前的 X、Y、Z 三轴的值来判断板子此时的运动状态，比如说，加速度 Z 值由小增大，表示 Z 轴方向上有在移动（有了加速度），所以可以判断出板子在移动，移动的方向在 Z 轴之上。\n\n先体验试一试\n------------\n\n经过了简单的介绍，我可以设计一个简单的判断，例如 获取板子的平衡情况，以 accelerometer 加速度模块为例，获取它的 X 轴的值，即可得到一个基本的数值，如果数值大于 20 说明它向右偏了，如果小于 20 则说明它向左偏了，如果在这两者之间，则说明它是平衡的，所以有如下的代码，显示 L 表示向左偏，而显示 R 表示板子向右偏了，试试吧！\n\n```python\nfrom microbit import *\n\nwhile True:\n    reading = accelerometer.get_x()\n    if reading > 20:\n        display.show(\"R\")\n    elif reading < -20:\n        display.show(\"L\")\n    else:\n        display.show(\"-\")\n```\n\n效果如下：\n\n![](../../assets/micropython/basic/images/base.gif)\n\n反馈板子姿态\n------------\n\n姿态检测，例如上下左右左右，前进后退摇晃自由落地等，如下代码就是，当板子面向上的时候显示笑脸，面向下的则是显示生气的表情。\n\n```python\nfrom microbit import *\n\nwhile True:\n    gesture = accelerometer.current_gesture()\n    if gesture == \"face up\":\n        display.show(Image.HAPPY)\n    else:\n        display.show(Image.ANGRY)\n```\n\n体验平衡球游戏\n--------------\n\n基于先前的基础运用，我们就可以做出一个趣味的平衡球游戏。\n\n> 代码比较复杂，直接粘贴运行体验即可。\n\n```python\nimport utime\nfrom random import randint\nfrom machine import I2C, Pin\nfrom mpu9250 import MPU9250\n\ni2c = I2C(scl=Pin(22), sda=Pin(21), freq=200000)\nsensor = MPU9250(i2c)\nprint(\"MPU9250 id: \" + hex(sensor.whoami))\nfrom display import Pixel, PixelPower\n\nPixelPower(True)\nView = Pixel()\nX, Y, Color, Flag = 2, 2, 2, 0\nwhile True:\n    # print('acceleration:', sensor.acceleration)\n    # print('gyro:', sensor.gyro)\n    # print('magnetic:', sensor.magnetic)\n    A = sensor.acceleration  # -1 and -2 Software correction\n    View.LoadXY(X, Y, (0, 0, 0), False)\n    if (A[1] > -1 and A[1] > X and X < View.Max - 1):\n        X = X + 1\n    elif (A[1] < -1 and A[1] < X and X > View.Min):\n        X = X - 1\n    if (A[0] > -2 and A[0] > Y and Y > View.Min):\n        Y = Y - 1\n    elif (A[0] < -2 and A[0] < Y and Y < View.Max - 1):\n        Y = Y + 1\n\n    Color = Color + Flag\n    if (Color == 10):\n        Flag = -2\n    elif (Color == 2):\n        Flag = +2\n\n    View.LoadXY(X, Y, (0, Color, Color), False)\n    View.Show()\n    utime.sleep_ms(100)\n```\n\n![](../../assets/micropython/basic/images/balance_ball.gif)"}, "/WebBit_doc/zh/micropython/basic/light.html": {"title": "光敏及手势检测", "content": "光敏及手势检测\n==============\n\n认识光敏传感器\n--------------\n\n细心的同学可能已经发现了，在bpibit这块板子上面有这样两个小东西，没错，这两个小东西就是光敏传感器。它是一个对光线敏感的传感器，经过采样电路可以把光的强度转换成电压的大小。\n\n![](../../assets/micropython/basic/light/bpi.png)\n\n它的型号是 PTSMD021 。\n\n![](../../assets/micropython/basic/light/ptsmd021.png)\n\n获取周围光照强度\n----------------\n\n在固件里有一个 light\n内建模块，调用这个模块中的函数我就可以轻松的获取到光线的强度。\n\n```python\nimport light\nfrom time import sleep_ms\nR = light.Intensity(39)\nL = light.Intensity(36)\n\nwhile True:\n    print('R=',R.read())\n    print('L=',L.read())\n    sleep_ms(1000)\n```\n\n我们要使用 light 这个模块，首先就要先导入这个模块，可以通过 import light 来导入。\n\n同理我们需要延时函数所以要导入 sleep\\_ms() 这个函数。\n\n那么 light.Intensity(39) 和 light.Intensity(36) 是什么意思呢，实际上这里做的是初始化光敏传感器的工作。 但那为什么是 36 和 39 呢，这个问题，我们留到内建模块的 API 文档中再进行补充说明。\n\n在完成了初始化之后，我们就可以调用 read() 函数来获取光线的强度了。read() 函数返回的是一个 0 1000 的数值，这个数值表明的当前大概的光照强度\n\n我们可以此时串口 REPL 打印出来的数据，图中用得 REPL 工具是[mpfshell-lite](https://github.com/BPI-STEAM/mpfshell-lite) 。\n\n![](../../assets/micropython/basic/light/message.png)\n\n通过光敏识别手势\n----------------\n\n从上面我们已经知道了，在我们的板子上面有两个光线传感器，那么我们就利用这两个光敏传感器来做一些有趣的事情吧，比如说简单的手势识别。\n\n在我们的 light 模块中预置了 Gesture() ，通过它就是让我们实现简单的手势识别，那就让我们来试一下吧。\n\n```python\nimport light\nfrom display import*\nts = light.Gesture()\ndisplay = Display()\nt = 0\nwhile True:\n    res = ts.get_gesture()\n    if res != None:\n        t = t+1\n        print(res, t)\n        if res == 'right':\n            display.show(Image.ARROW_E)\n        else:\n            display.show(Image.ARROW_W)\n```\n\n首先导入我们的 light 模块，然后实例化 Gesture() 这个类，ts = light.Gesture() 通过这段代码完成了检测手势动作的初始化。\n\n调用 get\\_gesture() 方法来检测我们的动作，这个检测函数执行需要大概 25ms 的时间，用 while True 是因为在这里我们想让它一直检测我们的手势，如果不想运行那么长的时间的话，我们可以用一个 for 语句来决定循环的次数，比如我们想让它在10S内检测手势动作，那就通过 for i in range(10 \\* 1000 / 25) 让 get\\_gesture() 循环400次就可以了。\n\n调用 get\\_gesture() 方法后，如果检测到向左的动作就会返回 ‘right’ ，如果是向左的动作就会返回 ‘left’ 。\n\n我们用手扫过两个光敏传感器，它就能检测到动作并返回结果。我们用手来回在板子上面扫过的执行的结果如下图所示\n\n![](../../assets/micropython/basic/light/message1.png)\n\n实测效果如下\n\n![](../../assets/micropython/basic/light/light.gif)\n\n> 在使用 get\\_gesture() 时要注意几个地方：\n> 要在光线强度适中的环境下使用，不要在光线太强或太弱的环境下使用，在室内日光灯下面使用，识别的准确率是最好的。\n> 使用时要确保光敏传感器面向光源，这个很重要，再强调一下要把板子朝向光源。\n\n我们了解可光敏传感器的使用方法后，我们就可以利用它来做一些有趣的事情，比如用手势来点亮led，检测光线强度来控制开关等等，还可以结合前面的\ndisplay ，开始你的脑洞并尝试动手做一些有趣的小东西吧\n\n如果你想知道为什么是 light.Intensity(39) 和 light.Intensity(36) ？就让我们来看一下电路图就一目了然了 (查看 bpibit 的原理图\\_)\n\n![](../../assets/micropython/basic/light/sensor.png)\n\n左边的光敏传感器连接的是引脚 pin36 ，右边的光敏传感器连接的是引脚 pin39。"}, "/WebBit_doc/zh/micropython/basic/temperature.html": {"title": "获取环境温度", "content": "获取环境温度\n============\n\n这个 LED 面板底下的 热敏电阻可以让你获得周围的环境温度。在使用它之前，建议将板子置于冷却下再采集，否则读取的温度和周围的温度有偏差，因为板子会发热，所以它的周围的影响最大的热源是板子自身的温度，所以环境的温度就会变成板子的温度。\n\n所以在板子还没开始发热之前，起初获取的一定是环境温度，后来才逐渐变成板子温度。\n\n赶快来试试吧\n------------\n\n```python\nfrom microbit import *\n\nwhile True:\n    temp = temperature() # get temperature ℃\n    print(temp)\n    display.scroll(str(temp))\n    sleep(10000)\n```\n\n实测对比效果\n------------\n\nLED 面板显示的内容\n\n![](../../assets/micropython/basic/temperature/tem.gif)\n\nREPL 打印出来的数据\n\n![](../../assets/micropython/basic/temperature/tem2.png)\n\n温度枪实测的温度\n\n![](../../assets/micropython/basic/temperature/tem1.jpg)"}, "/WebBit_doc/zh/micropython/basic/io.html": {"title": "控制金手指 IO", "content": "控制金手指 IO\n=============\n\nIO 在计算机中指 Input/Output ，也就是输入和输出，简称 IO 口。\n\n![](../../assets/micropython/basic/images/io.png)\n\n各种 IO 接口都不尽相同，有些特殊的接口是要更大一些，而且一般来说，它附近也会印有标签方便用户理解，如这块板子的底部是按照 0/1/2/3V/GND 的顺序分布在金手指上（计算机中大多都是是从 0 开始计算的）。\n\n如果你把金手指接上底座，那么其他更小的蓝白线条相间的引脚（pin）也就能够被用上了，这在第一章的硬件介绍的时候，是有特别指出的，忘了可以查看左侧的产品介绍。\n\n在这个 microbit 的模块中，将板子的接口定义为 pinN 对象，其中 N 代表接口的数值，所以 0 号接口也就叫做 pin0 对象，如果你在之后觉得这并不好用，可以通过 import machine 的 Pin 重新定义成自己喜欢的引脚名称。\n\n“害羞”的板子\n------------\n\n下面要写的一个案例，就非常有意思了。\n\n我想要触摸板子的引脚并让它做出对应的反应，看起来这个板子就好像个害羞的小姑娘。\n\n准备的代码如下：\n\n```python\nfrom microbit import *\nwhile True:\n    if pin1.is_touched():\n        display.show(Image.HAPPY)\n    else:\n        display.show(Image.SAD)\n```\n\n这个时候你需要一只手触摸在 1 号标签的引脚上，就可以能看到板子由 悲 转 喜 了，如果你松开了，它又会改变表情了，是生气吗？XD\n\n程序解释起来如下 1. 反复运行 `pin1.is_touched()` 来判断这个引脚是否有被触摸到。（原理是 ADC 采样） 2. 运行后返回了 True，此时显示它为笑脸，否则一直显示苦脸，所以你不去摸它的时候，它会感到悲伤的。（等等！这是哪门子的害羞呢！！！！）\n\n运行效果如下：\n\n![](../../assets/micropython/basic/images/touched_io.gif)\n\n需要注意的是，因为我们人体（手）有静电，有可能会电到它，导致它的表情有时候会很抽搐。\n\n灯的开与关\n----------\n\n最初上手的时候，我们早已学会了如何控制板子 LED 灯的变化，但那都是别人帮我们做好的，所以今天我们来亲自动手尝试一下，别人是怎么做到的，掌握它后成为别人常说的别人家的孩子 吧。\n\n为此我们准备了以下几个常见的 Led 灯，你会发现它们长短不一，这是为了区分它们的正负极，其中正极是长的那端，所以负极就是短的那端。\n\n提示：区分正负极的意图是希望你在接线的时候，元件（LED）正极接电源正极（+），元件（LED）负极接电源负极（-）。\n\n![](../../assets/micropython/basic/images/leds.jpg)\n\n我们开始第一步吧，先普通的把灯点亮，也就是直接将其（LED）接到电源上，那么就把大的那家伙直接接到板子的 3V 和 GND 上吧，3V 指电源正极（3V），GND 指电源负级，也称接地。\n\n![](../../assets/micropython/basic/images/led.gif)\n\n这样就点亮了一盏灯（注意正负极），但这样点亮的灯是不可以控制的，它只会亮，不能灭。\n\n本想拿另外一盏灯接上去做对比的，但我们发现一个问题，其他的灯都太短了，所以就交换了以下，用我们的大灯来控制了，可以看到此时接上去灯是不会亮的。\n\n![](../../assets/micropython/basic/images/led_off.jpg)\n\n那么我们就通过下面的代码来控制它的亮和灭吧，可以看图中我们使用了 pin2 的引脚来控制。\n\n```python\nfrom microbit import *\npin2.write_digital(1)\n```\n\n可以看到它亮了起来，那就说明我们可以控制了它的亮，这是不是就和最开始入门教程的一致了？\n\n![](../../assets/micropython/basic/images/led_on.jpg)\n\n那么我们这次就补充一个 Blink（闪烁）的效果吧，使用如下代码。\n\n```python\nfrom microbit import *\n\nwhile True:\n    pin2.write_digital(1)\n    sleep(200)\n    pin2.write_digital(0)\n    sleep(1000)\n```\n\n运行效果如下：\n\n![](../../assets/micropython/basic/images/blink.gif)\n\n\n1.  使用 pin2 引脚进行输出 1 ， 这会让 LED 存在变成高电平，简单认为上就是这个引脚有电压了，效果相当于直接接了电源正极。（原理上应该理解为两个引脚之间形成电势差）。\n2.  首先先将其点亮，即为 pin2.write\\_digital(1)，之后使用 sleep(200) 让板子休息 200 毫秒。\n3.  然后就将其熄灭，也就是 pin2.write\\_digital(0)，之后再休息 1000毫秒，也就是 1 秒。\n4.  将上述过程重新来一遍。"}, "/WebBit_doc/zh/micropython/basic/music.html": {"title": "播放简单的音乐", "content": "播放简单的音乐\n==============\n\n我提供了一个 MIDI 播放功能模块，它可以对指定的 蜂鸣器 进行 PWM 输出，从而播放出音乐，虽然你可能并不需要知道这些。\n\n咳咳，废话不多说，来点音乐，在板上已经预先接好了一个内置的蜂鸣器，其引脚位置为25，如果你有一定的动手能力，可以之后来学习如何自己接一个 蜂鸣器来播放音乐。\n\n> 不要装压电式蜂鸣器，它只能播放单个声调。\n\n使用代码如下（接口可参考 Microbit 文档）\n\n```python\nimport music\nmusic.play(music.NYAN)\n```\n\n可以看到有如下列表，这都是我们内置的音乐。\n\n```python\nmusic.DADADADUM\nmusic.ENTERTAINER\nmusic.PRELUDE\nmusic.ODE\nmusic.NYAN\nmusic.RINGTONE\nmusic.FUNK\nmusic.BLUES\nmusic.BIRTHDAY\nmusic.WEDDING\nmusic.FUNERAL\nmusic.PUNCHLINE\nmusic.PYTHON\nmusic.BADDY\nmusic.CHASE\nmusic.BA_DING\nmusic.WAWAWAWAA\nmusic.JUMP_UP\nmusic.JUMP_DOWN\nmusic.POWER_UP\nmusic.POWER_DOWN\n```\n\n挑选一些出来听听，应该会有你喜欢的。\n\n创作一首曲子\n------------\n\n写下一段 Python 的列表 `[\"C4:4\", \"D4\", \"C\", \"E:8\"]`，就代表一段音乐。\n\n这要如何理解呢？\n\n可以认为每一个元素都是一个音符，它的格式满足如下：\n\n```python\nNOTE[octave][:duration]\n```\n\n首先要有一丁点的乐理基本理解。\n\nNOTE 指这一节点的音阶，通俗来讲，音乐里的 C D E F G A B 就是音阶，如 `\"C\"` 指 do，所以 C D E F G A B 就是 do re mi fa so la xi。\n\noctave 指这一节点的八度，八度就是指音程关系，简单一点讲，就是你唱 1 2 3 4 5 6 7 1 （注释：1234567 对应的音名分别是CDEFGAB），第一个 1 就是最后一个 1 的低八度，最后一个 1 就是第一个1的高八度，低音到高音，越小就越低音。\n\nduration 指这一节点的拍子数，简单理解为该节点音符播放持续的时间。\n\n举例来说：\n\n`\"C4:4\"` 相当于 C（Do）在 4 （中音部分）的音符，接着 :4 指持续四个拍子，默认的拍子时长是 125 ms，即播放时长（duration）为 0.5s。\n\n如果你给节点 NOTE 命名为 R 那么在指定的时长里，喇叭就不会播放任何声音。\n\n为了很好解释这些，我们来看如下一章节的案例。\n\n> music 模块默认的拍子定位为 ticks=4, bmp=120，ticks指某个音符的拍子类型缺省值，如：‘C4’ 且 ticks=4，相当于‘C4:4’，意味着这个节点在 bpm 的基准下播放的时长，而 bpm 指每分钟节拍数的单位，电子音乐当中正是依赖于用 BPM 数值的高低来描述不同音乐的速率。\n> 根据公式可以算出基准的拍子 beats = 60(s) \\* 000 / 120 / ticks，如果是默认值，则拍子单位时长为 60000/120/4 = 125 milliseconds。\n\n试试播放音乐\n------------\n\n亲自试试这段代码吧。\n\n```python\nimport music\nmusic.play([ \"C4\", \"D4\", \"E4\", \"F4\", \"G4\", \"A4\", \"B4\", \"C5\"])\nmusic.play([ \"D1\", \"D2\", \"D3\", \"D4\", \"D5\", \"D6\", \"D7\", \"D8\"])\n```\n\n播放二只老虎\n------------\n\n我们为了能够在板子上播放这首经典的两只老虎，准备了如下代码。\n\n```python\nimport music\n\ntune = [\"C4:4\", \"D4:4\", \"E4:4\", \"C4:4\", \"C4:4\", \"D4:4\", \"E4:4\", \"C4:4\",\n        \"E4:4\", \"F4:4\", \"G4:8\", \"E4:4\", \"F4:4\", \"G4:8\"]\nmusic.play(tune)\n```\n\n而且神奇的是并不只会这样哦，它还可以进一步简化作曲过程，比如说，现在的节点 ‘C4:4’ 将会影响到之后的八度配置，直到有新的替换。 所以你可以这样写：\n\n```python\nimport music\n\ntune = [\"C4:4\", \"D\", \"E\", \"C\", \"C\", \"D\", \"E\", \"C\", \"E\", \"F\", \"G:8\",\n        \"E:4\", \"F\", \"G:8\"]\nmusic.play(tune)\n```\n\n是不是产生了同样的效果了呢？\n\n特殊的声音效果\n--------------\n\nmusic 让你制作非音符的声音，比如下面这里我们就创建了一个警笛声\n\n```python\nfrom microbit import *\nimport music\nwhile True:\n    music.pitch(range(880, 1760, 16), 15)\n    sleep(50)\n    music.pitch(range(1760, 880, -16), 15)\n    sleep(50)\n```\n\n稍微注意了，music.pitch 方法是使用它的实例，它需要一个频率，440的频率相当于一场用来调音的音乐会 a 的频率。\n\n另外，在这个案例中，range函数是被用作生成一个数字的值，这些数字定义了音调的音高，这三个参数分别分开始值，结束值，以及梯度值。因此，这里第一个range 的意思是。创造一个频率值从 880 开始，以 16 的跨度递增到 1760，而至于第二个 range 是说创造一个 1760 以 16 的跨度来递减到 880。这就使得我们可以发出 一上一下 像警笛一样的声音。\n\n最后我们还使用了`while Ture：` 它会让这个警笛声一直持续下去的，是不是很有意思呢？\n\n动手连接你的音响\n----------------\n\n大家在使用板子播放音乐的时候有没有发现声音有点小呢，在这里我们向大家介绍如何把板子连接到音响，用音响来播放音乐，如下图所示\n\n![](../../assets/micropython/basic/music/music.jpg)\n\nP0口连接音频线的左声道或者右声道，GND 连接音频线的GND\n\n![](../../assets/micropython/basic/music/5.png)\n\n从网络上获取乐谱\n----------------\n\n第一次接触这种音乐的格式不懂乐理的同学可能就有点懵了。那有没有一种可以快速获取乐谱的方法呢？有网友专门制作了一个转换工具，可以自动生成音频格式的数据。那就让我们来试试用这个工具生成板子可以播放的音乐数据吧。\n\n这个工具由 [fizban99](https://github.com/fizban99) 制作。\n<https://github.com/fizban99/microbit_rttl>\n\n转换的工作是一个excel的文件来实现的，我们首先下载这个excel文件，[点击下载](https://github.com/fizban99/microbit_rttl/raw/master/rtttl2microbit.xlsm)\n\n我们有了转换的工具了，接下来就需要下载音乐源文件了,点击下面连接进行下载\n[Zip file of Mixed Tunes 1 (450tunes)](http://www.picaxe.com/downloads/rtttl.zip) \n[Zip file of Mixed Tunes 2 (375 tunes)](http://www.picaxe.com/downloads/rtttl2.zip) \n[Zip file of Mixed Tunes 3 (10,000 tunes)](http://www.picaxe.com/downloads/rtttl3.zip) [Zip file of TV Theme Tunes (50 tunes)](http://www.picaxe.com/downloads/rtttl_tv.zip)\n[Zip file of Christmas Tunes (70 tunes)](http://www.picaxe.com/downloads/rtttl_xmas.zip)\n\n把下载的音乐源文件都解压，所有准备工作做好之后，打开我们之前下载的excel文件，你会见到像下面的界面。\n\n![](../../assets/micropython/basic/music/1.png)\n\n点击Open RTTTL tune file，它会自动弹出文件管理器，找到我们刚才解压的文件中的其中一个，选中要转换的音乐文件后，点击打开\n\n![](../../assets/micropython/basic/music/3.png)\n\n完成上面的步骤后我们就完成了转换的工作，点击 play 可以播放音乐文件，注意：这里的 Copy code 是使用不了的复制出来的是乱码，所以我们直接复制红框中的内容就好了\n\n![](../../assets/micropython/basic/music/4.png)\n\n复制转换出来的代码,就可以让板子播放音乐了\n\n```python\nimport music\nmusic.set_tempo(ticks=16, bpm=45)\ntune = ['D#6', 'D#', 'D#:2', 'F', 'G', 'G#', 'G#', 'G', 'F', 'F:6',\n        'D:2', 'D', 'D', 'D', 'D#','F', 'G', 'G', 'F', 'D#', 'D#:6',\n        'D#:2', 'D#', 'D#', 'D#', 'F', 'G', 'G#', 'G#', 'G', 'F', 'F:4']\nmusic.play(tune)\n```"}, "/WebBit_doc/zh/micropython/basic/button.html": {"title": "检测面板按键", "content": "检测面板按键\n============\n\n好的，至少我现在已经会创建一些代码让板子做一些事情了。\n\n那么，接下来我们来处理设备的输入，比如按键输入吧。\n\n首先，我们要知道两个概念， Output 输出是表示从设备输出到外围，Input 输入是处理设备过程中接受到的一些信息。\n\n那么在板子上最明显的输入便是二个按钮，灯板左右两个 A 和 B 按键，如果我们能想得知板子按键按下了吗，或者是按过吗，又或是，按了几次，要如何做到呢？\n\n其实这并不难，倒不如说很容易做到。\n\n```python\nfrom microbit import *\n\nsleep(2000)\n\ndisplay.scroll(str(button_a.get_presses()))\n```\n\n这段代码运行时候会先暂停两秒，然后你才开始按键，此时将会滚动显示你按下 A 的次数。就是这样简单，虽然这些代码并没有什么用，但还是提供了些许新思路，让你可以去想象更多控制硬件的方式。\n\n* sleep 函数可以让板子暂停些许时间，暂停的时间为方块数字的毫秒，如果你想在你的程序某个时候暂停，就按照上面那样写个sleep 函数就行。\n\n* button\\_a 对象允许你通过 get\\_presses 方法 获取一个时间内被按的次数\n\n然后一旦 get\\_presses 获取到了值，将其传递到 display.sroll 中，这个方法只能接受字符型，所以我们需要通过 str 函数将 整型转换成字符串，所以针对 python 原理我们做了一个假设，进行更深层次的理解 如果你在 10 秒内按了 10 次，那么上面代码的第三行怎么执行呢？ 由于 python 是从最内层开始执行代码的。 所以：\n\n`display.scroll(str(button_a.get_presses()))`\n\n当然变成这样就会显示你按下的按键次数（一段时间里，可指定）。\n\n`display.scroll(str(10))`\n\n现在python已经知道按了多少下了，所以接下来将里面的变成字符串，记注一定是最内层优先执行，即先执行 str(“10”)。\n\n`display.scroll(str(\"10\"))`\n\n循环处理事件\n------------\n\n如果你想要板子去响应一个按钮按压事件，那么你就需要用 if 进行判断按钮是否按压，而且这个判断方法建议放在一个死循环中。 例如：\n\n```python\nwhile True:\n    # Do stuff\n```\n\n所以我们可以构筑一个很简单的代码：\n\n```python\nfrom microbit import *\n\nwhile True:\n    if button_a.is_pressed():\n        display.show(Image.HAPPY)\n        display.clear()\n```\n\n此时可以按下按键 A 显示我们之前学习到的 Image ，这便是所谓的学以致用了。"}, "/WebBit_doc/zh/micropython/basic/compass.html": {"title": "制作一个指南针", "content": "制作一个指南针\n==============\n\n注意：在 1.2 的版型上没有磁力计功能。\n\n这个模块可以让你访问内置的电子罗盘(即 AK8963 )。在使用指南针之前，应该校准指南针，否则读数可能会出错。\n\n校准罗盘会导致程序暂停，直到校准完成。校准由一个小游戏组成，通过旋转板子在空中画圈完成校准。\n\n有关指南针的函数\n----------------\n\n执行此函数开始校准过程，你会收到一条有指导意义的信息，然后我需要旋转板子，在空中画一个倒立的’8’或着转圈，(这个动作可以参考你的手机，手机的指南针功能在使用之前都会有一个校准的步骤)，这个校准的过程会占用大概1分钟的时间，校准期间你无法执行其他程序。\n\n提示信息\n\n![](../../assets/micropython/basic/compass/prompt.png)\n\n如果罗盘校准成功，返回True，否则返回False。\n\n返回x轴上磁场强度的读数，它是一个正整数或负整数，取决于磁场的方向。\n\n返回y轴上磁场强度的读数，它是一个正整数或负整数，取决于磁场的方向。\n\n返回z轴磁场强度的读数，它是一个正整数或负整数，取决于磁场的方向。\n\n给出从上述读数计算出的罗盘航向，为0到360范围内的整数，表示按顺时针方向的角度，12点钟方向为0\n\n返回设备周围磁场大小，它是一个整数。\n\n体验一下指南针\n--------------\n\n```python\n\"\"\"\n    compass.py\n    Creates a compass.\n    The user will need to calibrate the compass first. The compass uses the\n    built-in clock images to display the position of the needle.\n\n\"\"\"\nfrom microbit import *\n\n# Start calibrating\ncompass.calibrate()\n# Try to keep the needle pointed in (roughly) the correct direction\nwhile True:\n    sleep(100)\n    needle = ((15 - compass.heading()) // 30) % 12\n    display.show(Image.ALL_CLOCKS[needle])\n```\n\n在这个例子中第一步程序先校准了电子罗盘（mpu），校准完成后我们可以看到我们的led面板上有一个指南针它不管我们如何转动板子它始终指向南方\n\n![](../../assets/micropython/basic/compass/compass.gif)"}, "/WebBit_doc/zh/micropython/advanced/leds.html": {"title": "再次点亮 LED 灯", "content": "再次点亮 LED 灯\n===============\n\n如果说 Hello World对软件程序员来说是一种宗教般的编程开始，那么对在硬件程序员的人来说，BlinkLed，亦如此，所有的硬件编程都是从点亮一盏灯开始的。因此我们讲究循序渐进，先是一盏灯，再是一排灯。\n\n![](../../assets/micropython/advanced/leds/ready.png)\n\n点亮 GPIO 上的 LED 灯\n---------------------\n\n### 进入 repl 模式\n\n![](../../assets/micropython/advanced/leds/into_repl.png)\n\n手动输入（也可以选取文本复制后，在黑框里右键粘贴）\n\n```python\nfrom machine import Pin\n```\n\n再次输入\n\n```python\nPin(18, Pin.OUT).value(1)\n```\n\n![](../../assets/micropython/advanced/leds/light_up.png)\n\n按下确定键（Enter）后即可看到面板上的灯有一盏亮起\n\n![](../../assets/micropython/advanced/leds/light_result.png)\n\n为了进一步确认它是我们控制的灯，输入\n\n```python\nPin(18, Pin.OUT).value(0)\n```\n\n![](../../assets/micropython/advanced/leds/light_down.png)\n\n这时就可以看到它灭了\n\n![](../../assets/micropython/advanced/leds/light_restore.png)\n\n### 使用 mian.py 文件\n\n准备以下代码到 main.py文件中，与上一个不同的是，这个效果是连续的，它将让灯亮起来后，等待一秒钟后灭了，由于展现的效果是连续的，没有办法通过图示来说明情况，所以自己动手试一试吧。\n\n```python\nfrom machine import Pin\nimport time\nled = Pin(18, Pin.OUT) # get a led on gpio 18.\nprint('turn on')\nled.value(1) # turn on\nprint('sleep 1s')\ntime.sleep(1) # sleep 1s\nprint('turn off')\nled.value(0) # turn off\n```\n\n![](../../assets/micropython/advanced/leds/mian_light.png)\n\n若是效果不明显，可以写成死循环来查看效果，注意使用`Ctrl + C`停下来，否则无法继续操作。\n\n```python\nfrom machine import Pin\nimport time\nled = Pin(18, Pin.OUT) # get a led on gpio 18.\nwhile True:\n      print('turn on')\n      led.value(1) # turn on\n      print('sleep 1s')\n      time.sleep(1) # sleep 1s\n      print('turn off')\n      led.value(0) # turn off\n      print('sleep 1s')\n      time.sleep(1) # sleep 1s\n```\n\n![](../../assets/micropython/advanced/leds/blink_led.png)\n\n点亮面板的 LED 阵列灯（NeoPixel）\n---------------------------------\n\n准备以下代码到 main.py 中\n\n```python\nfrom pixel import Pixel\nView = Pixel()\nRGB = (10, 10, 10)\nView.LoadXY(2, 2, RGB)\nView.Show()\n```\n\n使用 `runfile main.py` 执行即可。"}, "/WebBit_doc/zh/micropython/advanced/mqtt.html": {"title": "尝试 MQTT 应用", "content": "尝试 MQTT 应用\n==============\n\nMQTT 是什么？\n-------------\n\nMQTT现今是物联网的重要组成部分，它的服务外层拥有复杂的安全性功能，同时架构设计上属于数据转发服务器，举例来说，一个MQTT的服务器，可以解决不同类型的两套系统的数据交换，通过订阅与收发的接口设计，使得它只负责将两端的数据进行一个交换即可。\n\nMQTT服务器的传输模式可以认为是大家通过各自的内部约定后进入了一个公共的聊天室，如果你想和别人进行沟通，你可以创建一个聊天室（推送），你也可以加入别人的聊天室（订阅），服务器不管你们之间如何沟通，它只会帮你把这个聊天室建立起来，你们之间自由交换信息即可，也就因此完成了传输。\n\n举例来说：\n\n小明想向小红发送消息，那么小明可以创建一个话题（topic）的聊天室进行发送（publish），然后小红去加入（subscribe）这个话题（topic）的聊天室，这样她就可以收到小明的信息了，旧版的MQTT的聊天室是公开的，彼此之间可以任意加入别人的话题，也就是其他人也可以接收到小明的消息，但现在的MQTT服务器允许你私底下定义权限（config），让小明的话题（topic）只有小红可以加入。\n\n![image](../../assets/micropython/advanced/mqtt/process.png)\n\n> 在这样的架构下，我们之间的代码都是客户端代码，也就不需要去另外写服务端的接收程序了，只要双方约定好接口的数据协议就可以了，由于之间的通信过于透明，所以它目前的安全性还过分依赖于表层的认证，往后也会对此权限与通信控制进行改进的。\n\n准备 MQTT 服务器\n----------------\n\n使用公共的 MQTT 服务器，如果你没有服务器的话，点此进入[通信猫 MQTT服务器](http://www.tongxinmao.com/txm/webmqtt.php) ，注意看说明 WS 和 TCP 服务器的端口不一致，所以自己连接的时候是要改动一下服务器端口。\n\n你也可以直接在网上进行测试体验 MQTT服务，订阅自己的主题信息和发送自己的主题信息。\n\n![image](../../assets/micropython/advanced/mqtt/online_demo.png)\n\n如果不想使用网络的 MQTT 服务器，则你可以使用一下本地 [mosquittoWindows](https://github.com/BPI-STEAM/BPI-BIT-MicroPython/releases/tag/windows-mosquitto)服务器环境包，解压直接运行 mosquitto.exe 即可，其中配置文件是mosquitto.conf 。\n\n![image](../../assets/micropython/advanced/mqtt/config.png)\n\n正常情况下运行后它不会有任何数据显示的，否则会报错闪退，所以不用担心它是否有在工作，如果需要确认它是否工作正常，可以按以下教程来尝试。\n\n-   [windows环境下mosquitto环境搭建与mqtt测试](https://blog.csdn.net/pgpanda/article/details/51800865)\n-   [Windows安装mosquitto](https://www.cnblogs.com/xhxljh/p/7307100.html)\n-   [MQTT教學（二）：安裝MQTT伺服器Mosquitto，Windows系統篇](http://swf.com.tw/?p=1005)\n\n启动 MQTT 客户端\n----------------\n\n请先确认联网了后即可开始 MQTT 服务。\n\n现在准备如下代码\n\n```python\nimport wifi\nwifi.start()\n\nserver_ip = \"mq.tongxinmao.com\" # 在线公共的 MQTT 服务器\nclient_id = \"umqtt_client\" # 客户端 ID ，随意定义，用来标识自己发出的数据。\n\nimport time\n\nfrom umqtt.robust import MQTTClient\n\ntry:\n    # see https://github.com/micropython/micropython-lib/blob/master/umqtt.simple/umqtt/simple.py\n    c = MQTTClient(client_id, server_ip, 18830) # 配置连接，这个是连通信猫的服务器配置，端口是 18830，一般默认的是 1883\n\n    c.DEBUG = True # 输出 Debug 信息\n\n    def sub_cb(topic, msg):\n        print((topic, msg))\n        c.publish(topic, msg) # 无论收到什么订阅的信息都以同样的主题和数据传回。\n\n    c.set_callback(sub_cb) # 把向远端订阅（subscribe）的数据接收回调处理。\n\n    if not c.connect(clean_session=False):\n        c.subscribe(b\"foo_topic\") # 订阅一个 foo_topic 的主题（topic）\n\n    c.publish(b\"foo_topic\", b\"hello\") # 向  foo_topic 的主题（topic）发送 hello 字符串。\n\n    while 1:\n        # 让芯片运行慢一点，便于观察现象。\n        time.sleep(1)\n\n        # 等待处理 MQTT 的数据\n        if c.check_msg() is not None:\n            c.wait_msg()\n\n        # 没数据可以处理的时候可以做点别的事情\n        else:\n            print('other operator')\n\nfinally:\n    c.disconnect() # 调试程序事重开服务，要记得收尾，否则将重启板子才可以继续。\n```\n\n以上便是 MQTT 的具体实例，运行起来的应该有如下效果。\n\n1.  板子将向订阅了 foo\\_topic 主题的发送一条 `hello`数据，此时在网页上订阅该主题的用户应该会得到该数据，并显示出来。\n\n2.  板子订阅了 foo\\_topic 主题，所以会接收到 1 自己先前发送的 `hello`数据，然后根据代码可知，它会把这条接收的数据原封不动的发回去，所以这时候板子会在oo\\_topic 主题上循环接收和发送数据。\n\n3.  如果我们在网页端部分向 foo\\_topic 主题发送了数据，则板子会接收到数据并对应显示数据，例如图中所看到的`11 22 3311` 数据，注意这时候，你发的新数据也会参与 2 中所提及的循环输出数据了。\n\n![image](../../assets/micropython/advanced/mqtt/online_test.png)\n\n如果是网页上则会显示你在板子中定义发送的数据。\n\n![image](../../assets/micropython/advanced/mqtt/running.png)"}, "/WebBit_doc/zh/micropython/advanced/vscode.html": {"title": "改善一下编程环境（微软加持）", "content": "改善一下编程环境（微软加持）\n============================\n\n有没有觉得先前的工具都太 low 了？现在是时候换强大的 IDE 工具了。\n\n说说 VSCode\n-----------\n\n在 Build 2015 大会上，微软除了发布了 Microsoft Edge 浏览器和新的 Windows 10 系统外，最大的惊喜莫过于宣布推出免费跨平台的 Visual Studio Code 编辑器了！\n\nVisual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义快捷键、括号匹配和颜色区分、代码片段、代码对比Diff、GIT命令等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持Win、Mac 以及 Linux，运行流畅，可谓是微软的良心之作......\n\n安装 VSCode 编辑器\n------------------\n\n点此下载宇宙第一的编辑器 VSCODE \\<https://code.visualstudio.com/\\> 。\n\n安装 Mpfshell 插件\n------------------\n\n> 看不懂英文的到这里先搜索中文语言包下载。\n\n![image](../../assets/micropython/advanced/vscode.png)\n\n在拓展商店里，搜索并安装 Python 和 Mpfshell 插件，可以让你处在任何 Python 代码页面下右键编辑运行代码。\n\n使用方法请查看插件说明，其实和 Mpfshell 是一样的。\n\n![image](../../assets/micropython/advanced/vsc-mpfshell.png)\n\n是时候享受 IDE 带来的轻松编程了，工具在手，天下我有。"}, "/WebBit_doc/zh/micropython/advanced/pycharm.html": {"title": "使用 Pycharm IDE 编程", "content": "使用 Pycharm IDE 编程\n=====================\n\n是时候换一个顶级的 Python 专业 IDE 来编程了，你觉得呢？本文将教你如何在Pycharm 里写 MicroPython 并运行。\n\n获取 intellij-MicroPython 插件\n------------------------------\n\n在此下载intellij-micropython \\<https://github.com/BPI-STEAM/BPI-BIT-MicroPython/releases/tag/pycharm\\>\n。\n\n可以在此查看，[项目主页](https://github.com/junhuanchen/intellij-micropython)。\n\n安装 pycharm 社区版\n-------------------\n\n获取 [pycharm](https://www.jetbrains.com/pycharm/) 使用 windows 系统[点此下载 2019.1版本](https://download-cf.jetbrains.com/python/pycharm-community-2019.1.exe)(community 版免费使用)\n\n安装完成打开即可，按 默认 的设置一路进入到以下界面即可。\n\n![image0](../../assets/micropython/advanced/pycharm/03.png)\n\n新建一个项目\n------------\n\n点击 Create New Project 弹出以下界面。\n\n![image1](../../assets/micropython/advanced/pycharm/05.png)\n\n如果没有安装 Python 则是以下界面\n\n![image2](../../assets/micropython/advanced/pycharm/04.png)\n\n最后可以看到项目已经建立完成。\n\n![image3](../../assets/micropython/advanced/pycharm/06.png)\n\n安装 intellij-MicroPython 插件\n------------------------------\n\n![image4](../../assets/micropython/advanced/pycharm/07.png)\n\n![image5](../../assets/micropython/advanced/pycharm/08.png)\n\n![image6](../../assets/micropython/advanced/pycharm/29.jpg)\n\n提示：该版本已经修改了底层为mpfshell，并没有完全整合到官方，所以仍和主仓的插件同名，因此 IDE 提示插件需要升级或是其他修复的时候，会被替换回原版，遇到这种情况的时候，忽视了就好。\n\n![image7](../../assets/micropython/advanced/pycharm/09.png)\n\n运行一个文件\n------------\n\n安装好插件后，在项目中启动它。\n\n![image8](../../assets/micropython/advanced/pycharm/10.png)\n\n你可以在设置里搜索 `MicroPython`得到以上页面。\n\n![image9](../../assets/micropython/advanced/pycharm/11.png)\n\n现在启动它，依次点开如图设置，Enable MicroPython support。\n\n![image10](../../assets/micropython/advanced/pycharm/12.png)\n\n选择 ESP8266 （ESP32）配置设备类型，再点击 Detect可以自动判断你连接的板子的路径（或名称），此时的 Detect 一定会失败，因为关键的依赖还没安装。\n\n![image11](../../assets/micropython/advanced/pycharm/13.png)\n\n当出现自动识别串口失败，则需要你自己填入自己板子的串口名称（包括路径），或是其他连接参数，比如：ws:192.168.1.1,1234，这和 `mpfshell` 的 open 是一样的。\n\n![image12](../../assets/micropython/advanced/pycharm/14.png)\n\n此时已经设定好板子的连接参数了，现在可以在 untitled 处右键新建一个python文件，第一次使用的时候，务必创建一个文件来触发安装依赖，安装完成后才能使用自动识别串口和 其他工具（菜单项中的 Tools）。\n\n![image13](../../assets/micropython/advanced/pycharm/15.png)\n\n在右侧代码编辑框中写入一句`print(helloworld!)`。\n\n![image14](../../assets/micropython/advanced/pycharm/16.png)\n\n第一次使用的时候，会提示你需要安装依赖项，因此点击消息的 Install requirements 即可在后台自动下载安装。\n\n![image15](../../assets/micropython/advanced/pycharm/17.png)\n\n耐心等待一会就可以了。\n\n![image16](../../assets/micropython/advanced/pycharm/18.png)\n\n安装完成会提示。\n\n![image17](../../assets/micropython/advanced/pycharm/19.png)\n\n现在我们可以运行 main.py 文件了，在编辑框的任意地方右键显示菜单选取 Run ‘Flash main.py’，即可自动生成运行文件配置并在板子中运行。\n\n> 如果 Linux 系统出现串口连接不上，须核对串口是否对一般用户有权限，如果不确定，请核对这条指令`usermod -a -G dialout Username && sudo reboot`，Username 是指你的用户名，不是 Username 。\n\n![image18](../../assets/micropython/advanced/pycharm/20.png)\n\n可以看到运行结果如下\n\n![image19](../../assets/micropython/advanced/pycharm/21.png)\n\n直接使用 Mpfshell\n-----------------\n\n在 MicroPython -\\> Run Mpfshell Tools 中可以使用 REPL 和 Mpfshell 的快捷功能。\n\n![image20](../../assets/micropython/advanced/pycharm/22.png)"}, "/WebBit_doc/zh/micropython/advanced/index.html": {"title": "进阶教程", "content": "进阶教程\n========\n\n当你掌握了前面那些基础的教程后，你已经入门了，具备基础的使用代码的能力，想要进阶的话，就要看更高级的开发文档了。\n\n看到这里，就是走进真正意义上的 Python 编程了。\n\n请从 [Python3菜鸟教程](https://www.runoob.com/python3/python3-tutorial.html)这里学会安装 Python3 环境，并运行 Python3 代码。\n\n接下来的教程可能对你来说会难懂许多，但也是你编程修炼的必经之路。\n\n在 Windows 任何地方按下 Win + R 键弹出运行框，并输入 [cmd]{.title-ref}，确认弹出黑窗。\n\n![](../../assets/micropython/advanced/run.png)\n\n然后请确认你系统里安装了 Python3 和 PIP 代码包管理工具。\n\n![](../../assets/micropython/advanced/python3.png)\n\n如图示可知。\n\n-   输入 python 显示 [Python 3.5.4 (v3.5.4:3f56838, Aug 8 2017,02:17:05) \\[MSC v.1900 64 bit (AMD64)\\] on win32]{.title-ref}表示安装了 python 3.5.4 ，此时按 Ctrl + C 可以退出。\n-   输入 pip -V 可以得知当前的 pip Python软件包管理工具版本，它可以帮你快速安装一些工具包。\n\n确认了这两件事后，就可以开始你的进阶之旅了。"}, "/WebBit_doc/zh/micropython/advanced/codelab.html": {"title": "如何使用 scratch3 for bpi:bit", "content": "如何使用 scratch3 for bpi:bit\n=============================\n\n在线 [Scratch3 Codelab](https://scratch3.codelab.club/)网站，更详细的看这里[codelab](https://www.codelab.club) 和 [scratch开源文档](https://blog.just4fun.site/tag/scratch.html)。\n\n首先选择适合你的系统版本，获取[adapter](https://adapter.codelab.club/user_guide/install/)，无需安装，打开即可。\n\n接着参考一下 [usb\\_microbit使用手册](https://adapter.codelab.club/user_guide/usage/#3-microbit)，同理，如下图，勾选mpfshell 选项。\n\n![](../../assets/micropython/advanced/codelab/used.png)\n\n如何使用它们？\n--------------\n\n确定 adapter 软件 和 scratch3 网站都打开了。 在 scratch3网站中，接着点开它（左下角的拓展按钮）\n\n![](../../assets/micropython/advanced/codelab/external.png)\n\n并滚动到最底，找到 bpi:bit 插件选择它，点击确认后回到主界面。\n\n![](../../assets/micropython/advanced/codelab/select.png)\n\n勾选 isconnected 表示进行连接\n\n![](../../assets/micropython/advanced/codelab/isconnected.png)\n\n此时插入硬件，点击连接，可以看到很快就连上了。（如果不能确定，就用通常的mpfshell 的方式来核对一下吧）\n\n![](../../assets/micropython/advanced/codelab/result.png)\n\n此时它可以用的标准积木有如下图\n\n![](../../assets/micropython/advanced/codelab/function.png)\n\n自此你就可以自由的使用自带的积木了，但是，如果你对自带的积木不满意，可以直接使用mpfshell，直接控制硬件，直接完成接口的调用和测试，如果你希望某些组合调试的接口，变成一个单独的积木，可以提交给我，直接合并，但是因为scratch3 还没有动态积木载入，所以没办法完全开放对接。\n\n![](../../assets/micropython/advanced/codelab/demo.png)\n\n如何使用 Scratch3 for Mpfshell ？\n---------------------------------\n\n如何使用 mpfshell ，其实只需要看几个实例就知道它们的由来和对照关系了。\n\n![](../../assets/micropython/advanced/codelab/example.png)\n\n如果你知道 mpfshell怎么用，那么这个也是同样的道理，所谓的控制硬件实际上就相当于每次调用mpfshell exec 而已。\n\n但要注意的地方就是 eim/mpfshell/exec/bpibit是一个典型的主题，意思是指，这个是一个实例的访问接口了，如果你有多个硬件的话，它就会呈现出不同的接口，比如默认的mpfshell 插件主题的是 eim/mpfshell/exec/default ，而 bpibit 的拓展是eim/mpfshell/exec/bpibit，所以可以根据这种区分多个实例的控制，等到你需要的时候，就会发现它的必要性了。\n\n说说它是如何设计出来的\n----------------------\n\n这次我们提供了可二次编辑的接口，但如果真的想知道如何做到的可以了解这两个项目。\n\n-   [scratch3-eim-mpfshell](https://github.com/junhuanchen/scratch3-eim-mpfshell)\n-   [webduino-module-eim](https://github.com/junhuanchen/webduino-module-eim)\n\n并且 scratch3 插件最后会期望同步到 Webduino blockly 当中，因为在我们blockly的平台上，允许不建立服务器也可以定义属于自己的积木，意味着可以更加专注的实现自己的积木了，而不是每修改一次就要合并到服务器里重建。这样开发出的积木和拓展插件是完全属于自己的，还可以通吃绝大部分积木前端平台了，更加的自由不受限制，完美！"}, "/WebBit_doc/zh/micropython/advanced/wifi.html": {"title": "让板子联上网", "content": "让板子联上网\n============\n\n> 20190528 以后正式版的固件已经关闭了 debug 信息，所以你需要禁用下述代码，可在 boot.py 内容修改它。\n\n```python\nimport esp\nesp.osdebug(None)\n```\n\n连接 WIFI 热点\n--------------\n\n固件上电后，在面板 LED 灯滚动完毕后，默认就会尝试联网，你可以注意到，如果这时候被工具或人为的 Ctrl + C 停止后，将不会进行联网操作，需要使用以下代码\n\n```python\nimport wifi # booy.py default enable\nwifi.try_connect()\n```\n\n效果如下图，默认 boot.py 里会默认调用 `import wifi`，所以你也可以直接在 REPL 中调用 `wifi.try_connect()`。\n\n![image](../../assets/micropython/advanced/wifi/try_connect.png)\n\n在默认的联网模式下，如果从来没有配网过，板子最初会自动连接 WIFI 名称 `webduino.io` 密码 `webduino` 的 WIFI 热点。\n\n如果附近没有该热点，将会输出`no AP found`，而我的环境里提前准备了这个热点，因此会得到一个IP地址`192.168.10.185`（如图），否则将会反复输出连接存在的问题（这并不会影响你的输入和输出），如果不希望它继续连接网络，可以手动输入`wifi.close()`停止 WIFI 连接。\n\n![image](../../assets/micropython/advanced/wifi/got_ip.png)\n\nSmartConfig 配网\n----------------\n\n当然，你的 WIFI 热点不一定是这个，所以你现在可以在开机的 LED 滚动过程中按下 **A键** 并松开，会自动进入配网模式，重新给板子连入其他WIFI，帮助板子连上指定WIFI，进入`SmartConfig` 的配网模式，LED（18）将会亮起，图例所示 LED 灯。\n\n![image](../../assets/micropython/advanced/wifi/start_config.png)\n\n复位后看板子的 LED 灯长亮。即可确认进入了配网模式，如果有必要，你也可以在此时的串口查看输出对应的信息。\n\n> 在这个模式将无法正常使用 `Mpfshell` 的 open ，但可以使用其他串口工具进入，这是因为此时板子已经无法响应 REPL 操作了，当配网完成后 REPL 会继续运行。\n\n![image](../../assets/micropython/advanced/wifi/smartconfig.png)\n\n若运行期间工具软件出错，你也可以使用其他串口工具查看输出信息。\n\n确认进入了配网模式后，此时你需要使用一台安卓手机来安装[EspTouch](https://github.com/EspressifApp/EspRelease/raw/master/EspTouch/esptouch.apk)的配网软件，你也可以在手机应用市场里搜索 SmartConfig 相关软件下载使用。\n\n> 现在软件发展速度很快，下图中的软件 UI 界面已经改变，但功能不变，请下载 EspTouch.APK 查看，支持在 Android 9+ 以后读取 WIFI 名称。如果获取不到，请到社区中搜索获得。\n\n![image](../../assets/micropython/advanced/wifi/view_apk.png)\n\n以 `Android-SmartConfig.apk` 为例，先将手机连入WIFI，然后再将让板子也连入同一个WIFI，再到软件中输入所连WIFI的密码，这将告知板子，如何连接到该WIFI。\n\n![image](../../assets/micropython/advanced/wifi/open_apk.png)\n\n点击唯一的按钮启动配网，可以看到 REPL 有对应信息输出，同时板子的 LED 灯也会跟着变化。\n\n等待一会，如果卡在了配网模式没有成功，则会在两分钟内会自动重启。而当配网成功后，LED 灯会变成 **微亮**，此时 REPL 会输出板子连上 WIFI 得到的 IP 地址，如下图为：`192.168.10.185`，并且 值得注意的是 3de1 就对应的是板子的名称，这个名称以后会用到。\n\n![image](../../assets/micropython/advanced/wifi/smc_apk.png)\n\n并且在手机上，也会看到板子的 IP 地址，此时板子已经完成了网络配置。\n\n![image](../../assets/micropython/advanced/wifi/smc_finish.png)\n\n![image](../../assets/micropython/advanced/wifi/apk_finish.png)\n\n小提示：如果配网失败，请按以下流程排除问题。\n\n-   确认进入了 配网模式（SmartConfig）\n-   确认 WIIFI 热点密码无误\n-   输入 wifi.isconnected() 返回 True\n-   确认 WIFI 射频 是 2.4Ghz（重要）\n\n修改联网配置文件\n----------------\n\n当你出现以上配网失败的时候，且找不到任何解决办法，你可以直接修改联网的配置文件，即手动创建或修改 WIFI 名称和密码配置文件 `wifi_cfg,py`。\n\n（现在固件会在调用 wifi.start() 后自动生成 `wifi_cfg,py`）\n\n准备一个 `wifi_cfg,py`, 其中内容为：\n\n```python\nWIFI_SSID = '你的WIFI热点名称'\nWIFI_PSWD = '你的WIFI热点密码'\nHOST_NAME = '你板子的网络名称' # 可选\n```\n\n（现在已经可以先 `get wifi_cfg.py` 取回配置）与 `mpfshell` 同一个目录中使用 `put wifi_cfg.py`, 将其替换掉现在的 WIFI 连接配置。\n\n你也可以直接在 `repl` 中输入‘wifi.smartcoinfig()’，来手动启动配网模式，而不是使用开机时的按键触发。\n\n无线使用 REPL\n-------------\n\n注意，使用前确保允许应用通过网络防火墙，且电脑与板子连接处于同一网络下（同一个WIFI下）。\n\n在这之前先进入 `repl` 输入`import webrepl_setup`启动网络配置流程。\n\n根据步骤依次为（e、1234、y）\n\n启动网络服务配置（启动输入 e，停止输入 d）设置网络连接密码（不少于4位，需输入两遍，由自己决定，我只是为了省事）是否需要重启板子（复位输入y，否则输入 n）\n\n![image](../../assets/micropython/advanced/wifi/webrepl.png)\n\n此前我已经知道了板子现在的 IP为`192.168.10.185`，如果不知道可以重新上电查看，接着使用`mpfshell`，输入`ws:192.168.10.185,1234`，其中`,1234`是我此前设定的连接密码（前一章），你也可以现在不输入，但待会也一样会提示你输入密码的。（注意是英文输入法的逗号）\n\n![image](../../assets/micropython/advanced/wifi/into_webrepl.png)\n\n可以看到已经连接成功，此时板子也可以透过无线来操作了，你也可以重启复位再试一次。\n\n连接失败会有以下两种提示：\n\n连接远端无响应，提示`WebREPL Remote IP Does not respond`，分析的情况是一种可能是与板子不同属一个网络，另一种可能是各种软件或硬件防火墙挡住了。\n连接密码错误，提示`WebREPL Password Error`，重新输入密码即可，也许你连到别人的板子了。\n出现问题时的操作，假设连不上，先用有线进去按 Ctrl + D软复位后核对连接，接着退出来换成无线连接。\n\n![image](../../assets/micropython/advanced/wifi/error_webrepl.png)"}, "/WebBit_doc/zh/micropython/advanced/mpfs.html": {"title": "再谈 REPL", "content": "再谈 REPL\n=========\n\n> 请确认您的编程环境里已经安装了 Python3 和 pip工具，否则下面的内容你都无法开始。这里推荐使用[MicroPython-Samples](https://github.com/BPI-STEAM/MicroPython-Samples)来部署你的开发环境。\n\n我们已经知道 REPL可以进行一些简单的代码交互和反馈，现在我们就要让重新认识一下 REPL 了。\n\n安装 mpfshell 工具\n------------------\n\n请从此处获取 [mpfshell-lite](https://github.com/BPI-STEAM/mpfshell-lite)工具，安装与使用方法均在此提及。\n\n在 mpfshell 的 REPL\n-------------------\n\n安装了它，在 repl 即可使用下述的功能，当然你也可以在 Xshell 、 MobaXterm等其他串口终端中实现。\n\n![image](../../assets/micropython/advanced/mpfs.png)\n\n### 输入历史记录\n\nREPL 会记住您输入的一定数量的前几行文本（在 ESP32 上最多 8 行）。要调用上一行，请使用 向上 和 向下 箭头键。\n\n### 使用 Tab 键\n\nTab键可以查看模块中所有成员列表。这对于找出模块或对象具有的函数和方法非常有用。假设您在下面的例子中导入了 import machine 然后键入 `.` 再按 Tab 键以查看 machine 模块所有成员列表:\n```\n    >>> import machine\n    >>> machine.\n    __class__        __name__        ADC              DAC\n    DEEPSLEEP        DEEPSLEEP_RESET                  EXT0_WAKE\n    EXT1_WAKE        HARD_RESET       I2C              PIN_WAKE\n    PWM              PWRON_RESET     Pin              RTC\n    SLEEP            SOFT_RESET       SPI              Signal\n    TIMER_WAKE       TOUCHPAD_WAKE    Timer            TouchPad\n    UART             ULP_WAKE        WDT              WDT_RESET\n    deepsleep        disable_irq     enable_irq       freq\n    idle             mem16            mem32            mem8\n    reset            reset_cause     sleep            time_pulse_us\n    unique_id        wake_reason\n    >>> machine.\n```\n### 行继续和自动缩进\n\n您键入的某些内容将需要“继续”，也就是说，需要更多行文本才能生成正确的Python 语句。在这种情况下，提示符将更改为`...`并且光标将自动缩进正确的数量，以便您可以立即开始键入下一行。通过定义以下函数来尝试此操作:\n```\n    >>> def toggle(p):\n    ...    p.value(not p.value())\n    ...    \n    ...    \n    ...    \n    >>>\n```\n在上面，您需要连续按三次Enter键才能完成复合语句（即三条线上只有点）。完成复合语句的另一种方法是按退格键到达行的开头，然后按Enter键。\n（如果您输错了并且想要退出，那么按ctrl-C，所有行都将被忽略。）\n\n您刚刚定义函数功能为翻转引脚电平。您之前创建的pin对象应该仍然存在（如果没有，则需重新创建它），您可以使用以下命令翻转LED:\n\n```\n    >>> toggle(pin)\n```\n\n现在让我们在一个循环中翻转 LED （如果您没有 LED，那么您可以打印一些文本而不是调用切换，看看效果）：\n\n```\n\\>\\>\\> import time \\>\\>\\> while True: ... toggle(pin) \\# print('test')\n... time.sleep\\_ms(500) ... ... ... \\>\\>\\>\n```\n\n这将以1Hz（半秒开，半秒关）翻转LED。要停止切换按 `ctrl-C`，这将引发键盘中断异常并退出循环。\n\n### 粘贴模式\n\n按 `ctrl-E`将进入特殊粘贴模式，您可将一大块文本复制并粘贴到REPL中。如果按ctrl-E，您将看到粘贴模式提示:\n```\n    paste mode; Ctrl-C to cancel, Ctrl-D to finish\n    === \n```\n\n然后，您可以粘贴（或键入）您的文本。请注意，没有任何特殊键或命令在粘贴模式下工作（例如Tab或退格），它们只是按原样接受。按 `ctrl-D` 完成输入文本并执行。\n\n### 其他控制命令\n\n还有其他四个控制命令：\n\n-   空白行上的 Ctrl-A 将进入原始 REPL\n    模式。这类似于永久粘贴模式，除了不回显字符。\n-   空白处的 Ctrl-B 转到正常的 REPL 模式。\n-   `Ctrl-C` 取消任何输入，或中断当前运行的代码。\n-   空白行上的 `Ctrl-D` 将执行软重启。\n\n管理板子上的文件\n----------------\n\nmpfs 提供了真正意义上的文件管理功能，近似大多数 linux 终端文件管理工具。\n\nMicroPython 内部提供了基于 oofats 建立的 FAT16分区文件系统，就可以在上面存放一些文件内容，如代码文件、资源文件、音乐文件等等。\n\n详细的你需要去看 mpfshell 的 readme 文档，在这里我说明几个重要功能即可。\n\n> mpfs 即为 mpfshell 的简称。\n\n### 运行 python 文件 lexecfile 和 execfile\n\nexecfile 指运行板子上存在的代码文件，添加了 l即可将本地的代码文件传到板子中并进入 repl 中运行。\n\n### 查看板子上的所有文件 ls\n\n这将列举板子上所有的目录、文件的名称。\n\n```shell\nmpfs [/]> ls\n\nRemote files in '/':\n\n    boot.py\n    wifi_cfg.py\n```\n\n### 快速查看文件内容 cat\n\n假如要查看上述所显示的 boot.py 文件，输入 cat boot.py 。\n\n```shell\nmpfs [/]> cat boot.py\n# This file is executed on every boot (including wake-boot from deepsleep)\n#import esp\n#esp.osdebug(None)\n#import webrepl\n#webrepl.start()\nimport wifi\nwifi.ready()\n\nmpfs [/]>\n```\n\n### 删除指定文件 rm\n\n假如要删除上述所显示的 boot.py 文件，输入 rm boot.py\n即可，此操作不可逆。\n\n### 文件的 推送 put 和 获取 get\n\n这两兄弟可以帮你把文件下载或上传，保存在 lpwd 目录下，可用 lcd 修改。\n\n还有更多功能你需要 亲自去尝试 或 在工具的文档中 寻找答案。"}, "/WebBit_doc/zh/micropython/advanced/wireless.html": {"title": "认识无线编程", "content": "认识无线编程\n============\n\n使用有线的方式连接板子已经是上个世纪的特色了，所以我们在以后的开发过程中，是支持且尽量往无线控制的方向上出发的，因为各种简单物联网设备是不会特地留一个有线接口给你连接电脑控制的，例如：一盏智能控制的灯。\n\n所以这时候无线就派上用处了，可以看到，在板子联网的时候，我们是可以不需要插入电脑的方式来直接帮助板子上网的，所以这便是无线的编程基础，要通过一个简单的方式让板子进入你所在的网络，你才能控制它。\n\n远程连接板子\n------------\n\nMicroPython 的交互接口使用的是 Python REPL，也就是它本身就是一个可再次操作的系统运行环境，与以往的Linux不同，它的特点就是简单容易使用，我们不是本身就是在享受科技给我们带来的美好，如果说编程只会让工具变得难用，那为何还要继续编程呢？\n\nREPL 是有线的时候常用的交互接口，而在无线上，则推出了[WebREPL](http://micropython.org/webrepl)，顾名思义，就是云端的 REPL ，如下图：\n\n![](../../assets/micropython/advanced/wireless/webrepl.png)\n\n可以看到它可以直接操作板子了，像过去的有线连接一样，响应速度非常快，和有线的感受差别不大。\n\n但这样显然还是不够的，因为这个编辑器只能够用，但并不好用，所以我还专门在 mpfshell 适配了 webrepl 的，也就是说，基于 mpfshell 的 pycharm 插件，也同样支持 无线编程 ，那么，所有觉得好用的功能全都用上了，如下图。\n\n![](../../assets/micropython/advanced/wireless/pycharm.png)\n\n运行程序正常，但需要注意两者的路径设定不太一样。\n\n1.  webrepl 标准路径为 `ws://192.168.30.116:8266`。\n2.  mpfshell 的路径则为:`ws:192.168.30.116,1234`，区别在于后者允许顺带密码，从而免去了连接认证。\n\n至此，你已经可以像过去有线一样使用它了，如果期间出现任何问题，只需要重启板子即可，它会自动上电连接网络并打开 Webrepl 的支持服务。\n\n未来将会使用电池供电的方式，脱离电脑供电，所以你可以完全脱离有线自由的控制它了，注意必要时刻需要降频至 80Mhz ，不然很快就会没有电的。\n\n远程管理板子\n------------\n\n虽然可以使用了 REPL 的方式去对板子进行编程控制了，但我们还需要一些额外的网络支持服务才能让我们的板子玩得更加愉快。\n\n这里我简单介绍一下它们。\n\n### FTP 标准文件系统操作服务\n\n使用以下代码即可启动 FTP 服务：\n\n```python\nimport ftptiny\nftptiny.FtpTiny().start()\n```\n\n![](../../assets/micropython/advanced/wireless/ftp.png)\n\n#### WebDAV HTTP 文件系统服务（在 20190312 后固件暂时移除了）\n\n使用以下代码即可启动：\n\n```python\nimport webdav\nwebdav.start()\n```\n\n![](../../assets/micropython/advanced/wireless/webdav.png)\n\n它和 FTP 不一样的地方就是使用的是 80 端口，访问的时候是用的 http，而不是\nftp。\n\n![](../../assets/micropython/advanced/wireless/webdav_index.png)\n\n### Hostname local 域名服务\n\n这个需要特定的路由服务支持，例如：openwrt(linux)。\n\n它允许你使用 hostname.lan （或直接 hostname）的方式代替 IP 来访问板子。\n\n所以不需要再去记忆 IP 地址了，而是自己定义自己的板子名称。\n\nhostname 保存在下图 wifi\\_cfg.py 文件中。\n\n![](../../assets/micropython/advanced/wireless/wifi_cfg.png)\n\n如图的 bit3D6D，访问方法和测试方法如下。\n\n![](../../assets/micropython/advanced/wireless/hostname.png)\n\n而如何使用呢？\n\n![](../../assets/micropython/advanced/wireless/hostname_demo.png)\n\n而你之后去其他地方更换网络了，也不需要更换 IP，只需要更换连接的 WIFI 配置就可以了。\n\n### MDns 反向域名解析服务\n\n如果你用不了 hostname 的方式来取代 IP 的记忆，除了请求云端服务商注册 DNS 域名解析外，那还有一个办法，就是反向注册 DNS ，DNS 本是服务端特有的管理服务，底下的客户端是不可以再改动的，所以呢，我们就使用主动申请的域名解析从而获得自己特定的域名。\n\n说白了，就是把 IP 变成了 自定义的网络路径，例如：hostname.local。\n\n如下示范，这也同样需要比较新的路由器支持，只要不是上个世纪的路由器，基本都支持了这个服务，但不否认 10 年之前产的路由器，可能都不一定带有这个 MDns 服务，包括电脑也不一定支持，Windows 需要额外安装 Bonjour Print Services 功能，可在[此处下载](https://support.apple.com/kb/DL999)。\n\n现在我使用如下代码来配置板子拥有 Mdns 的注册功能（所有操作都是基于联网的条件下）。\n\n```python\ntry:\n    import network\n    mdns = network.mDNS()\n    mdns.start(\"bpibit\", \"MicroPython with mDNS\")\n    _ = mdns.addService('_ftp', '_tcp', 21, \"MicroPython\",\n                         {\"board\": \"ESP32\", \"service\": \"bpibit FTP File transfer\", \"passive\": \"True\"})\n    _ = mdns.addService('_telnet', '_tcp', 23, \"MicroPython\", {\"board\": \"ESP32\", \"service\": \"bpibit Telnet REPL\"})\n    _ = mdns.addService('_http', '_tcp', 80, \"MicroPython\", {\"board\": \"ESP32\", \"service\": \"bpibit Web server\"})\n    print(\"mDNS started\")\nexcept Exception as e:\n    print(\"mDNS not started\")\n```\n\n在电脑中可以使用 `bpibit.local` 替代 IP 地址访问它，如下图，你也可以取自己想要的名字，改掉代码里的 `mdns.start(\"bpibit\", \"MicroPython with mDNS\")` 即可。\n\n![](../../assets/micropython/advanced/wireless/mdns.png)\n\n但实际上不仅如此，还可以知道它提供了什么服务等等，我用了其他软件来查看，以下是手机中查看的结果，可以看到 MicroPython 对应的是 mdns.addService 的参数。\n\n![](../../assets/micropython/advanced/wireless/mdns_server.png)\n\n看图可以得知是我们注册的时候提供的信息，如 FTP 和 HTTP 服务。\n\n### Python 动态建立网站服务\n\nWebdav 实现的是静态的纯粹网站，并不适合利用后台的 Python 进行运算的网站服务。\n\n所以在固件里提供了 [microwebsrv](https://microwebsrv.hc2.fr/) 用以搭建 Python 动态网站。\n\n这之后会专门出一个简单应用示例以做说明，它将类似 PHP 语言一样建立网站服务。"}, "/WebBit_doc/zh/micropython/library/machine/machine.RTC.html": {"title": "类 RTC -- 实时时钟", "content": "类 RTC -- 实时时钟\n============================\n\nRTC是独立的时钟，可以跟踪日期和时间。\n\n示例:\n\n```python\nimport machine\nfrom machine import RTC \nrtc = machine.RTC()\nrtc.init((2018, 11, 21, 3, 9, 0, 0, 0))\nprint(rtc.datetime())\n```\n\n构建对象\n------------\n\n```python\nclass RTC()\n```\n\n创建RTC对象。\n\n方法\n-------\n\n```python\nRTC.init([datetimetuple])\n```\n\n始化RTC。日期时间为下列形式的8元组：\n```\n( year,month,day,weekday,hour,minute,second,microsecond )\n```\n - ``weekday`` -从周一到周日对应1-7。\n\n\n```python\nRTC.datetime([datetimetuple])\n```\n\n设置RTC日期和时间。\n\n8元组格式同上文。"}, "/WebBit_doc/zh/micropython/library/machine/machine.html": {"title": "machine - 与硬件相关的功能", "content": "machine - 与硬件相关的功能\n====================================================\n\n该 ``machine`` 模块包含与特定电路板上的硬件相关的特定功能。该模块中的大多数功能允许直接和不受限制地访问和控制系统上的硬件块（如CPU，定时器，总线等）。\n使用不当，可能导致故障，锁定，电路板崩溃，以及在极端情况下硬件损坏。\n\n关于 `machine` 模块的函数和类方法使用的回调的注释：所有这些回调应被视为在中断上下文中执行。\n这对于ID> = 0的物理设备和具有负ID（例如-1）的“虚拟”设备都是如此（这些“虚拟”设备在真实硬件和实际硬件中断之上仍然是薄的垫片）。\n\n- 类 Pin – 控制 I/O 引脚\n- 类 ADC – 模数转换\n- 类 TouchPad – 触摸\n- 类 PWM – 脉冲宽度调制\n- 类 UART – 双工串行通信总线\n- 类 I2C – 双线串行协议\n- 类 SPI – 串行外设接口总线协议 (主端)\n- 类 Timer – 控制硬件定时器\n- 类 RTC – 实时时钟\n- 类 WDT – 看门狗定时器\n\n复位相关函数\n-----------------------\n\n```python\nreset()\n```\n与按下外部 RESET按键效果一样.\n\n```python\nreset_cause()\n```\n获得重置原因。\n\n\n中断相关函数\n---------------------------\n\n```python\ndisable_irq()\n```\n 禁用中断请求。返回先前的IRQ状态，该状态应被视为不透明值。`enable_irq()` 在 `disable_irq()` 调用之前，\n 应将此返回值传递给函数以将中断恢复到其原始状态。\n\n\n```python\nenable_irq(state)\n```\n 重新启用中断请求。`state` 参数应该是最近一次调用`disable_irq()` 函数时返回的值。\n\n电源相关函数\n-----------------------\n\n```python\nfreq()\n```\n 返回 CPU 频率,单位Hz\n\n```python\nidle()\n```\n为CPU提供时钟，有助于在短期或长期内随时降低功耗。一旦触发任何中断，外设继续工作并继续执行\n（在许多端口上，这包括以毫秒级的规则间隔发生的系统定时器中断）。\n\n```python\nsleep()\n```\n停止CPU并禁用除WLAN之外的所有外围设备。从请求睡眠的位置恢复执行。为了唤醒实际发生，应首先配置唤醒源。\n\n```python\ndeepsleep()\n```\n 停止CPU和所有外围设备（包括网络接口，如果有）。执行从主脚本恢复，就像重置一样。\n 可以检查重置原因以了解我来自哪里 :data:`machine.DEEPSLEEP` 。为了唤醒实际发生，应首先配置唤醒源，如 :class:`Pin` 更改或 :class:`RTC` 超时。\n\n\n```python\nwake_reason()\n```\n 得到唤醒原因。\n\n其他函数\n-----------------------\n\n```python\nrng()\n```\n 返回一个24 bit软件生成的随机数.\n\n```python\nunique_id()\n```\n 返回 board/ SoC的唯一标识符的字节字符串。如果底层硬件允许，它将从board/ SoC实例变化到另一个实例。\n 长度因硬件而异（如果您需要短ID，请使用完整值的子字符串）。在某些MicroPython端口中，ID对应于网络MAC地址。\n\n```python\ntime_pulse_us(pin, pulse_level, timeout_us=1000000)\n```\n 在给定的引脚上测试外部脉冲电平持续时间，并以微秒为单位返回外部脉冲电平的持续时间。 ``pulse_level`` =1测试高电平持续时间，pulse_level=0测试低电平持续时间。\n 当设置电平和现在脉冲的电平不一致时，则会等到输入电平和设置的电平一致时开始计时，如果设置的电平和现在脉冲的电平一致时，那么就会立即开始计时。\n 当引脚电平和设置电平一直相反时，则会等待超时，超时返回-2。当引脚电平和设置电平一直相同时，也会等待超时，超时返回-1， ``timeout_us`` 即为超时时间。\n\n常量\n---------\n\n```python\nmachine.IDLE\nmachine.SLEEP\nmachine.DEEPSLEEP\n```\nIRQ 唤醒值. \n\n```python\nmachine.PWRON_RESET\nmachine.HARD_RESET\nmachine.WDT_RESET\nmachine.DEEPSLEEP_RESET\nmachine.SOFT_RESET\n```\n重置原因.\n\n```python\nmachine.WLAN_WAKE\nmachine.PIN_WAKE\nmachine.RTC_WAKE\n```\n唤醒原因."}, "/WebBit_doc/zh/micropython/library/machine/machine.UART.html": {"title": "类 UART -- 双工串行通信总线", "content": "类 UART -- 双工串行通信总线\n=============================================\n\nUART实现标准UART / USART双工串行通信协议。在物理层面，它由2根线组成：RX和TX。\n通信单元是一个字符（不要与字符串混淆），可以是8bit或9bit宽。\n\n\n构建对象\n------------\n\n```python\nclass UART(id,baudrate, bits, parity, stop, tx, rx, rts, cts,timeout)\n```\n\n构造UART对象\n\n- ``id`` - 串口号:1、2  \n- ``baudrate`` - 波特率\n- ``bits``- 每个字符的位数\n- ``parity``- 奇偶校验:0-偶数,1-奇数\n- ``rx`` , ``tx`` - UART读、写引脚\n- ``stop`` - 停止位数量:1、2\n- ``timeout``- 超时时间（单位：毫秒） < timeout ≤ 0x7FFF FFFF (十进制：0 < timeout ≤ 2147483647)\n\n\n\n\n> ``UART(id=0)`` 用于REPL。\n> 所有引脚均可以作为串口的输入RX，除 ``P2``、``P3`` 、``P4`` 、``P10`` 只能作为输入，其余所有的引脚理论上都可以作为输出TX。\n> ``GPIO 1`` 、``GPIO 3`` 用于板子的USB串口，在初始化UART定义 ``tx`` ，``rx`` 引脚一般不使用，除非你要用到板子的USB接口作为串口输出。\n\n方法\n-------\n\n\n\n```python\nUART.init(baudrate, bits, parity, stop, tx, rx, rts, cts,timeout)\n```\n\n使用给定参数初始化UART总线\n\n\n```python\nUART.deinit()\n```\n\n关闭UART总线。\n\n```python\nUART.any()\n```\n\n返回一个整数，计算可以无阻塞地读取的字符数。如果没有可用字符，它将返回0，如果有字符，则返回正数。\n即使有多个可读的字符，该方法也可以返回1。\n\n要查询更复杂的可用字符，请使用`select.poll`:\n```python\npoll = select.poll()\npoll.register(uart, select.POLLIN)\npoll.poll(timeout)\n```\n\n```python\nUART.read([nbytes])\n```\n\n读字符。如果 ``nbytes`` 指定，则最多读取多个字节，否则读取尽可能多的数据。\n\n返回值：包含读入的字节的字节对象。 ``None`` 超时时返回。\n\n```python\nUART.readinto(buf[, nbytes])\n```\n\n将字节读入 ``buf`` 。如果 ``nbytes`` 指定，则最多读取多个字节。否则，最多读取 ``len(buf)`` 字节数。\n\n返回值：读取和存储到超时 ``buf`` 或 ``None`` 超时的字节数。\n\n```python\nUART.readline()\n```\n\n读一行，以换行符结尾。\n\n返回值：读取行或 ``None`` 超时。\n\n```python\nUART.write(buf)\n```\n\n将字节缓冲区写入总线。\n\n返回值：写入或 ``None`` 超时的字节数。"}, "/WebBit_doc/zh/micropython/library/machine/machine.PWM.html": {"title": "类 PWM -- 脉冲宽度调制", "content": "类 PWM -- 脉冲宽度调制\n=============================\n\n脉冲宽度调制（PWM）是一种通过数字方式获取模拟结果的技术。\n\n\n构建对象\n------------\n\n```python\nclass PWM(pin, freq, duty)\n```\n\n创建与设定引脚关联的PWM对象。这样您就可以写该引脚上的模拟值。\n\n- ``pin`` 支持PWM的引脚  ``GPIO0``、``GPIO2``、``GPIO4``、``GPIO5``、``GPIO10``、``GPIO12~19``、``GPIO21``、``GPIO22``、``GPIO23``、``GPIO25~27``。有关更多信息，请查看[ESP32 系列芯片技术规格书](https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_cn.pdf) 中有关ESP32引脚功能的内容。\n- ``freq`` 频率,0 < freq <= 78125\n- ``duty``  占空比, 0 ≤ duty ≤ 0x03FF (十进制：0 ≤ duty ≤ 1023)\n\n> 限制条件是它们必须处于相同的频率。\n\n示例:\n\n```python\nfrom machine import PWM, Pin\n\npwm = PWM (Pin(2), freq=1000,  duty=1023)    # create an PWM object\n```\n\n方法\n------------\n\n```python\nPWM.init(freq, duty)\n```\n\n初始化PWM，freq、duty如上所述。    \n\n\n示例:\n\n```python\npwm.init(1000, 500)\n```\n\n```python\nPWM.freq([freq_val])\n```\n\n当没有参数时，函数获得并返回PWM频率。当设置参数时，函数用来设置PWM频率，无返回值。\n\n- ``freq_val`` PWM波频率,0 < freq ≤ 0x0001312D（十进制：0 < freq ≤ 78125）\n\n示例:\n\n```python\nprint(pwm.freq())\nprint(pwm.freq(2000)\n```\n\n```python\nPWM.duty([duty_val])\n```\n\n没有参数时，函数获得并返回PWM占空比。有参数时，函数用来设置PWM占空比。\n\n- ``duty_val`` 占空比, 0 ≤ duty ≤ 0x03FF（十进制：0 ≤ duty_val ≤ 1023）\n\n示例:\n```\n >>> print(pwm.duty())\n 50\n >>> print(pwm.duty(500))\n None\n```\n\n```python\nPWM.deinit( )\n```\n\n关闭PWM。"}, "/WebBit_doc/zh/micropython/library/machine/machine.WDT.html": {"title": "类 WDT -- 看门狗定时器", "content": "类 WDT -- 看门狗定时器\n===========================\n\n当程序崩溃并最终进入不可恢复状态时，WDT用于重新启动系统。一旦启动，就无法以任何方式停止或重新配置。\n启用后，程序必须定期 ``喂狗`` ，以防止它过期和重置系统。\n\n示例:\n\n```python\nfrom machine import WDT\nwdt = WDT()        # enable it with a wdt\nwdt.feed()\n```\n\n构建对象\n------------\n\n```python\nclass WDT()\n```\n\n创建一个WDT对象并启动它。\n\n方法\n-------\n\n```python\nwdt.feed()\n```\n\n对WDT喂狗以防止它重置系统。程序应该将此调用放置在一个合理的位置，以确保在验证所有操作都正确之后才会对WDT进行喂狗。"}, "/WebBit_doc/zh/micropython/library/machine/machine.TouchPad.html": {"title": "类 TouchPad -- 触摸", "content": "类 TouchPad -- 触摸\n=============================\n\n\n构建对象\n------------\n\n```python\nclass TouchPad(Pin)\n```\n\n创建与设定引脚关联的TouchPad对象。\n\n- ``Pin`` 可用引脚有：``GPIO4``、``GPIO0``、``GPIO2``、``GPIO15``、``GPIO13``、``GPIO12``、``GPIO14``、``GPIO27``、``GPIO33``、``GPIO32``。有关更多信息，请查看[ESP32 系列芯片技术规格书](https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_cn.pdf) 中有关ESP32引脚功能的内容。\n \n\n示例:\n\n```python\nfrom machine import TouchPad, Pin\n\ntp = TouchPad(Pin(14))\n```\n\n``TouchPad.read`` 返回相对于电容性变量的值。当触摸时，是个较小数字(通常在 *10* 内)，当没有触针时，是较大数字(大于 * 1000 *)是常见的。然而，这些值是“相对的”，可以根据电路板和周围不同而变化，因此可能的需要进行一些校准。\n\n有10个电容触摸控脚,如果调用其他的引脚将会导致 ``ValueError`` 。\n\n方法\n---------\n\n```python\nTouchPad.read()\n```\n\n读取TouchPad的电平。\n\n```python\nTouchPad.config(value)\n```\n\n设置触摸的阈值\n\n- ``value`` 整数"}, "/WebBit_doc/zh/micropython/library/machine/machine.SPI.html": {"title": "类 SPI -- 串行外设接口总线协议 (主端)", "content": "类 SPI -- 串行外设接口总线协议 (主端)\n=====================================================================\n\nSPI是由主设备驱动的同步串行协议。在物理层面，总线由3条线组成：SCK，MOSI，MISO。\n多个设备可以共享同一总线。每个设备都应有一个单独的第4个信号SS（从选择），用于选择与之进行通信的总线上的特定设备。\nSS信号的管理应该在用户代码中进行（通过  `Pin` ）。\n\n构建对象\n------------\n\n```python\nclass SPI(id, ...)\n```\n\n在给定总线上构造SPI对象，``id`` 值依赖于特定的端口及其硬件。\n值0是、1等通常用于选择硬件SPI块#0、#1等。值是-1可以用于SPI的bitsmashing(软件)实现(如果由一个端口支持的话)。\n\n如果没有其他参数，则会创建SPI对象但不进行初始化（它具有上次初始化总线的设置，如果有的话）。\n如果给出额外的参数，则初始化总线。请参阅 ``init`` 初始化参数。\n\n方法\n-------\n\n```python\nSPI.init(baudrate=1000000, \\*, polarity=0, phase=0, bits=8, firstbit=SPI.MSB, sck=None, mosi=None, miso=None, pins=(SCK, MOSI, MISO))\n```\n\n使用给定参数初始化SPI总线：\n\n- ``baudrate`` SCK时钟频率。\n- ``polarity`` 0或1，空闲时钟线所在的电平。\n- ``phase`` 0或1来分别在第一或第二时钟边沿上采样数据。\n- ``bits`` 每次传输的宽度（以位为单位）。所有硬件都保证只支持8个。\n- ``firstbit`` 可以是  ``SPI.MSB`` 或 ``SPI.LSB``.\n- ``sck``, ``mosi``, ``miso`` 是 pins (machine.Pin) 对象以用于总线信号。对于大多数硬件SPI块（由 ``id`` 构建对象的参数选择），引脚是固定的，不能更改。在某些情况下，硬件模块允许2-3个替代引脚组用于硬件SPI模块。任意引脚分配仅适用于bitbanging SPI驱动程序（ ``id`` = -1）。\n- ``pins`` -  esp32没有 ``sck`` ， ``mosi`` ， ``miso`` 参数，而是允许指定它们作为一个元组 ``pins`` 参数。\n\n```python\nSPI.deinit()\n```\n\n关闭SPI总线。\n\n```python\nSPI.read(nbytes, write=0x00)\n```\n\n读取指定的字节数， ``nbytes`` 同时连续写入由给定的单字节 ``write`` 。返回包含 ``bytes`` 已读取数据的对象。\n\n```python\nSPI.readinto(buf, write=0x00)\n```\n\n读入 ``buf`` 指定的缓冲区，同时不断写入由 ``write`` 给出的单字节。\n\n返回 ``None``。\n\n注意：在 ``esp32`` 上，此函数返回读取的字节数。\n\n\n```python\nSPI.write(buf)\n```\n\n写入`` buf`` 中的字节。\n\n返回 ``None``。\n\n注意：在 ``esp32`` 上，此函数返回写入的字节数。\n\n```python\nSPI.write_readinto(write_buf, read_buf)\n```\n\n从 ``write_buf`` 中写入字节，同时读入 ``read_buf`` 中。缓冲区可以是相同的，也可以是不同的，但是两个缓冲区都必须具有\n长度相同。\n\n返回 ``None``。\n\n注意：在 ``esp32`` 上，此函数返回写入的字节数。\n\n常数\n---------\n\n```python\nclass SPI.MASTER\n```\n\n用于初始化SPI总线到主机; 这仅用于 ``esp32``。\n\n```python\nclass SPI.MSB\n```\n\n将第一位设置为最高位。\n\n```python\nclass SPI.LSB\n```\n\n将第一个位设置为最低位。"}, "/WebBit_doc/zh/micropython/library/machine/machine.I2C.html": {"title": "类 I2C --  双线串行协议", "content": "类 I2C --  双线串行协议\n=======================================\n\nI2C是用于设备之间通信的双线协议。在物理层面，它由2条线组成：SCL和SDA，分别是时钟和数据线。\n\n创建连接到特定总线的I2C对象。它们可以在创建时初始化，也可以在以后初始化。\n\n示例:\n\n```python\nfrom machine import I2C,Pin\n\ni2c = I2C(scl=Pin(22), sda=Pin(23), freq=400000) # create I2C peripheral at frequency of 400kHz\n# depending on the port, extra parameters may be required\n# to select the peripheral and/or pins to use\n\ni2c.scan()  # scan for slaves, returning a list of 7-bit addresses\n\ni2c.writeto(42, b'123') # write 3 bytes to slave with 7-bit address 42\ni2c.readfrom(42, 4)  # read 4 bytes from slave with 7-bit address 42\n\ni2c.readfrom_mem(42, 8, 3) # read 3 bytes from memory of slave 42,\n#   starting at memory-address 8 in the slave\ni2c.writeto_mem(42, 2, b'\\x10') # write 1 byte to memory of slave 42\n#   starting at address 2 in the slave\n```\n\n构建对象\n------------\n\n```python\nclass I2C(id=-1, \\*, scl, sda, freq=400000)\n```\n\n   使用以下参数构造并返回新的I2C对象：\n\n\n\n- ``id`` 标识特定的I2C外设。默认值-1选择I2C的软件实现\n- ``scl`` 应该是一个pin对象，指定用于SCL的引脚\n- ``sda`` 应该是一个pin对象，指定用于SDA的引脚\n- ``freq`` 应该是一个整数，它设置SCL的最大频率。0 < freq ≤ 500000(Hz)。\n\n> I2C可使用引脚有GPIO 0/2/4/5/9/16/17/18/19/21/22/23/25/26/27\n\nGeneral Methods\n---------------\n\n```python\nI2C.init(scl, sda, \\*, freq=400000)\n```\n\nInitialise the I2C bus with the given arguments:\n\n- ``scl`` 是SCL线的pin对象\n- ``sda`` 是SDA线的pin对象\n- ``freq`` 是SCL时钟速率\n\n```python\nI2C.deinit()\n```\n\n   关闭I2C总线。\n\n```python\nI2C.scan()\n```\n\n 扫描0x08和0x77之间的所有I2C地址，并返回响应的列表。如果在总线上发送其地址（包括写入位）后将器件拉低，则器件会响应。\n\nPrimitive I2C operations\n------------------------\n\n以下方法实现Primitive I2C operations主总线操作，并且可以组合以进行任何I2C事务。如果您需要更多控制总线，则提供它们，\n否则可以使用标准方法（见下文）。\n\n```python\nI2C.start()\n```\n\n   在总线上生成START条件（SDA在SCL为高电平时转换为低电平）。\n\n```python\nI2C.stop()\n```\n\n在总线上生成STOP条件（SDA在SCL为高电平时转换为高电平）。\n\n```python\nI2C.readinto(buf, nack=True)\n```\n\n从总线读取字节并将它们存储到 ``buf`` 中。读取的字节数是 ``buf`` 的长度。在接收到除最后一个字节之外的所有字节之后，\n将在总线上发送 ``ACK`` 。在接收到最后一个字节之后，如果 ``nack``  为真，则将发送 ``NACK``，否则将发送  ``ACK`` （并且在这种情况下，从属设备假定在稍后的调用中将读取更多字节）。\n\n\n```python\nI2C.write(buf)\n```\n\n将 ``buf`` 中的字节写入总线。检查每个字节后是否收到 ``ACK`` ，如果收到 ``NACK`` ，则停止发送剩余的字节。该函数返回已接收的 ``ACK`` 数。\n\n\nStandard bus operations\n-----------------------\n\n下面的方法实现了针对给定从设备的标准I2C主读写操作。\n\n```python\nI2C.readfrom(addr, nbytes, stop=True)\n```\n\n从 ``addr`` 指定的从程序中读取 ``nbytes`` 。如果  ``stop`` 为真，则在传输结束时生成一个停止条件。返回一个读取数据的 ``bytes`` 对象。\n\n```python\nI2C.readfrom_into(addr, buf, stop=True)\n```\n\n从 ``addr`` 指定的奴隶读入 ``buf`` 。读取的字节数将是 ``buf`` 的长度。如果 ``stop`` 为真，则在传输结束时生成一个停止条件。\n\n该方法返回 ``None`` 。\n  \n\n```python\nI2C.writeto(addr, buf, stop=True)\n```\n\n将 ``buf`` 中的字节写入 ``addr`` 指定的从机。如果在从 ``buf`` 写入一个字节后收到 NACK  ，则不发送剩余的字节。\n如果 ``stop`` 为true，则即使收到NACK，也会在传输结束时生成STOP条件。该函数返回已接收的ACK数。\n\n\n寄存器操作\n-----------------\n\n某些I2C器件充当可以读写的存储器器件（或寄存器集）。在这种情况下，有两个与I2C事务相关的地址：从地址和存储器地址。\n以下方法是与这些设备通信的便利功能。\n\n```python\nI2C.readfrom_mem(addr, memaddr, nbytes, \\*, addrsize=8)\n```\n\n从 ``memaddr`` 指定的内存地址开始，从 ``addr`` 指定的slave中读取 ``nbytes`` 。参数 ``addrsize`` 以位为单位指定地址大小。\n返回读取数据的 ``bytes`` 对象。\n\n```python\nI2C.readfrom_mem_into(addr, memaddr, buf, \\*, addrsize=8)\n```\n\n从 ``memaddr`` 指定的内存地址开始，从 ``addr`` 指定的slave中读入 ``buf`` 。读取的字节数是 ``buf`` 的长度。\n参数 ``addrsize`` 以位为单位指定地址大小。\n\n该方法返回 ``None`` 。\n\n```python\nI2C.writeto_mem(addr, memaddr, buf, \\*, addrsize=8)\n```\n\n从 ``memaddr`` 指定的内存地址开始，将 ``buf`` 写入 ``addr`` 指定的从机。参数 ``addrsize`` 以位的形式指定地址大小。\n\n该方法返回 ``None`` 。"}, "/WebBit_doc/zh/micropython/library/machine/machine.Timer.html": {"title": "类 Timer -- 控制硬件定时器", "content": "类 Timer -- 控制硬件定时器\n======================================\n\n硬件定时器处理周期和事件的时间。定时器可能是MCU和SoC中最灵活和异构的硬件类型，从一个模型到另一个模型的差别很大。\nMicroPython的Timer类定义了在给定时间段内（或在一段延迟后执行一次回调）执行回调的基线操作，并允许特定的板定义更多的非标准行为（因此不能移植到其他板）。\n\n> 内存不能在irq处理程序（中断）中分配，因此处理程序中引发的异常不会提供太多信息。\n\n构建对象\n------------\n\n```python\nclass Timer(id, ...)\n```\n\n构造给定id的新计时器对象。Id为-1构造虚拟计时器。\n\n方法\n-------\n\n```python\nTimer.init(\\*, mode=Timer.PERIODIC, period=-1, callback=None)\n```\n\n初始化计时器，示例:\n\n```python\ntimer.init(period=100)     # periodic with 100ms period\ntimer.init(mode=Timer.ONE_SHOT, period=1000)   # one shot firing after 1000ms\n```\n\n关键参数:\n\n- ``mode`` 可以是以下之一:\n  - ``Timer.ONE_SHOT`` - 计时器运行一次，直到配置完毕通道的期限到期。\n  - ``Timer.PERIODIC`` - 定时器以通道的配置频率定期运行。\n\n```python\nTimer.value()\n```\n\n获取并返回计时器当前计数值。 \n\n示例:\n\n```python\nvalue = timer.value()\nprint(value)\n```\n\n```python\nTimer.deinit()\n```\n\n取消定时器的初始化。停止计时器，并禁用计时器外围设备。\n\n常数\n---------\n\n```python\nTimer.ONE_SHOT\nTimer.PERIODIC\n```"}, "/WebBit_doc/zh/micropython/library/machine/machine.ADC.html": {"title": "类 ADC -- 模数转换", "content": "类 ADC -- 模数转换\n=========================================\n\n构建对象\n------------\n\n```python\nclassADC(Pin)\n```\n创建与设定引脚关联的ADC对象。这样您就可以读取该引脚上的模拟值。\n\n- ``Pin``  ADC在专用引脚上可用，ESP32可用引脚有： ``GPIO36`` / ``ADC1_CH0`` 、``GPIO39`` / ``ADC1_CH3`` 、``GPIO34``/``ADC1_CH6``、``GPIO35``/``ADC1_CH7``、``GPIO32``/``ADC1_CH4``、``GPIO33``/``ADC1_CH5``，可测电压范围为0~3.3V。有关更多信息，请查看[ESP32 系列芯片技术规格书](https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_cn.pdf) 中有关ESP32引脚功能的内容。\n\n示例:\n\n```python\nfrom machine import ADC, Pin\n\nadc = ADC(Pin(33))     # create an ADC object\n```\n\n方法\n-------\n\n```python\nADC.read( )\n```\n\n读取ADC并返回读取结果，返回的值将在0到4095之间。\n\n\n\n\n```python\nADC.atten(db)\n```\n\n 设置衰减比（即满量程的电压，比如11db满量程时电压为3.3V）,默认为``ADC.ATTIN_0DB``。\n\n- ``db``：衰减比, ``ADC.ATTIN_0DB`` 、``ADC.ATTN_2_5_DB``、``ADC.ATTN_6DB``、``ADC.ATTN_11DB``\n\n\n```python\nADC.width(bit)\n```\n\n 设置数据宽度\n\n- ``bit``： ``ADC.WIDTH_9BIT`` 、 ``ADC.WIDTH_10BIT`` 、 ``ADC.WIDTH_11BIT`` 、 ``ADC.WIDTH_12BIT``\n\n\n\n示例:\n\n```python\nfrom machine import ADC, Pin\n\nadc = ADC(Pin(34))     # create an ADC object\nadc.atten(adc.ATTN_11DB)   # set 3.3V Range\nx = adc.read()\nprint(x)\n```\n\n常量\n---------\n\n\n衰减比\n\n```python\nADC.ATTN_0DB\n```\n\n等于0,满量程：1.2v\n\n```python\nADC.ATTN_2_5DB\n```\n\n等于1,满量程：1.5v\n\n```python\nADC.ATTN_6DB\n```\n\n等于2,满量程：2.0v\n\n```python\nADC.ATTN_11DB\n```\n\n等于3,满量程：3.3v\n\n\n数据宽度\n\n```python\nADC.WIDTH_9BIT\n```\n\n等于0，9位数据宽度， 即满量程0x1ff(511)\n\n```python\nADC.WIDTH_10BIT\n```\n\n等于1，10位数据宽度， 即满量程0x7ff(2047)\n\n```python\nADC.WIDTH_11BIT\n```\n\n等于2，11位数据宽度， 即满量程0x3ff(1023)\n\n```python\nADC.WIDTH_12BIT\n```\n\n等于3，12位数据宽度， 即满量程0xfff(4095)"}, "/WebBit_doc/zh/micropython/library/machine/machine.Pin.html": {"title": "类 Pin -- 控制 I/O 引脚", "content": "类 Pin -- 控制 I/O 引脚\n=============================\n\n引脚对象用于控制I / O引脚（也称为GPIO - 通用输入/输出）。引脚对象通常与可以驱动输出电压和读取输入电压的物理引脚相关联。\n引脚类具有设置引脚模式（IN，OUT等）的方法以及获取和设置数字逻辑电平的方法。有关引脚的模拟控制, 请参阅 :class:`ADC` 类.\n\n通过使用明确指定某个I / O引脚的标识符来构造引脚对象。允许的标识符形式和标识符映射到的物理引脚是特定于端口的。\n标识符的可能性是整数，字符串或具有端口和引脚号的元组。\n\n示例:\n\n```python\nfrom machine import Pin\n\n# create an output pin on pin #32\np0 = Pin(32, Pin.OUT)\n\n# set the value low then high\np0.value(0)\np0.value(1)\n\n# create an input pin on pin #33, with a pull up resistor\np2 = Pin(33, Pin.IN, Pin.PULL_UP)\n\n\n# configure an irq callback\np2.irq(trigger=Pin.IRQ_FALLING, handler=lambda t:print(\"IRQ\"))\n```\n\n构建对象\n------------\n\n```python\nclass Pin(id, mode=1, pull=1, value, drive, alt)\n```\n访问与给定相关的引脚外设（GPIO引脚） ``id`` 。如果在构建对象中给出了其他参数，则它们用于初始化引脚。\n未指定的任何设置将保持其先前的状态。\n\n> MicroPython 板子提供自有的引脚映射,将引脚映射为ESP32的GPIO。\n\n参数:\n\n- ``id`` 是强制性的，可以是任意对象。可能的值类型包括：int（内部引脚标识符），str（引脚名称）和元组（[port，pin]对）。如是使用MicroPython,可用Pin.P(0~20),例如(Pin.P0)P0引脚提供映射为GPIO。\n\n- ``mode`` 指定引脚模式，可以是以下之一：\n\n  - ``Pin.IN`` - 引脚配置为输入。如果将其视为输出，则引脚处于高阻态。\n\n  - ``Pin.OUT`` - 引脚配置为（正常）输出。\n\n  - ``Pin.OPEN_DRAIN`` -引脚配置为开漏输出。开漏输出以下列方式工作：如果输出值设置为0，则引脚处于低电平有效; 如果输出值为1，则引脚处于高阻态。并非所有端口都实现此模式，或某些端口可能仅在某些引脚上实现。\n\n\n  - ``Pin.ALT`` - 引脚配置为执行替代功能，该功能是端口特定的。对于以这种方式配置的引脚，任何其他Pin方法（除外 `Pin.init` ）都不适用\n（调用它们将导致未定义或特定于硬件的结果）。并非所有端口都实现此模式。\n\n\n  - ``Pin.ALT_OPEN_DRAIN`` - 和 ``Pin.ALT`` 相同，但引脚配置为漏极开路。并非所有端口都实现此模式。\n\n- ``pull`` 指定引脚是否连接了（弱）拉电阻，可以是以下之一：\n\n  - ``None`` - 无上拉或下拉电阻\n  - ``Pin.PULL_UP`` - 上拉电阻使能\n  - ``Pin.PULL_DOWN`` - 下拉电阻使能\n\n- ``value`` 仅对Pin.OUT和Pin.OPEN_DRAIN模式有效，并指定初始输出引脚值，否则引脚外设的状态保持不变。\n\n- ``drive`` 指定引脚的输出功率，可以是：Pin.LOW_POWER， Pin.MED_POWER或Pin.HIGH_POWER。实际的电流驱动能力取决于端口。并非所有端口都实现此参数。\n\n- ``alt`` 指定引脚的复用功能，它可以采用的值取决于端口。此参数仅对Pin.ALT和Pin.ALT_OPEN_DRAIN 模式有效。当引脚支持多个复用功能时，可以使用它。如果仅支持一个引脚复用功能，则不需要此参数。并非所有端口都实现此参数。\n\n\n如上所述，Pin类允许为特定引脚设置复用功能，但它不在此类引脚上指定任何进一步的操作。\n在复用功能模式下配置的引脚通常不用作GPIO，而是由其他硬件外设驱动。\n这种引脚支持的唯一操作是通过调用构建对象或 `Pin.init` 方法重新初始化。\n如果引脚在复用功能模式下配置 ``Pin.IN`` ， ``Pin.OUT`` 或者``Pin.OPEN_DRAIN`` 将重新初始化，复用功能将从pin中删除。\n\n方法\n-------\n\n```python\nPin.init(mode=1, pull=1, value, drive, alt)\n```\n使用给定参数重新初始化引脚。只会设置指定的参数。引脚外围状态的其余部分将保持不变。\n有关参数的详细信息，请参阅构建对象文档。\n\n 返回 ``None``.\n\n\n```python\nPin.value([x])\n```\n此方法允许设置和获取引脚的值，具体取决于是否 ``x`` 提供参数。\n\n如果省略该参数，则该方法获得引脚的数字逻辑电平，分别返回对应于低电压信号和高电压信号的0或1。\n此方法的行为取决于引脚的模式：\n\n- ``Pin.IN`` -该方法返回引脚上当前存在的实际输入值.\n- ``Pin.OUT`` - 该方法的行为和返回值未定义.\n- ``Pin.OPEN_DRAIN`` - 如果引脚处于状态“0”，则方法的行为和返回值未定义。否则，如果引脚处于状态“1”，则该方法返回引脚上当前存在的实际输入值。.\n\n如果提供了参数，则此方法设置引脚的数字逻辑电平。参数x可以是转换为布尔值的任意值。\n如果转换为True，则将引脚设置为状态“1”，否则将其设置为“0”状态。此方法的行为取决于引脚的模式：\n\n\n\n - ``Pin.IN`` - 该值存储在引脚的输出缓冲区中。引脚状态不会改变，它仍然处于高阻态。一旦更改为 ``Pin.OUT`` 或 ``Pin.OPEN_DRAIN`` 模式，存储的值将在引脚上激活。\n - ``Pin.OUT`` -输出缓冲区立即设置为给定值。\n - ``Pin.OPEN_DRAIN`` - 如果值为“0”，则引脚设置为低电压状态。否则，引脚被设置为高阻态。\n\n 设置此方法返回的值时 ``None``.\n\n```python\nPin.on()\n```\n 设置引脚为高电平\n\n```python\nPin.off()\n```\n 设置引脚为低电平\n\n```python\nPin.irq(handler=None, trigger=(Pin.IRQ_FALLING | Pin.IRQ_RISING))\n```\n配置在引脚的触发源处于活动状态时调用的中断处理程序。如果引脚模式是， ``Pin.IN`` 则触发源是引脚上的外部值。\n如果引脚模式是， ``Pin.OUT`` 则触发源是引脚的输出缓冲器。\n否则，如果引脚模式是， ``Pin.OPEN_DRAIN`` 那么触发源是状态'0'的输出缓冲器和状态'1'的外部引脚值。\n\n参数:\n\n- ``handler`` 是一个可选的函数，在中断触发时调用。\n\n- ``trigger`` 配置可以触发中断的事件。可能的值是：\n\n  - ``Pin.IRQ_FALLING`` 下降沿中断\n  - ``Pin.IRQ_RISING`` 上升沿中断\n  - ``Pin.IRQ_LOW_LEVEL`` 低电平中断\n  - ``Pin.IRQ_HIGH_LEVEL`` 高电平中断\n\n这些值可以一起进行 ``OR`` 运算以触发多个事件。\n\n\n此方法返回一个回调对象。\n\n常量\n---------\n\n板子自有的引脚映射,将板子引脚因为为ESP32的GPIO\n\n```python\nPin.P0\nPin.P1\nPin.P2\nPin.P3\nPin.P4\nPin.P5\nPin.P6\nPin.P7\nPin.P8\nPin.P9\nPin.P10\nPin.P11\nPin.P13\nPin.P14\nPin.P15\nPin.P16\nPin.P19\nPin.P20\nPin.P23\nPin.P24\nPin.P25\nPin.P26\nPin.P27\nPin.P28\n```\n\n以下常量用于配置引脚对象。\n\n```python\nPin.IN\nPin.OUT\nPin.OPEN_DRAIN\nPin.ALT\nPin.ALT_OPEN_DRAIN\n```\n\n选择引脚模式。\n\n```python\nPin.PULL_UP\nPin.PULL_DOWN\n```\n\n 选择是否有上拉/下拉电阻。使用None无拉的值 。\n ``None`` for no pull.\n\n```python\nPin.LOW_POWER\nPin.MED_POWER\nPin.HIGH_POWER\n```\n 选择引脚驱动强度。\n\n```python\nPin.IRQ_FALLING\nPin.IRQ_RISING\nPin.IRQ_LOW_LEVEL\nPin.IRQ_HIGH_LEVEL\n```\n选择IRQ触发类型。"}, "/WebBit_doc/zh/micropython/library/random.html": {"title": "random - 生成随机数", "content": "random - 生成随机数\n=========================================\n\n该模块基于Python标准库中的 ``random`` 模块。它包含用于生成随机数的函数。\n\n函数\n---------\n\n```python\nrandom.randint(start, end)\n```\n\n随机生成一个start到end之间的整数。\n\n- ``start``:指定范围内的开始值，包含在范围内。\n- ``stop``：指定范围内的结束值，包含在范围内。\n\n示例:\n\n```\n>>> import random\n>>> print(random.randint(1, 4))\n4\n>>> print(random.randint(1, 4))\n2\n```\n\n```python\nrandom.random()\n```\n\n随机生成一个0到1之间的浮点数。 \n\n示例:\n\n```\n>>> print(random.random())\n0.7111824\n>>> print(random.random())\n0.3168149\n```\n\n```python\nrandom.unifrom(start, end)\n```\n\n随机生成start到end之间的浮点数。\n\n- ``start``：指定范围内的开始值，包含在范围内。\n- ``stop``：指定范围内的结束值，包含在范围内。\n\n示例:\n\n```\n>>> print(random.uniform(2, 4))\n2.021441\n>>> print(random.uniform(2, 4))\n3.998012\n```\n\n```python\nrandom.getrandbits(size)\n```\n\n随机生成 0 到 size 个位二进制数范围内的正整数。 \n\n- ``size`` :位大小。例如，size = 4，那么便是从 0 到0b1111中随机一个正整数；size = 8，那么便是从 0 到 0b11111111中随机一个正整数。\n\n示例:\n\n```\n>>> print( random.getrandbits(1))#1位二进制位，范围为0~1（十进制：0~1）\n1\n>>> print(random.getrandbits(1))\n0\n>>> print(random.getrandbits(8))#8位二进制位，范围为0000 0000~1111 11111（十进制：0~255）\n224\n>>> print(random.getrandbits(8))\n155\n```\n\n```python\nrandom.randrange(start, end, step)\n```\n\n随机生成start到end并且递增为 step 的范围内的正整数。例如，randrange(0, 8, 2)中，随机生成的数为0、2、4、6中任一个。\n\n- ``start``：指定范围内的开始值，包含在范围内\n- ``stop``：指定范围内的结束值，包含在范围内\n- ``step``：递增基数\n\n示例:\n\n```\n>>> print(random.randrange(2, 8, 2))\n4\n>>> print(random.randrange(2, 8, 2))\n6\n>>> print(random.randrange(2, 8, 2))\n2\n```\n\n```python\nrandom.seed(sed)\n```\n\n指定随机数种子，通常和其他随机数生成函数搭配使用。\n\n> MicroPython中的随机数其实是一个稳定算法得出的稳定结果序列，而不是一个随机序列。\n> seed就是这个算法开始计算的第一个值。所以就会出现只要seed是一样的，那么后续所有“随机”结果和顺序也都完全一致。\n\n示例:\n\n```python\nimport random\n\nfor j in range(0, 2):\n  random.seed(13)  #指定随机数种子\n  for i in range(0, 10):  #生成0到10范围内的随机序列\n    print(random.randint(1, 10))\n  print(\"end\")\n```\n\n运行结果:\n\n```\n5\n2\n3\n2\n3\n4\n2\n5\n8\n2\nend\n5\n2\n3\n2\n3\n4\n2\n5\n8\n2\nend\n```\n\n从上面可以看到生成两个随机数列表是一样的，你也可以多生成几个随机数列表看看。\n另外当我不用seed(sed)函数时，相当于没有指定随机种子，这样就是随机生成的。\n\n```python\nrandom.choice(obj)\n```\n\n函数说明：随机生成对象obj中的元数。\n\n- ``obj``：元数列表\n\n示例:\n\n```\n>>> print(random.choice(\"MicroPython\"))\nm\n>>> print(random.choice(\"MicroPython\"))\nn\n>>> print(random.choice([0, 2, 4, 3]))\n3\n>>> print(random.choice([0, 2, 4, 3]))\n3\n>>> print(random.choice([0, 2, 4, 3]))\n2\n```"}, "/WebBit_doc/zh/micropython/library/neopixel.html": {"title": "neopixel - WS2812 灯带", "content": "neopixel - WS2812 灯带\n=========================================\n\nNeoPixels也被称为WS2812 LED彩带，是连接在一起的全彩色led灯串。你可以设置他它们的红色，绿色和蓝色值，\n在0到255之间。neopixel模块可通过精确的时间控制，生成WS2812控制信号。\n\n构建对象\n------------\n\n```python\nclass NeoPixel(pin, n,bpp=3,timing=0)\n```\n\n- ``pin`` :输出引脚,可使用引脚见下文\n-  ``n`` :LED灯的个数\n- ``bpp``:\n\n  - ``3``:默认为3元组RGB\n  - ``4``:对于具有3种以上颜色的LED，例如RGBW像素或RGBY像素,采用4元组RGBY或RGBY像素\n\n- ``timing``:默认等于0,为400KHz速率；等于1，为800KHz速率\n\n> NeoPixel可使用的pin引脚有板子的P5,P6,P7(板上RGB),P8,P9,P11,P13,P14,P15,P16,P19,P20。\n\n\n示例:\n\n```python\nfrom machine import Pin\nimport neopixel\n\npin = Pin(17, Pin.OUT)\nnp = neopixel.NeoPixel(pin, n=3,bpp=3,timing=1)   #800khz\n```\n\n方法\n-------\n\n```python\nNeoPixel.write()\n```\n\n把数据写入LED中。 \n\n示例:\n\n```python\nnp[0] = (255, 255, 255) # 设置第一个LED像素为白色\nnp.write()\n```\n\n```python\nNeoPixel.fill(rgb_buf)\n```\n\n填充所有LED像素。\n\n- ``rgb_buf`` :rgb颜色\n\n示例:\n\n```python\nnp.fill( (255, 255, 255) )\n```"}, "/WebBit_doc/zh/micropython/library/ntptime.html": {"title": "ntptime - 时间同步", "content": "ntptime - 时间同步\n=========================================\n\n该模块用于时间同步,提供准确时间，国际标准时间(UTC)。\n\n> **什么是NTP**\n> Network Time Protocol（NTP）是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源（如石英钟，GPS等等)做同步化。它可以提供高精准度的时间校正。\n\n方法\n------\n\n\n```python\nsettime(timezone=8,server = 'ntp.ntsc.ac.cn')\n```\n\n同步本地时间\n\n- ``timezone`` - 时区时间差,默认为东八区,补偿8小时\n- ``server``  -  可自行指定授时服务器,server为字符串类型。默认授时服务器为\"ntp.ntsc.ac.cn\"。\n\n\n示例:\n\n```python\nfrom MicroPython import *\nimport ntptime\n\nmywifi=wifi()\nmywifi.connectWiFi('tang','tang123456')   \n\nprint(\"同步前本地时间：%s\" %str(time.localtime()))\nntptime.settime()\nprint(\"同步后本地时间：%s\" %str(time.localtime()))\n```\n运行结果:\n\n```\nConnecting to network...\nWiFi Connection Successful,Network Config:('172.20.10.4', '255.255.255.240', '172.20.10.1', '172.20.10.1')\n同步前本地时间：(2000, 1, 1, 0, 40, 8, 5, 1)\n同步后本地时间：(2018, 12, 27, 12, 10, 7, 3, 361)\nMicroPython v1.0.1-dirty on 2018-11-23; MicroPython with ESP32\nType \"help()\" for more information.\n>>>\n```"}, "/WebBit_doc/zh/micropython/library/index.html": {"title": "MicroPython 类库", "content": "MicroPython 类库\n===============\n\n以下库中提供了特定于 MicroPython-ESP32 实现的功能。\n\n\n- btree – 简单的 BTree 数据库\n- framebuf — 帧缓冲操作\n- machine — 与硬件相关的功能\n- network — 网络配置\n- uctypes – 以结构化方式访问二进制数据\n- micropython – 访问和控制MicroPython内部\n- neopixel — WS2812 灯带\n- random — 生成随机数\n- ntptime — 时间同步\n- dht — dht模块\n- _thread — 线程"}, "/WebBit_doc/zh/micropython/library/_thread.html": {"title": "_thread - 线程", "content": "_thread - 线程\n==========================\n\n该模块提供了用于处理多个线程（也称为轻量级进程或任务）的低级原语 - 多个控制线程共享其全局数据空间。为\n了同步，提供了简单的锁（也称为互斥锁或二进制信号量）。\n\n发生线程特定错误时，会RuntimeError引发异常。\n\n快速使用示例:\n\n```python\nimport _thread\nimport time\n\ndef th_func(delay, id):\n   while True:\n      time.sleep(delay)\n      print('Running thread %d' % id)\n\nfor i in range(2):\n   _thread.start_new_thread(th_func, (i + 1, i))\n```\n\n## 方法\n\n\n```python\n_thread.start_new_thread（function，args [，kwargs]）\n```\n\n启动一个新线程并返回其标识符。线程使用参数列表args（必须是元组）执行函数。可选kwargs参数指定关键字参数的字典。\n当函数返回时，线程将以静默方式退出。当函数以未处理的异常终止时，将打印堆栈跟踪，然后线程退出（但其他线程继续运行）。\n\n```python\n_thread.exit()\n```\n\n引发 SystemExit 异常。如果未捕获时，这将导致线程以静默方式退出。\n\n```python\n_thread.allocate_lock()\n```\n\n返回一个新的锁定对象。锁的方法如下所述。锁最初是解锁的。\n\n```python\n_thread.get_ident()\n```\n\n返回thread identifier当前线程。这是一个非零整数。它的价值没有直接意义; \n它旨在用作例如索引线程特定数据的字典的魔术cookie。当线程退出并创建另一个线程时，可以回收线程标识符。\n\n```python\n_thread.stack_size([size])\n```\n\n返回创建新线程时使用的线程堆栈大小（以字节为单位）。可选的size参数指定用于后续创建的线程的堆栈大小，并且必须是0（使用平台或配置的默认值）或至少为4096（4KiB）的正整数值。\n4KiB是目前支持的最小堆栈大小值，以保证解释器本身有足够的堆栈空间。\n\n## 对象\n\n```python\n_thread.LockType\n```\n\n这是锁定对象的类型。\n\n```python\nClass Lock\n```\n\n用于线程之间的同步\n\n### 方法\n\n锁定对象具有以下方法：\n\n```python\nlock.acquire(waitflag = 1，timeout = -1)\n```\n\n在没有任何可选参数的情况下，此方法无条件地获取锁定，如果有必要，等待它被另一个线程释放（一次只有一个线程可以获取锁定 - 这就是它们存在的原因）。\n\n如果存在整数 ``waitflag`` 参数，则操作取决于其值：如果它为零，则仅在不等待的情况下立即获取锁定时获取锁定，而如果它非零，则如上所述无条件地获取锁定。\n\n如果浮点超时参数存在且为正，则它指定返回之前的最长等待时间（以秒为单位）。负超时参数指定无限制等待。如果 ``waitflag`` 为零，则无法指定超时。\n\n``True`` 如果成功获取锁定则返回值，否则返回值 ``False`` 。\n\n```python\nlock.release()\n```\n\n释放锁定。必须先获取锁，但不一定是同一个线程。\n\n```python\nlock.locked()\n```\n\n返回锁的状态：True如果已被某个线程获取，False如果没有。\n\n除了这些方法之外，还可以通过with语句使用锁定对象，例如::\n\n```python\nimport _thread\n\na_lock = _thread.allocate_lock()\nwith a_lock:\n   print(\"a_lock is locked while this executes\")\n```"}, "/WebBit_doc/zh/micropython/library/btree.html": {"title": "btree – 简单的 BTree 数据库", "content": "btree – 简单的 BTree 数据库\n=====================================\n\n ``btree`` 模块使用外部储存（磁盘文件，或在一般情况下为随机访问流）实现简单的键值数据库。\n 键排序储存在数据库中，除对单个键值的有效检索外，数据库还支持高效的有序范围扫描（使用给定范围内的键来检索值）。\n 在应用程序接口方面，B树数据库尽可能以与标准 `dict` 类型工作方式相似的方式运行，一个明显区别是键和值都须\n 为 `bytes` 对象（因此，若您想要储存其他类型的对象，需首先将之序列化为 `bytes` ）。\n\n该模块基于著名的BerkelyDB 库的1.xx版本。\n\n示例:\n```python\n import btree\n\n # First, we need to open a stream which holds a database 首先，我需要打开一个包含数据库的流\n # This is usually a file, but can be in-memory database 这通常是一个文件，也可能是一个内存数据库\n # using uio.BytesIO, a raw flash partition, etc. 使用uio.BytesIO，一个原始闪分区\n # Oftentimes, you want to create a database file if it doesn't\n # exist and open if it exists. Idiom below takes care of this.\n # 通常，若不存在数据库文件，则您需要创建一个；若已存在，则只需打开。以下的习语考虑到了这一点。\n # DO NOT open database with \"a+b\" access mode. 请勿打开带有\"a+b\"访问编码的数据库。\n\ntry:\n    f = open(\"mydb\", \"r+b\")\nexcept OSError:\n    f = open(\"mydb\", \"w+b\")\n\n # Now open a database itself 现在打开一个数据库\n db = btree.open(f)\n\n # The keys you add will be sorted internally in the database 您添加的键将在数据库进行内部排序\n db[b\"3\"] = b\"three\"\n db[b\"1\"] = b\"one\"\n db[b\"2\"] = b\"two\"\n\n # Assume that any changes are cached in memory unless\n # explicitly flushed (or database closed). Flush database\n # at the end of each \"transaction\". \n # 除非显式刷新（或数据库关闭），否则假设任何更改都缓存在内存中。在每次“处理”结束时都刷新数据库。\n db.flush()\n\n # Prints b'two'\n print(db[b\"2\"])\n\n # Iterate over sorted keys in the database, starting from b\"2\"\n # until the end of the database, returning only values. \n # 在数据库中对已排序的键进行迭代，从b“2”开始到数据库结束，只返回值。\n # Mind that arguments passed to values() method are *key* values. 注意传递给values()方法的参数为*key*值\n # Prints:\n #   b'two'\n #   b'three'\n for word in db.values(b\"2\"):\n    print(word)\n\n del db[b\"2\"]\n\n # No longer true, prints False 不正确，打印False\n print(b\"2\" in db)\n\n # Prints:\n #  b\"1\"\n #  b\"3\"\n for key in db:\n    print(key)\n\n db.close()\n\n # Don't forget to close the underlying stream! 请一定记得关闭基础流！\n f.close()\n```\n\n函数\n---------\n\n```python\nopen(stream, \\*, flags=0, cachesize=0, pagesize=0, minkeypage=0 )\n```\n\n从随机存取的 ``stream``（类似一个打开的文件）中打开一个数据库。所有其他的参数都是可选的，且都只为关键字，并允许对数据库操作的高级参数进行调整（大多数用户并不会需要这个）:\n\n* *flags* - 当前未使用的\n* *cachesize* - 以字节计的建议最大内存缓存大小。对于一个由充足内存的板而言，使用更大值或许可以提高性能。该值只是推荐值，若该值设置过低，则模块可能会占用更多内存。\n* *pagesize* - B树中用于节点的页面大小。可接受范围为512-65536。若为0，则会使用基础I/O块的大小（内存使用和性能之间的最佳协调）。\n* *minkeypage* - 每个页面存储的键的最小数量。默认值为0等于2。\n\n返回一个B树对象，该对象实现一个字典协议（方法集）和下述的一些附加方法。\n\n方法\n-------\n\n```python\nbtree.close()\n```\n   关闭数据库。处理结束时关闭数据库是强制性的，因为某些未写入的数据可能仍留在缓存中。注意：这并不会关闭随数据库打开的基础流，基础流应单独关闭（这也是强制性的，以确保从缓冲区中刷新的数据进入底层储存）。\n\n```python\nbtree.flush()\n```\n   将缓存中的任何数据刷新到底层流。\n\n```python\nbtree.__getitem__(key)\nbtree.get(key, default=None)\nbtree.__setitem__(key, val)\nbtree.__detitem__(key)\nbtree.__contains__(key)\n```\n\n标准字典方法。\n\n```python\nbtree.__iter__()\n```\n   B树对象可被直接迭代（与字典相似）以按顺序访问所有键。\n\n```python\nbtree.keys([start_key, [end_key, [flags]]])\nbtree.values([start_key, [end_key, [flags]]])\nbtree.items([start_key, [end_key, [flags]]])\n```          \n\n这些方法类似于标准字典方法，但也可使用可选参数来迭代一个键子范围，而不是整个数据库。\n注意：这三种方法中， *start_key* 和 *end_key* 参数都代表键值。例如， ``values()`` 方法将迭代与给定键范围对应的值。\n无 *start_key* 值即意为“从首个键”，无 *end_key* 值或其值为None则意为“直到数据库结束”。\n默认情况下，范围包括 *start_key* ，而不包括 *end_key* ，您可以通过传递 `btree.INCL` 的标记来将 *end_key* 包括在迭代中。\n您可以通过传递 `btree.DESC` 的标记来按照下行键方向进行迭代。标记值可同为ORed。\n\n常量\n---------\n\nINCL\n\n`keys()`, `values()`, `items()` 方法的标记, 指定扫描应该包含结束键。\n\nDESC\n\n`keys()`, `values()`, `items()` 方法的标记, 指定扫描应按照键的下行方向进行。"}, "/WebBit_doc/zh/micropython/library/network.html": {"title": "network- 网络配置", "content": "network- 网络配置\n==================\n\n该模块提供网络驱动程序和路由配置。要使用此模块，必须烧录具有网络功能的MicroPython固件版本。\n此模块中提供了特定硬件的网络驱动程序，用于配置硬件网络接口。然后，可以通过 `usocket`模块使用已配置接口提供的网络服务。\n\n构建对象\n------------\n\n```python\nclass: WLAN(interface_id)\n```\n\n  创建WLAN对象。\n\n- ``interface_id`` \n  - ``network.STA_IF`` 客户端，连接到上游WiFi接入点。\n  - ``network.AP_IF``  接入点，允许其他WiFi客户端连接。\n\n\n\n方法\n------------\n\n```python\nWLAN.active(is_active)\n```\n\n带有参数时，为是否激活，不带参数为查询当前状态。当激活WiFi功能后,功耗会增加。当不使用WiFi功能可使用 ``active`` 来真正关闭物理层的无线。\n\n- ``is_active`` \n  -  ``True``  激活（“up”）网络接口。\n  -  ``False``  停用（“down”）网络接口。\n\n\n```python\nWLAN.scan([ssid，bssid，channel，RSSI，authmode，hidden])\n```\n\n扫描可用的无线网络（仅在STA接口上进行扫描），返回有关WiFi接入点信息的元组列表。\n\n- ``ssid`` 服务集标识。\n\n- ``bssid`` 接入点的硬件地址，以二进制形式返回为字节对象。您可以使用ubinascii.hexlify()将其转换为ASCII格式。\n\n- ``authmode``\n\n  - ``AUTH_OPEN`` = 0\n  - ``AUTH_WEP`` = 1\n  - ``AUTH_WPA_PSK`` = 2\n  - ``AUTH_WPA2_PSK`` = 3\n  - ``AUTH_WPA_WPA2_PSK`` = 4\n  - ``AUTH_MAX`` = 6\n\t\n- ``hidden``\n\n  - ``False`` 可见\n  - ``True`` 隐藏\n  \n```python\nWLAN.isconnected()\n```\n\n检查站点是否连接到AP。\n\n- 在STA模式下，如果连接到WiFi接入点并具有有效的IP地址则返回True，否则返回False。\n- 在AP模式下，当站点连接时返回True，否则返回False。\n\n```python\n WLAN.connect(ssid, password)\n```\n\n连接到无线网络。\n\n- ``ssid``：WiFi名称\n- ``password``：WiFi密码\n\n```python\n WLAN.config(essid, channel)\n```\n\n获取接口的MAC adddress或者设置WiFi接入点名称和WiFi通道。\n\n-  ``ssid``：WiFi账户名\n-  ``channel``：WiFi通道\n\n```python\n WLAN.ifconfig([(ip, subnet, gateway, dns)])\n```\n\n不带参数时，返回一个4元组(ip, subnet_mask, gateway, DNS_server)。\n\n- ``ip``：IP地址\n- ``subnet_mask``：子网掩码\n- ``gateway``:网关\n- ``DNS_server``：DNS服务器\n\n\n带参数时，配置静态IP。例如:\n\n```python\nwlan.ifconfig(('192.168.0.4', '255.255.255.0', '192.168.0.1', '8.8.8.8'))\n```\n\n```python\nWLAN.disconnect()\n```\n\n断开与当前连接的无线网络的连接。\n\n```python\nWLAN.status()\n```\n\n返回无线连接的当前状态。\n\n\n示例\n------------\n\n\n\n作为客户端连接WiFi:\n\n```python\nimport network\n\nSSID = \"yourSSID\"               #WiFi名称\nPASSWORD = \"yourPASSWD\"          #WiFi密码\n\nwlan = network.WLAN(network.STA_IF)  #创建WLAN对象\nwlan.active(True)               #激活界面\nwlan.scan()                    #扫描接入点\nwlan.isconnected()              #检查站点是否连接到AP\nwlan.connect(SSID, PASSWORD)      #连接到AP\nwlan.config('mac')              #获取接口的MAC adddress\nwlan.ifconfig()                #获取接口的IP/netmask/gw/DNS地址\n```\n\n\n作为接入开启WiFi:\n\n```python\nimport network\n\nap = network.WLAN(network.AP_IF)    #创建接入点界面\nap.active(True)                  #激活界面\nap.config(essid='ESP-AP',channel=1)  #设置接入点的ESSID，和WiFi 通道\n```\n  \n\nWiFi连接实例:\n\n```python\nimport network\n\nwlan = network.WLAN(network.STA_IF)\nwlan.active(True)\nif not wlan.isconnected():\n  print('connecting to network...')\n  wlan.connect('SSID', 'PASSWORD')   #连接到AP\n   #'SSID'： WiFi账号名\n   #'PASSWORD'：WiFi密码\n  while not wlan.isconnected():\n   pass\nprint('network config:', wlan.ifconfig())\n```"}, "/WebBit_doc/zh/micropython/library/uctypes.html": {"title": "uctypes - 以结构化方式访问二进制数据", "content": "uctypes - 以结构化方式访问二进制数据\n========================================================\n\n该模块为MicroPython实现“外部数据接口”。它背后的想法类似于CPython的 ``ctypes`` 模块，但实际的API是不同的，\n简化并针对小尺寸进行了优化。该模块的基本思想是定义具有与C语言允许的功能大致相同的数据的数据结构布局，\n然后使用熟悉的点语法访问它以引用子字段。\n\n构建对象\n------------\n\n```python\nclass uctypes.struct(addr, descriptor, type) \n```\n\n将内存中以c形式打包的结构体或联合体转换为字典，并返回该字典。\n\n- ``addr``:开始转换的地址\n- ``descriptor``:转换描述符\n\n  -  ``格式``: \"field_name\":offset|uctypes.UINT32\n  -  ``offset``：偏移量，单位：字节,  VOID、UINT8、INT8、UINT16、INT16、UINT32、INT32、UINT64、INT64、BFUINT8、BFINT8、BFUINT16、BFINT16、BFUINT32、BFINT32、BF_POS、BF_LEN、FLOAT32、FLOAT64、PTR、ARRAY\n- ``type``:c结构体或联合体存储类型，默认为本地存储类型\n\n  - ``NATIVE``:MricoPython本地的存储类型\n  - ``LITTLE_ENDIAN``:小端存储\n  - ``BIG_ENDIAN``:大端存储 \n\n示例:\n```\n  #如果需要C文件中的结构体，需要使用VC或者VS生成.dll（windows）或.os（linux、mac）文件，然后下载进入MCU中，使用MCU打开此文件，获取结构体或联合体\n  >>> a = b\"0123\"\n  >>> s = uctypes.struct(uctypes.addressof(a), {\"a\": uctypes.UINT8 | 0, \"b\": uctypes.UINT16 | 1}, uctypes.LITTLE_ENDIAN)\n  >>> print(s)\n  <struct STRUCT 3ffc7360>\n  >>> print(s.a)\n  48\n  >>> s.a = 49\n  >>> print(a)\n  b'1123'\n```"}, "/WebBit_doc/zh/micropython/library/dht.html": {"title": "dht - dht模块", "content": "dht - dht模块\n=========================================\n\ndht模块中提供了dht系列温湿度传感器读取相关的函数。\n\n\n类 DHT22\n---------\n\n### 构建对象\n\n```python\nclass DHT22(pin)\n```\n\n创建一个与引脚pin相连的DHT22传感器对象。\n\n- ``pin``:引脚\n\n> **ESP32支持引脚**\n> GPIO0/2/4/5/16/17/18/19/21/22/23/25/26/27\n\n示例:\n\n```python\nfrom machine import Pin\nimport dht\n\nd = dht.DHT22(Pin(Pin.P0))\n```\n\n### 方法\n\n\n```python\nDHT22.humidity()\n```\n\n读取并返回传感器的湿度值。 \n\n示例:\n\n```python\nd.measure()\nprint(d.humidity())\n```\n\n```python\nDHT22.temperature()\n```\n\n读取并返回传感器的温度值。\n\n示例:\n\n```python\nd.measure()\nprint(d.temperature())\n```\n\n类 DHT11\n---------\n\n与DHT22()函数类似，不再赘述。"}, "/WebBit_doc/zh/micropython/library/framebuf.html": {"title": "framebuf - 帧缓冲操作", "content": "framebuf - 帧缓冲操作\n=============================================\n\n该模块提供一个可用于创建位图、可发送到显示器的通用帧缓冲区。\n\n帧缓冲区类\n-----------------\n\n帧缓冲区类提供一个像素缓冲区，此缓冲区可使用像素、线、矩形、文本甚至其他帧缓冲区来绘制。此缓冲区可在生成显示器输出时发挥作用。\n\n示例:\n\n```python\nimport framebuf\n\n# FrameBuffer needs 2 bytes for every RGB565 pixel\n#对于每个RGB565像素，帧缓冲区都需2字节\nbuffer=bytearray(10 * 100 * 2)\nfbuf = framebuf.FrameBuffer(buffer, 10, 100, framebuf.RGB565)\n\nbuf.fill(0)\nfbuf.text('MicroPython!', 0, 0, 0xffff)\n```\n\n构造函数\n------------\n\n```python\nclass FrameBuffer(buffer, width, height, format, stride=width)\n```\n构建一个帧缓冲区对象。参数为:\n\n构建一个帧缓冲区对象。参数为:\n\n*   *buffer* 缓冲区是一个带有缓冲区协议的对象，且其大小须足以容纳由宽度、高度和帧缓冲区定义的每个像素。\n*   *width* 宽度为以像素为单位的帧缓冲区的宽度。\n*   *height* 高度为以像素为单位的帧缓冲区的高度。\n*   *format* 形式指定用于帧缓冲区的像素类型； 有效值为 `framebuf.MVLSB`, `framebuf.RGB565` 和 `framebuf.GS4_HMSB`. MVLSB为单色1位色彩，RGB565为RGB16位色彩，GS4\\_HMSB为灰度4位色彩。 色彩值c传递给类函数时，c是一个编码取决于帧缓冲区格式的小整数。\n*   *stride* 跨度是帧缓冲区中每条水平线之间的像素数量。此参数默认值为宽度， 但是在另一更大帧缓冲区或屏幕中实现一个帧缓冲区时可能需要调整。缓冲区空间须适应增大的步骤大小。\n\n必须指定有效缓冲区、宽度、高度和可选跨度。无效帧缓冲区大小或维度可能会导致意外错误。\n\n绘制原始形状\n------------------------\n\n下面的类函数将图形绘制到帧缓冲区中。\n\n```python\nFrameBuffer.fill(c)\n```\n使用指定颜色填满整个帧缓冲区。\n\n```python\nFrameBuffer.pixel(x, y[, c])\n```\n若未给定c，则获取指定像素的色值。若给定c，将指定像素设置到给定颜色。\n\n```python\nFrameBuffer.hline(x, y, w, c)\nFrameBuffer.vline(x, y, h, c)\nFrameBuffer.line(x1, y1, x2, y2, c)\n```\n\n使用给定颜色和1像素的厚度从一组坐标中绘制一条线。line类函数将这条线画到另一组坐标上， 而hline和vline类函数分别将水平和垂直线绘制到给定长度。\n\n```python\nFrameBuffer.rect(x, y, w, h, c)\nFrameBuffer.fill_rect(x, y, w, h, c)\n```\n\n在给定位置、按照给定大小和颜色绘制一个矩形。 rect 类函数仅绘制1个像素的边框，而 fill_rect 类函数可绘制出边框和矩形内部。\n\n绘制文本\n------------\n\n```python\nFrameBuffer.text(s, x, y[, c])\n```\n使用坐标作为文本的左上角，将文本写入帧缓冲区。文本颜色可由任意参数定义，否则将保持其默认值1。所有字符都有8x8像素的尺寸，目前尚无办法改变字体。\n\n其他类函数\n-------------\n\n```python\nFrameBuffer.scroll(xstep, ystep)\n```\n使用给定向量转换帧缓冲区的内容。这可能会在帧缓冲区中留下之前颜色的覆盖区。\n\n```python\nFrameBuffer.blit(fbuf, x, y[, key])\n```\n在当前帧缓冲区的顶部的给定坐标下绘制另外一个帧缓冲区。若指定*key*，则其应为一个颜色整数，且相应颜色被认为是透明的：所有具有该色值的像素都不会被绘制。\n\n此类函数在帧缓冲区使用的不同格式间运行，但是由于颜色格式不匹配，最终颜色可能与预想的存在差异。\n\n常量\n---------\n\n```python\nframebuf.MONO_VLSB\n```\n单色（1位）颜色模式\n\n此模式定义了一个映射，其中一个字节的位为垂直映射，而0位位于屏幕的最顶部。因此，每个字节占据8个垂直像素。 后续字节在连续的水平位置出现，直至到达最右侧的边缘。更多字节从最左边开始低8个像素显示。\n\n```python\nframebuf.MONO_HLSB\n```\n单色（1位）颜色模式\n\n此模式定义了一个映射，其中一个字节的位为水平映射。每个字节占据8个水平像素，0位位于最左边。 后续字节在连续的水平位置出现，直至到达最右侧的边缘。更多字节在下一行低1个像素显示\n\n```python\nframebuf.MONO_HMSB\n```\n单色（1位）颜色模式\n\n此模式定义了一个映射，其中一个字节的位为水平映射。每个字节占据8个水平像素，而7位位于屏幕的最左边。 后续字节在连续的水平位置出现，直至到达最右侧的边缘。更多字节在下一行低1个像素显示。\n\n```python\nframebuf.RGB565\n```\nRGB565彩色（16位，5+6+5）颜色模式\n\n```python\nframebuf.GS2_HMSB\n```\n灰度（2位）颜色模式\n\n```python\nframebuf.GS4_HMSB\n```\n灰度（4位）颜色模式\n\n```python\nframebuf.GS8_HMSB\n```\n灰度（8位）颜色模式"}, "/WebBit_doc/zh/micropython/library/micropython.html": {"title": "micropython - 访问和控制MicroPython内部", "content": "micropython - 访问和控制MicroPython内部\n==============================================================\n\n函数\n---------\n\n```python\nconst(expr)\n```\n\n用于声明表达式是常量，以便编译可以优化它。该功能的使用应如下:\n\n```python\nfrom micropython import const\n\nCONST_X = const(123)\nCONST_Y = const(2 * CONST_X + 1)\nprint(CONST_X)\nprint(CONST_Y)\n```\n\n运行结果:\n\n```\n>>>123\n>>>247\n```\n\n\n以这种方式声明的常量仍可作为全局变量从它们声明的模块外部访问。另一方面，如果常量以下划线开头，则它被隐藏，\n它不可用作全局变量，并且不会占用执行期间的任何内存。\n\n此 ``const`` 函数由MicroPython解析器直接识别，并作为:`micropython`模块的一部分提供，主要是通过遵循上述模式可以编写在\nCPython和MicroPython下运行的脚本。\n\n```python\nopt_level([level])\n```\n\n如果水平给出那么这个函数设置脚本，并返回的后续编译优化级别 ``None`` 。否则返回当前优化级别。\n\n优化级别控制以下编译功能:\n\n* 断言:在0级断言语句被启用并编译成字节码; 在级别1和更高级别的断言未编译。\n* 内置 ``__debug__`` 变量:在0级，此变量扩展为 ``True``; 在1级和更高级别，它扩展到 ``False``。\n* 源代码行号:在0,1和2级源代码行号与字节码一起存储，以便异常可以报告它们出现的行号; 在级别3和更高的行号不存储。\n\n默认优化级别通常为0级。\n\n```python\nalloc_emergency_exception_buf(size)\n```\n\n设置紧急情况下的（栈溢出，普通RAM不足等）保险RAM分配，使在紧急情况下仍有RAM可用。\n\n- ``size``:保险剩余RAM的大小，一般为100\n\n\n使用此函数的一种好方法是将它放在主脚本的开头（例如 ``boot.py`` 或 ``main.py`` ），\n然后紧急异常缓冲区将对其后的所有代码生效。\n\n\n```python\nmem_info([verbose])\n```\n\n函数说明： 打印当前内存使用的情况（包括栈和堆的使用量）。\n\n>如果给出参数level（任何数据类型），则打印出更加详细的信息，它会打印整个堆，指示哪些内存块被使用，哪些内存是空闲的。 \n\n不给参数:\n\n```\n>>>micropython.mem_info()\nstack: 736 out of 15360\nGC: total: 48000, used: 7984, free: 40016\nNo. of 1-blocks: 72, 2-blocks: 31, max blk sz: 264, max free sz: 2492\n>>>\n```\n给定参数:\n\n```\n>>>micropython.mem_info(\"level\")\nstack: 752 out of 15360\nGC: total: 48000, used: 8400, free: 39600\nNo. of 1-blocks: 82, 2-blocks: 36, max blk sz: 264, max free sz: 2466\nGC memory layout; from 3ffc4930:\n00000: h=ShhBMh=DhBhDBBBBhAh===h===Ahh==h==============================\n00400: ================================================================\n00800: ================================================================\n00c00: ================================================================\n01000: =========================================hBh==Ah=ShShhThhAh=BhBh\n01400: hhBhTShh=h==h=hh=Bh=BDhhh=hh=Bh=hh=Bh=BhBh=hh=hh=h===h=Bhh=h=BhB\n01800: h=hh=h=Bh=hBh=h=hBh=h=hBh=h=h=hh=======h========================\n01c00: ============================================Bh=hBhTh==hh=hh=Sh=h\n02000: h==Bh=B..h...h==....h=..........................................\n(37 lines all free)\n0b800: ........................................................\n>>>\n```\n\n```python\nqstr_info([verbose])\n```\n\n打印当前所有已使用的字符串在内存中的个数，占用内存大小等信息。\n\n\n\n> 如果给出参数，则打印出具体的字符串信息。打印的信息是依赖于实际情况的，包括被录入的字符串数量和它们使用的RAM的数量。\n在详细模式中，它打印出所有字符串的名称。 \n\n不给参数:\n\n```\n>>>micropython.qstr_info()\nqstr pool: n_pool=1, n_qstr=4, n_str_data_bytes=31, n_total_bytes=1135\n>>>\n```\n\n给定参数:\n\n```\n>>>micropython.qstr_info(\"level\")\nqstr pool: n_pool=1, n_qstr=4, n_str_data_bytes=31, n_total_bytes=1135\nQ(b)\nQ(2)\nQ(asdfa222)\nQ(level)\n>>>\n```\n\n```python\nstack_use()\n```\n\n返回一个整数，表示当前正在使用的堆栈量。这个绝对值并不是特别有用，而应该用它来计算不同点的堆栈使用差异。\n\n示例:\n```\n>>>micropython.stack_use()\n720\n```\n\n```python\nheap_lock()\n```\n\n锁定堆，当堆被锁定时，任何操作都不会分配内存 。如果尝试内存分配操作，则会产生MemoryError错误。。\n\n```python\nheap_unlock()\n```\n\n解锁堆\n\n```python\nkbd_intr(chr)\n```\n\n设置将引发KeyboardInterrupt异常的字符。默认情况下，在脚本执行期间将其设置为3，对应于Ctrl-C。\n将-1传递给此函数将禁用Ctrl-C的捕获，传递3将恢复它。\n\n如果该流用于其他目的，此函数可用于防止在通常用于REPL的传入字符流上捕获Ctrl-C。\n\n```python\nschedule(func, arg)\n```\n\n安排函数func “很快”执行。该函数传递值arg作为其单个参数。“很快”意味着MicroPython运行时将尽最大努力在尽可能早的时间执行该功能，\n因为它也试图提高效率，并且以下条件成立：\n\n- 预定的功能永远不会抢占另一个预定的功能。\n- 计划函数总是在“操作码之间”执行，这意味着所有基本的Python操作（例如附加到列表）都保证是原子的。\n- 给定端口可以定义“关键区域”，在该区域内永远不会执行调度函数。可以在关键区域内安排功能，但在退出该区域之前不会执行这些功能。关键区域的示例是抢占中断处理程序（IRQ）。\n\n此功能的用途是从抢占IRQ安排回调。这样的IRQ限制了在IRQ中运行的代码（例如，堆可能被锁定），并且调度稍后调用的函数将解除这些限制。\n\n注意：如果 ``schedule()`` 从抢占IRQ调用，则当不允许内存分配并且要传递的回调 ``schedule()`` 是绑定方法时，直接传递它将失败。这是因为创建对绑定方法的引用会导致内存分配。解决方案是在类构建对象中创建对方法的引用并将该引用传递给 ``schedule()`` 。\n这里将在“创建Python对象”下的参考文档中详细讨论 。\n\n有一个有限的堆栈来保存预定的函数，如果堆栈已满，``schedule()`` 则会引发一个 ``RuntimeError`` 。"}, "/WebBit_doc/zh/micropython/samples/weather.html": {"title": "如何爬取城市天气", "content": "# 如何爬取城市天气\n\n## 前提条件\n\n- 1.首先确保当前固件依赖包是否完整\n\n```python\nhelp(“modules”)\n```\n\n- 效果如下图，若没有图上两个依赖包，请烧录最新固件。\n\n- ![Evaluate](../../assets/micropython/samples/weather/check.png)\n\n- 2.确保已经连上网络\n详见：https://github.com/BPI-STEAM/BPI-BIT-MicroPython/wiki/how_to_wifi\n\n## 准备天气api\n\n- 1.这里我用到了国家气象局的API\n`http://www.weather.com.cn/data/cityinfo/101200801.html    # 101200801为荆州市`\n各城市ID详见：http://mobile.weather.com.cn/js/citylist.xml\n- 2.请求返回Json数据样列\n\n```python\n{\n  \"weatherinfo\": \n  {\n    \"city\": \"荆州\",\n    \"cityid\": \"101200801\",\n    \"img1\": \"n7.gif\",\n    \"img2\": \"d2.gif\",\n    \"ptime\": \"18:00\",\n    \"temp1\": \"16℃\",\n    \"temp2\": \"23℃\",\n    \"weather\": \"小雨转阴\"\n  }\n}\n```\n\n\n- 我们可以分析这些json文件写出下面这样的实例\n\n## 实例分析\n\n```python\n\nimport urequests\nfrom microbit import *\n\ndef get_weather():\n\turl = \"http://www.weather.com.cn/data/cityinfo/101200801.html\"\n\trsp = urequests.get(url)\n\tdata = eval(rsp.text) # eval函数用于把字符串类型的json数据->转为python的字典类型\n\tweather = data[\"weatherinfo\"]\n\tL = weather[\"temp1\"] #最低温\n\tH = weather[\"temp2\"] #最高温\n\treturn \"L:\" + L[:-1] + \" H:\" + H[:-1] # 数据样例->  L:16 H:23\n\ndisplay.scroll(get_weather())\n\n# L[:-1] H[:-1]去掉℃和℉两个特殊符号，否则会出现编码错误\n```"}, "/WebBit_doc/zh/micropython/modules/index.html": {"title": "内建模块", "content": "内建模块\n========\n\n以下模块是 BPI-BIT MicroPython 的当前固件所拥有的全部模块，在 REPL下输入 help('modules')确认可得，底部列表提供非官方内建（build-in）的模块文档。\n\n![image](../../assets/micropython/modules/all_modules.png)\n\n增添的模块有如下列表：\n\n1. urequests 模块\n2. umqtt.simple 模块\n3. display 模块\n4. music 模块"}, "/WebBit_doc/zh/micropython/modules/umqtt.simple.html": {"title": "umqtt.simple 模块", "content": "umqtt.simple 模块\n=========================================\n\nMQTT是一种基于发布 - 订阅的“轻量级”消息传递协议，用于在TCP / IP协议之上使用。\n提供订阅/发布模式，更为简约、轻量，易于使用，针对受限环境（带宽低、网络延迟高、网络通信不稳定），可以简单概括为物联网打造。\n\n>该模块来源于 [``MicroPython-lib``](https://github.com/micropython/micropython-lib/tree/master/micropython/umqtt.simple)\n\n构建对象\n-------------\n\n```python\nclass MQTTClient(client_id, server, port=0, user=None, password=None, keepalive=0,ssl=False, ssl_params={})\n```\n- ``client_id``\n- ``server``\n- ``port``\n- ``user``\n- ``password``\n- ``keepalive``\n- ``ssl``\n- ``ssl_params``\n\n\n方法\n----------------\n\n```python\nMQTTClient.set_callback(f)\n```\n\n- ``f`` - f(topic, msg) 为回调函数,第1参数为 ``topic`` 接收到的主题,第2参数为 ``msg`` 为该主题消息\n\n\n\n为收到的订阅消息设置回调\n\n```python\n MQTTClient.set_last_will(topic, msg, retain=False, qos=0)\n```\n\n设置MQTT“last will”消息。应该在 connect()之前调用。\n\n```python\n MQTTClient.connect( clean_session=True )\n```\n\n连接到服务器。如果此连接使用存储在服务器上的持久会话，则返回True（如果使用clean_session = True参数，则返回False（默认值））。\n\n```python\n MQTTClient.disconnect()\n```\n\n断开与服务器的连接，释放资源。\n\n```python\n MQTTClient.ping()\n```\n\nPing服务器（响应由wait_msg（）自动处理）\n\n```python\n MQTTClient.publish(topic, msg, retain=False, qos=0)\n```\n\n发布消息\n\n```python\n MQTTClient.subscribe(topic, qos=0)\n```\n\n订阅主题\n\n```python\n MQTTClient.wait_msg()\n```\n\n等待服务器消息。订阅消息将通过set_callback（）传递给回调集，任何其他消息都将在内部处理。\n\n```python\n MQTTClient.check_msg()\n```\n\n检查服务器是否有待处理的消息。如果是，则以与wait_msg（）相同的方式处理，如果不是，则立即返回。\n\n\n注意\n----------------\n\n* wait_msg()并且check_msg()是“主循环迭代”方法，阻塞和非阻塞版本。wait_msg()如果您没有任何其他前台任务要执行（即您的应用只响应订阅的MQTT消息），check_msg() 如果您也处理其他前台任务，则应定期在循环中调用它们 。\n* 请注意，如果您只发布消息，则不需要调用wait_msg()/ check_msg()，也不要订阅消息。\n* 发布和订阅都支持QoS 0和1。不支持QoS2以保持较小的代码大小。除ClientID外，目前只支持“clean session”参数进行连接。"}, "/WebBit_doc/zh/micropython/modules/display.html": {"title": "display 模块", "content": "display 模块\n==============\n\n要使用display模块，你需要:\n```python\nimport display\ndisplay= display.Display()\n```\n\n或者:\n```python\nfrom microbit import display\n```\n函数\n----------\n\n```python\ndisplay.scroll(val, color=Red, delay=150)\n```\n\n- ``val`` 要显示的字符比如'hello world!'或数字如 12345。\n- ``color`` 内部预置的颜色有:\n    - ``black`` - [0, 0, 0]\n    - ``Red`` - [2, 0, 0]\n    - ``Orange`` - [2, 1, 0]\n    - ``Yellow`` - [2, 2, 0]\n    - ``Green`` - [0, 2, 0]\n    - ``Blue`` - [0, 0, 2]\n    - ``Indigo`` - [0, 2, 2]\n    - ``Purple`` - [2, 0, 2]\n             \n用户也可以使用自定义的颜色比如`color=[7,8,9]`,列表中的值分别对应红色，绿色，蓝色的颜色值，取值范围都是0-255。\n\n同时color也可以包含多个颜色比如`[[0,1,5],[2,2,8],[3,2,1],[4,5,6]]`，每个字符的颜色就会按照color的颜色显示。\n\n- ``delay`` 字符滚动的速度。"}, "/WebBit_doc/zh/micropython/modules/urequests.html": {"title": "urequests 模块", "content": "urequests 模块\n================================\n\n之前我用了 socket 库，这个作为入门的工具还是不错的，对了解一些爬虫的基本理念，掌握爬虫爬取的流程有所帮助。\n入门之后，我们就需要学习一些更加高级的内容和工具来方便我们的爬取。\n那么这一节来简单介绍一下 urequests 库的基本用法。\n\nResponse类\n---------\n```python\nclass Response(s)\n```\n该Response类的对象，包含服务器对HTTP请求的响应。\n\n- ``s``-ussl对象\n\n方法\n---------\n\n```python\nclose()\n```\n\n关闭socket。\n\n```python\n@content\n```\n\n返回响应的内容，以字节为单位。\n\n```python\n@text\n```\n\n以文本方式返回响应的内容，编码为unicode。\n\n```python\njson()\n```\n\n返回响应的json编码内容并转为dict类型。\n\n方法\n---------\n\n```python\nrequest(method, url, data=None, json=None, headers={},params=None)\n```\n\n向服务器发送HTTP请求。\n\n- ``method`` - 要使用的HTTP方法\n- ``url`` - 要发送的URL\n- ``data`` - 要附加到请求的正文。如果提供字典或元组列表，则将进行表单编码。\n- ``json`` - json用于附加到请求的主体。\n- ``headers`` - 要发送的标头字典。\n- ``params`` - 附加到URL的URL参数。如果提供字典或元组列表，则将进行表单编码。\n\n```python\nhead(url, **kw)\n```\n\n发送HEAD请求,返回Response对象。\n\n- ``url`` - Request对象的URL\n- ``**kw`` - request方法的参数。\n\n```python\nget(url, **kw)\n```\n\n发送GET请求,返回Response对象。\n\n- ``url`` - Request对象的URL\n- ``**kw`` - request方法的参数。\n\n```python\n post(url, **kw)\n```\n\n发送POST请求,返回Response对象。\n\n- ``url`` - Request对象的URL\n- ``**kw`` - request方法的参数。\n    \n\n```python\n put(url, **kw)\n```\n\n发送PUT请求,返回Response对象。\n\n- ``url`` - Request对象的URL\n- ``**kw`` - request方法的参数。\n    \n```python\n patch(url, **kw)\n```\n\n送PATCH请求,返回Response对象。\n\n- ``url`` - Request对象的URL\n- ``**kw`` - request方法的参数。\n\n\n    \n```python\n delete(url, **kw)\n```\n\n发送DELETE请求。,返回Response对象。\n\n- ``url`` - Request对象的URL\n- ``**kw`` - request方法的参数。"}, "/WebBit_doc/zh/micropython/modules/music.html": {"title": "music 模块", "content": "music 模块\n==============\n\nmusic模块与microbit的music使用方法相同。\n\n要使用music模块，你需要:\n```python\nimport music\n```\n音符\n----------\n\n以下是音符格式:\n```python\nNOTE[octave][:duration]\n```\n\n例如，``A1:4`` 指的是八度音程中的音符\"A\"，持续四个节拍（节拍可以由 ``set_tempo`` 函数设定 - 见下文）。\n如果使用音符 ``R`` ，则将其视为休息（静音）。\n\n在音调符号中，“#”表示将基本音级升高半音；“b”表示将基本音级降低半音；例如，Ab是A-升半音并且C#是C-降半音。\n\noctave默认状态下等于4，为中音阶；duration默认状态是4节拍；\n\n\n贝多芬第五交响曲的开头:\n\n```python\n['r4:2', 'g', 'g', 'g', 'eb:8', 'r:2', 'f', 'f', 'f', 'd:8']\n```\n\n八度音阶的定义和范围符合本页列出的关于科学音高表示法的表格 [on this page about scientific pitch notation](https://en.wikipedia.org/wiki/Scientific_pitch_notation#Table_of_note_frequencies)\n例如，middle \"C\"是 ``c4`` 和concert “A”（440）是 ``a4`` 。八度音符从音符\"C\"开始。\n\n函数\n----------\n\n```python\n set_tempo(ticks=4, bpm=120)\n```\n\n设置播放节拍\n\n一定数量的ticks(整数)构成单个节拍。每个节拍以每分钟特定频率播放（每分钟节拍 - 也是整数）。\n\n可参考以下设置播放节拍:\n\n``music.set_tempo()`` - 将节拍设置恢复为 ticks = 4, bpm = 120\n``music.set_tempo(ticks=8)`` - 只改变单节拍速度\n``music.set_tempo(bpm=180)`` - 只改变节拍频率\n\n计算滴答的长度（以毫秒为单位）是非常简单的算术： ``60000/bpm/ticks_per_beat`` 。\n对于那些是默认的值或。 ``60000/120/4 = 125 milliseconds`` or ``1 beat = 500 milliseconds``。\n\n```python\n get_tempo()\n```\n\n获取当前速度作为整数元组: ``(ticks, bpm)``.\n\n```python\n play(music, pin=6, wait=True, loop=False)\n```\n\n- ``music`` \n\n    - 播放 ``music`` 包含上面定义的音乐DSL。\n\n    - 如果 ``music`` 是一个字符串，则应该是单个音符，例如 ``'c1:4'``。\n\n    - 如果 ``music`` 被指定为音符列表（如上面音乐DSL部分中所定义），则它们一个接一个地播放以执行旋律。\n\n- ``pin`` 默认是板子的P6引脚\n\n- ``wait`` 阻塞：如果 ``wait`` 设置为 ``True``, 为阻塞,否则未不。\n\n- ``loop`` ：如果 ``loop`` 设置为 ``True`` ，则重复调整直到stop被调用（见下文）或阻塞调用被中断。\n    \n\n```python\n pitch(frequency, duration=-1, pin=Pin.P6, wait=True)\n```\n\n- ``frequency``, ``duration``:以给定指定毫秒数的整数频率播放频率。例如，如果频率设置为440并且长度设置为1000，那么我会听到标准A调一秒钟。\n\n    如果 ``duration`` 为负，则连续播放频率，直到阻塞或者被中断，或者在后台呼叫的情况下，设置或调用新频率stop（见下文）。\n\n- ``pin`` pin=Pin.P6,默认是板子的P6引脚。可重定义其他引脚。\n\n    请注意，您一次只能在一个引脚上播放频率。\n\n- ``wait`` 阻塞：如果 ``wait`` 设置为 ``True``, 为阻塞,否则未不。\n\n\n```python\n stop()\n```\n    \n停止给定引脚上的所有音乐播放。\n\n\n```python\n reset()\n```\n\n以下列方式重置以下属性的状态\n\n``ticks = 4``\n``bpm = 120``\n``duration = 4``\n``octave = 4``\n\n内置旋律\n----------\n\n出于教育和娱乐的目的，该模块包含几个以Python列表表示的示例曲调。它们可以像这样使用：\n\n```python\nimport music\nmusic.play(music.NYAN)\n```\n\n所有音乐都不受版权保护，由Nicholas H.Tollervey撰写并发布到公共领域或者有一位不知名的作曲家，并受到公平（教育）使用条款的保护。\n\n它们是:\n\n``DADADADUM`` - 贝多芬第五交响曲C小调开幕式。\n``ENTERTAINER`` - 斯科特乔普林的Ragtime经典作品“The Entertainer”的开场片段。\n``PRELUDE`` - JSBach的48首前奏曲和赋格曲的第一首C大调前奏曲的开篇。\n``ODE`` - 贝多芬第七交响曲D小调的“欢乐颂”主题。\n``NYAN`` - Nyan Cat主题 (http://www.nyan.cat/). 作曲家不详。\n``RINGTONE`` - 听起来像手机铃声的东西。用于指示传入消息。\n``FUNK`` - 为秘密特工和犯罪主谋提供的时髦低音系列。\n``BLUES`` - 一个boogie-woogie 12杆蓝调步行低音。\n``BIRTHDAY`` - “生日快乐\" 版权状态见: http://www.bbc.co.uk/news/world-us-canada-34332853\n``WEDDING`` - 来自瓦格纳歌剧“Lohengrin”的新娘合唱。.\n``FUNERAL`` -  “葬礼进行曲”，也被称为FrédéricChopin的钢琴奏鸣曲第2号B-minor,Op 35。\n``PUNCHLINE`` -一个有趣的片段表明一个笑话已经被创造出来了。\n``PYTHON`` - John Philip Sousa的游行“Liberty Bell”又名“Monty Python's Flying Circus”的主题（之后以Python编程语言命名）。\n``BADDY`` - 沉默的电影时代入口的一个坏人。\n``CHASE`` - 无声电影时代的追逐场景。\n``BA_DING`` - 表示发生了某些事情的短信号\n``WAWAWAWAA`` - 一个非常悲伤的长号。\n``JUMP_UP`` - 用于游戏，表示向上移动。\n``JUMP_DOWN`` - 用于游戏，表示向下移动。\n``POWER_UP`` - 一种炫耀，表明一项成就被释放。\n``POWER_DOWN`` - 一种悲伤，表示一项成就已经失去。\n\n示例\n----------\n\n```python\n\"\"\"\nmusic.py\n\nPlays a simple tune using the Micropython music module.\nThis example requires a speaker/buzzer/headphones connected to P0 and GND.\n\"\"\"\nfrom microbit import *\nimport music\n\n# play Prelude in C.\nnotes = [\n    'c4:1', 'e', 'g', 'c5', 'e5', 'g4', 'c5', 'e5', 'c4', 'e', 'g', 'c5', 'e5', 'g4', 'c5', 'e5',\n    'c4', 'd', 'a', 'd5', 'f5', 'a4', 'd5', 'f5', 'c4', 'd', 'a', 'd5', 'f5', 'a4', 'd5', 'f5',\n    'b3', 'd4', 'g', 'd5', 'f5', 'g4', 'd5', 'f5', 'b3', 'd4', 'g', 'd5', 'f5', 'g4', 'd5', 'f5',\n    'c4', 'e', 'g', 'c5', 'e5', 'g4', 'c5', 'e5', 'c4', 'e', 'g', 'c5', 'e5', 'g4', 'c5', 'e5',\n    'c4', 'e', 'a', 'e5', 'a5', 'a4', 'e5', 'a5', 'c4', 'e', 'a', 'e5', 'a5', 'a4', 'e5', 'a5',\n    'c4', 'd', 'f#', 'a', 'd5', 'f#4', 'a', 'd5', 'c4', 'd', 'f#', 'a', 'd5', 'f#4', 'a', 'd5',\n    'b3', 'd4', 'g', 'd5', 'g5', 'g4', 'd5', 'g5', 'b3', 'd4', 'g', 'd5', 'g5', 'g4', 'd5', 'g5',\n    'b3', 'c4', 'e', 'g', 'c5', 'e4', 'g', 'c5', 'b3', 'c4', 'e', 'g', 'c5', 'e4', 'g', 'c5',\n    'a3', 'c4', 'e', 'g', 'c5', 'e4', 'g', 'c5', 'a3', 'c4', 'e', 'g', 'c5', 'e4', 'g', 'c5',\n    'd3', 'a', 'd4', 'f#', 'c5', 'd4', 'f#', 'c5', 'd3', 'a', 'd4', 'f#', 'c5', 'd4', 'f#', 'c5',\n    'g3', 'b', 'd4', 'g', 'b', 'd', 'g', 'b', 'g3', 'b3', 'd4', 'g', 'b', 'd', 'g', 'b'\n]\n\nmusic.play(notes)\n\n```"}, "/WebBit_doc/zh/micropython/guide.html": {"title": "MicroPython 上手指引", "content": "# MicroPython 上手指引\n\n如何使用 Bpi:Bit 的 MicroPython 开发资源？这篇文档将教你快速上手，获取所有资源。\n\n## 从基础开始\n\n从左侧**MicroPython目录**中的**基础教程**开始学习。\n\n## 为了不迷路，记住相关的位置，如下社区或仓库\n\n在这里需要学会如何搜索文档、查阅相关文档、到社区里提问等方法解决问题。\n\n- 开源组织 [BPI-STEAM](https://github.com/BPI-STEAM)\n\n- 发布主页 [BPI-BIT-MicroPython](https://github.com/BPI-STEAM/BPI-BIT-MicroPython)\n\n- 示例代码 [MicroPython-Samples](https://github.com/BPI-STEAM/MicroPython-Samples)\n\n- 官方文档 [doc-bpi-steam](https://bpi-steam-docs.readthedocs.io)\n\n- 官方社区 [bpi-bit/micropython](https://forum.banana-pi.org.cn/c/bpi-bit/micropython)\n\n- QQ 交流群 662087773 和 541341988 都可以，欢迎来学习交流（玩！）。\n\n推荐的社区有如下：\n\n- [MicroPython 中文社区](http://www.micropython.org.cn/bbs/)\n\n- [MicroPython Dfrobot 社区](http://mc.dfrobot.com.cn/forum-157-1.html)\n\n\n## 使用示例代码，学习 Python 编程\n\n进入我们的 SDK 示例仓库，欢迎提出需求或提交代码，和我们共同建设开源社区。\n\n- 示例代码 [MicroPython-Samples](https://github.com/BPI-STEAM/MicroPython-Samples)\n\n\n## 看看别人的博客，了解更广阔的世界\n\n此处是预留给大佬们的位置，欢迎入驻。\n\n> 我的博客在这里 [Juwan](http://cnblogs.com/juwan) 。"}, "/WebBit_doc/zh/arduino/tutorials/basic/arduino-ide.html": {"title": "安装Arduino IDE并添加BPI-BIT开发扩展", "content": "# 安装Arduino IDE并添加BPI-BIT开发扩展\n\n## 安装Arduino IDE \n\n### 在Windows系统下：\n1. 下载并安装最新版本的Arduino IDE， ```Windows Installer``` from [arduino.cc](https://www.arduino.cc/en/Main/Software)\n2. 从 [espressif/arduino-esp32](https://github.com/espressif/arduino-esp32)开源项目下载Arduino开发扩展包\n\n    ![Step 1](../../../assets/arduino/tutorials/basic/Image/win-1.png)\n\n3. 解压Arduino开发扩展包  ```[ARDUINO_SKETCHBOOK_DIR]/hardware/espressif/esp32```\n    \n    - ARDUINO_SKETCHBOOK_DIR: 一般情况下是 ```C:/Users/[YOUR_USER_NAME]/Documents/Arduino``` 并列在Arduino首选项中的“Sketchbook位置”下方。\n        \n        ![Step 2](../../../assets/arduino/tutorials/basic/Image/win-2.png)\n\n    - 依次打开目录 ```[ARDUINO_SKETCHBOOK_DIR]/hardware/espressif/esp32/tools``` 并且双击运行 ```get.exe```\n        \n        ![Step 3](../../../assets/arduino/tutorials/basic/Image/win-3.png)\n\n    - 当 ```get.exe``` 运行结束, 您应该在目录中看到以下文件\n\n        ![Step 4](../../../assets/arduino/tutorials/basic/Image/win-4.png)\n\n4. 插入BPI：BIT板并等待驱动程序安装（或手动安装） [Serial CH341](http://www.wch.cn/downloads/file/5.html) \n5. 运行 `Arduino IDE`\n6. 选择您的版型(BPI-BIT) ```Tools > Board``` menu\n\n    ![Step 5](../../../assets/arduino/tutorials/basic/Image/win-5.png)docs\\WebBit_doc\\zh\\assets\\arduino\\tutorials\\basic\\Image\n\n7. 选择BIT板所连接的COM端口，例如`COMx`\n8. 编译并上传您的工程代码 (BIT板设计有自动烧录电路，直接点击上传即可)\n\n    ![Arduino IDE Example](../../../assets/arduino/tutorials/basic/Image/arduino-ide.png)\n\n### 在Debian / Ubuntu OS安装说明\n\n- 从 [arduino.cc](https://www.arduino.cc/en/Main/Software)网站获取并安装最新版本的 Arduino IDE\n- 打开终端并执行以下命令 (copy-> paste并点击回车):\n\n  ```bash\n  sudo usermod -a -G dialout $USER && \\\n  sudo apt-get install git && \\\n  wget https://bootstrap.pypa.io/get-pip.py && \\\n  sudo python get-pip.py && \\\n  sudo pip install pyserial && \\\n  mkdir -p ~/Arduino/hardware/espressif && \\\n  cd ~/Arduino/hardware/espressif && \\\n  git clone https://github.com/espressif/arduino-esp32.git esp32 && \\\n  cd esp32 && \\\n  git submodule update --init --recursive && \\\n  cd tools && \\\n  python2 get.py\n  ```\n- 重新运行 Arduino IDE\n\n- 如果您已经安装arduino至`~/`目录，请执行以下代码, 如果没有, 那么请从 `mkdir -p ~/Arduino/hardware`开始:\n\n  ```bash\n  cd ~/Arduino/hardware\n  mkdir -p espressif && \\\n  cd espressif && \\\n  git clone https://github.com/espressif/arduino-esp32.git esp32 && \\\n  cd esp32 && \\\n  git submodule update --init --recursive && \\\n  cd tools && \\\n  python2 get.py\n  ```\n\n### Mac OS安装说明\n\n- 从 [arduino.cc](https://www.arduino.cc/en/Main/Software)网站获取并安装最新版本的 Arduino IDE\n- 打开终端并执行以下命令 (copy-> paste并点击回车):\n\n  ```bash\n  mkdir -p ~/Documents/Arduino/hardware/espressif && \\\n  cd ~/Documents/Arduino/hardware/espressif && \\\n  git clone https://github.com/espressif/arduino-esp32.git esp32 && \\\n  cd esp32 && \\\n  git submodule update --init --recursive && \\\n  cd tools && \\\n  python get.py \n  ```\n  其中 `~/Documents/Arduino` 目录与\"Arduino\" > \"首选项\" > \"Sketchbook location\" (在软件启动后)应该保持一致。 如果有需要的话，或许需要更改上面的命令！\n  \n- 如果您收到以下错误。 使用xcode-select --install安装命令行开发工具并再次尝试上面的命令：\n\n```\nxcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun\n```\n  \n```\nxcode-select --install\n```\n  \n- 在运行 `python get.py`的时候，收到错误提示: `IOError: [Errno socket error] [SSL: TLSV1_ALERT_PROTOCOL_VERSION] tlsv1 alert protocol version (_ssl.c:590)` ，您可以尝试使用 `python3` 代替 `python` \n\n- 重启 Arduino IDE"}, "/WebBit_doc/zh/webduino/advanced/blockly.html": {"title": "认识 Webduino Blockly Bit", "content": "# 认识 Webduino Blockly Bit\n\nWebduino Blockly Bit 体验版是 Webduino 所研发出来的图像化编辑工具，采用 Google Blockly 设计而成，提供虚实整合、程序积木、远程操控的环境，可尽情体验物联网的使用情境与操作感受， 快速实现各式各样的创意。\n\n打开链接：[Webduino Blockly Bit 体验版](https://webduino.com.cn/link.html?lang=zh-hans&type=blockly)\n\n> 更多 Webduino Blockly 功能请参考：[Webduino Blockly 基本操作](https://tutorials.webduino.io/zh_tw/docs/basic/blockly/blockly-tutorial-01.html)、[Webduino Blockly 特殊功能](https://tutorials.webduino.io/zh_tw/docs/basic/blockly/blockly-tutorial-02.html)、[连动多块开发板](https://tutorials.webduino.io/zh_tw/docs/basic/blockly/multi-board.html)。\n\n## 工具接口说明\n\nWebduino Blockly 的接口主要分成三个部分，第一个部分是左边与左上方的选单列，里头有「程序积木」与「JavaScript」两个互相切换的页签，右上方依序为「产生 QRCode」、「查看装置状态」、「网页互动测试」 、「Webduino Bit 仿真器」、「删除所有积木」、「存盘并产生链接」和「执行」。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/blockly-01.jpg)\n\n## 控制 Webduino Bit 开发板\n\nebduino Blockly Bit 目前可以 Wi-Fi 和 WebSocket 操控，如果没有实体开发板，亦可透过「仿真器」的方式操控。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/blockly-02.jpg)\n\n注意，若要使用 WebSocket，**网址必须为 http，且端口号须为 8080**。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/blockly-08.jpg)\n\n## 储存盘案\n\n当我们编辑完之后，可以点选 Webduino Blockly 右上方的「链接」图标，会产生一组链接网址，这组链接网址代表的是当前画面，只要把这组网址记到浏览器的「我的最爱」或「书签」内，下次再打开就会出现一模一样的画面了。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/blockly-07.jpg)\n\n## 在线 Webduino Bit 仿真器\n\n打开 Webduino Blockly Bit 体验版后，画面上会自动打开仿真器，仿真器里包含一块虚拟的 Bit 开发板，程序执行后，开发板上的 Webduino logo 会变成绿色，同时下方出现灯泡与火焰的虚拟元素，如果有使用「 光敏电阻」，则可以透过灯泡元素进行互动，若有使用「温敏电阻」，则可以透过火焰元素进行互动。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/blockly-03.jpg)\n\n## 网页互动区\n\nWebduino Blockly 内嵌网页模板，点选网页互动测试的按钮，就可以从下拉选单选择这些网页模板，并透过这些网页操控物联网装置，网页模板包含：显示文字、点击灯泡、控制图片、颜色调整、按钮行为、拉霸操作、Youtube 、影像追踪、遥控器、绘制图表。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/blockly-04.jpg)\n\n## 完美支持手机\n\nWebduino Blockly 内建了 QRCode 的按钮，点选这个按钮就会产生 QRCode ，用行动装置扫描，就可以将目前「网页互动区」的网页，呈现于手机的浏览器。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/blockly-05.jpg)\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/blockly-06.jpg)"}, "/WebBit_doc/zh/webduino/advanced/index.html": {"title": "Webduino 高阶", "content": "# Webduino 高阶\n\n从这里开始，就正式进入物联网网页开发环节了，请按下述教程开始你的进阶之旅吧。\n\n可能会有些老生常谈的基础问题，但这并不影响你深入学习。\n\n> 请在标准环境 [Webduino Blockly 标准版](https://bit.webduino.com.cn/blockly/?lang=zh-hans) 下进行开发。\n\n> 教程对应的教学网站：[在线教学文件](https://bit.webduino.com.cn/site/zh_cn/tutorials.html) 。"}, "/WebBit_doc/zh/webduino/advanced/temperature.html": {"title": "侦测温度", "content": "# 侦测温度\n\nWebduino Bit 的内建一个温敏电阻，温敏电阻类似光敏电阻的原理，实时透过模拟讯号反馈温度数值并侦测温度的变化，进一步更能实现智能居家监测的相关应用。\n\n## 基本操作 ( 显示温度数值 )\n\n打开 [Webduino Blockly Bit 体验版](https://webduino.com.cn/link.html?lang=zh-hans&type=blockly)，在编辑区放入*开发板积木*，开发板默认使用「*仿真器*」，联机到画面中 「*虚拟的 Bit 开发板*」，默认 Device ID 为 「*1234*」。\n\n> 开发板相关积木，在「*开发板*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-01.jpg)\n\n如果是使用「*实体 Bit 开发板*」，下拉选单选择「*Wi-Fi*」，并于后方字段填入开发板的 Device ID。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-02.jpg)\t\n\n在开发板内放入「*设定 thermistor 为热敏电阻*」的积木。\n\n> 热敏电阻相关积木，在「*热敏电阻*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/temperature-01.jpg)\n\n点选右上方的选单，打开网页互动区，下拉选单选择「*显示文字*」，左侧选单也会出现对应的积木功能。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/temperature-02.jpg)\n\n放入 thermistor 开始侦测的积木，在侦测的同时，于网页互动区显示侦测到的温度。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/temperature-03.jpg)\n\n点选右上方红色按钮执行，会看见虚拟 Bit 开发板下方出现一个灯泡和一个火焰的图案，这时候只要用鼠标拖曳「火焰图案」靠近热敏电阻，就会看见温度呈现在网页中，如果是使用实体 Bit 开发板，则可以用手指按压热敏电阻，或用嘴吹气， 观察温度数值变化。\n\n> 范例链接：[Webduino Bit 侦测温度](https://webduino.com.cn/link.html?lang=zh-hans&type=example&blockly=temperature01)\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/temperature-04.gif)\n\n因为热敏电阻为模拟讯号，所以呈现的数值会有许多小数点以下的位数，我们可以透过四舍五入的积木，显示小数点两位的数值。\n\n> 四舍五入到小数点的积木在「*进阶功能 > 数值转换*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/temperature-05.jpg)\n\n## 组件互动 ( 全彩点矩阵颜色显示温度 )\n\n在 [5x5 全彩 LED 点矩阵](rgbmatrix.html) 教学里有介绍全彩点矩阵的用法，接着将会介绍如何透过不同的颜色，呈现温度的变化，当温度越高颜色越红，反之温度越低颜色越蓝，一开始除了温敏电阻，也放入设定 matrix 为全彩点矩阵的积木。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/temperature-06.jpg)\n\n因为要改变颜色，所以会用到颜色目录里的「红、绿、蓝」颜色积木，由于在 Blockly 的设定中，混合颜色的最大值为 100，最小值为 0，待会将要把温度的数值局限在这个范围内。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/temperature-07.jpg)\n\n首先使用一个变量 t 表示侦测到的温度，接着透过逻辑判断：「*如果 t 大于 100 则 t 只等于 100，如果 t 小于 0 则 t 只等于 0*」，就能将 t 局限在 0 到 100 之间，完成后也可透过网页互动区显示 t 的数值。\n\n> 变量的积木在「*变量*」目录下，逻辑积木在「*基本功能 > 逻辑*」目录下，数字积木在「*基本功能 > 数学式*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/temperature-08.jpg)\n\n放入「设定 matrix 第一颗色彩」的积木，设定红色为 t，蓝色为 100-t，如此一来当温度越高就会越红，温度越低就会越蓝。\n\n> 数学式加减的积木在「*基本功能 > 数学式*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/temperature-09.jpg)\n\n点选右上方红色按钮执行，要用鼠标拖曳「火焰图案」靠近或远离热敏电阻，就会看见全彩点矩阵的第一颗灯，呈现红色蓝色的变化，如果是使用实体 Bit 开发板，则可以用手指按压热敏电阻，或用嘴吹气，观察颜色变化。\n\n> 范例链接：[Webduino Bit 全彩点矩阵颜色显示温度 1](https://webduino.com.cn/link.html?lang=zh-hans&type=example&blockly=temperature02)\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/temperature-10.gif)\n\n如果要一次让全彩点矩阵的 25 颗灯一起亮，可以透过循环的方式，让 25 颗灯一起依据温度而产生红色蓝色的颜色变化。\n\n> 范例链接：[Webduino Bit 全彩点矩阵颜色显示温度 2](https://webduino.com.cn/link.html?lang=zh-hans&type=example&blockly=temperature03)\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/temperature-11.jpg)\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/temperature-12.gif)"}, "/WebBit_doc/zh/webduino/advanced/setting.html": {"title": "Webduino Bit 初始化设定", "content": "# Webduino Bit 初始化设定\n\n使用 Webduino Bit 之前，最重要的就是进行初始化设定，初始化设定的目的在于让 Webduino 开发板可以自动上网 ( Internet )，或是在局域网络透过 WebSocket 联机，有了初始化设定， 我们也能够自定义开发板的显示名称和密码，更可以连上 internet 进行远程更新。\n\n## Webduino Bit 初始化步骤说明\n\n### 1. 接上电源，输入 WiFi 账号密码联机\n\n把 Webduino Bit 接上电源，一开始在开发板正面的全彩 LED 点矩阵，会依序显示四个数字，这四个数字对应到计算机或行动装置 WiFi 搜寻里的 SSID 名称 ( 例如显示 1234，在 WiFi 搜寻中就会看到 bit1234 的名 称 )。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/setting-07.gif)\n\n因为开发板尚未设定联机至局域网络，所以一开始 *会闪红灯，接着红灯恒亮*。 接着请准备一台具备 WiFi 功能的计算机、笔电或行动装置，使用这台装置进行 WiFi 搜寻刚刚看到为「*bitXXXX*」的装置 ( 以上述的例子而言，就是搜寻 bit1234 )。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/setting-01.jpg)\n\n输入默认密码 **12345678**，进行联机。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/setting-02.jpg)\n\n### 2. 设定 WiFi 账号密码与显示名称\n\n*确认联机成功后*，打开浏览器 ( 建议使用 Chrome )，网址列输入 **192.168.4.1** 联机到 Bit 开发板的设定画面，包含以下几种设定：\n\n- *WiFi SSID、PWD*：*必填*，表示开发板要连接哪个无线网络。\n- *Device ID*：默认空白，*OTA 更新后就会取得 Device ID* ( **若默认 18 码 ID，在 OTA 更新后会更换为长度较短的 ID** )。\n- *Device SSID、PWD*：装置在 WiFi 搜寻中所显示的名称和密码，若不填写会自动产生 ID 以及默认密码 12345678 ( **尚未 OTA 远程更新前请勿修改** )。\n- *MQTT Server*：开发板要连接的服务器，默认 *Global*，如果在中国地区请选择 *China*。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/setting-03.jpg)\n\n设定完成后按下 SUBMIT 储存，出现 SAVE OK 的字样表示储存成功，此时 Bit 开发板会重启并闪烁红灯，当红灯熄灭，且绿灯亮起一次之后，表示 Bit 开发板已经成功链接上家里或环境内的 WiFi 基地台。 ( 若红灯持续闪烁或恒亮，请移除电源，重新操作步骤 1 与步骤 2 )\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/setting-04.jpg)\n\n**新版界面介绍：**\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/new-interface.png)\n\n上图可以看到我们将新版本界面分为了三个部分，第一部分是设置板子基本信息，同时反馈bit板Device ID，第二个部分设置板子需要连接的WiFi，可以同时设置三个WiFi，方便用户在开发环境与演示环境等不同场景键无缝切换，免去了换个地方即要重设WiFi的麻烦。第三个部分显示板子现在连接的WiFi信息以及版本信息。同时上图中的Device ID依旧为长ID，但是可以通过点击下面的按钮获取短ID，但是此时需要板子保持联网状态。点击获取`Shoren the ID`之后，会看到如下过程信息：\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/new-interface-getShortID.png)\n\n获取短ID结果：\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/new-interface-shortID.png)\n\n> 小提醒，版本号 Ver 0.1.06_0719_01 之后的版本，若红灯闪完后亮起「**蓝灯**」而不是绿灯，表示已有新版本可以进行 OTA 更新。\n\n### 3. OTA 远程更新\n\nOTA 远程更新可以在 Webduino Bit 连上网络后，联机服务器更新取得最新版本韧体，更新步骤如下：\n\n> 注意！ 更新过程中请勿移除开发板电源，避免更新失败。\n\n- 步骤 1、确认开发板已经可以正常连上 WiFi，若不行，请检查 WiFi 联机或重新进行初始化设定。\n- 步骤 2、移除开发板电源。\n- 步骤 3、接上开发板电源，**在白灯显示数字的时候，按住按钮 A**。\n- 步骤 4、**按住按钮 A 不放，直到开发板闪完红灯、绿灯熄灭上线后，此时会再听到蜂鸣器发出轻微的一个声响，再放开按钮 A**。 ( 若是第一次进行 OTA 更新，声响可能会在放开按钮 A 之后才会出现 )\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/setting-08.jpg)\n- 步骤 5、完成后会看到开发板的点矩阵，**由第一颗灯开始亮蓝灯**，表示开始进行更新，**当蓝灯全部亮起接着熄灭后，表示更新完成**。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/setting-09.gif)\n\n- 步骤 6、更新完成后开发板会闪红灯自动进行联机，联机成功会亮绿灯后绿灯熄灭，当 OTA 远程更新完成，可以看到一开始显示开发板的号码的白灯，由「闪灯」变成「跑马灯」的方式呈现，此时如果想修改 Device 的 SSID 显示名称， 就可以透过 WiFi 联机开发板，由 192.168.4.1 进行修改，而在设定画面最下方，也会看到开发板的版本号，变成 0528 以上的版本。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/setting-10.jpg)\n\n### 4. 打开 Webduino Blockly ( Bit 体验版 ) 进行测试\n\n如果要测试实体开发板，可以打开下方 Webudino Blockly ( Bit 体验版 ) 的范例程序，在「开发板」的积木空格内，填入开发板的 Device ID，接着点击右上方红色的执行按钮，执行后按钮会变成绿色，同时也会看见 Bit 开 发板亮起红绿蓝三色的菱形。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/setting-05.jpg)\n\n如果没有实体开发板，但想要体验 Webduino Bit，也可以打开下方范例程序，打开后可以看到画面中多出一个「仿真器」的区域，这个区域中包含一块虚拟的 Webduino Bit，其 Device ID 为 1234，因此只要开发板的下拉选单选择「仿真器」，Device ID 输入 1234，执行后就会看见虚拟的 Bit 开发板，亮起红绿蓝三色的菱形。\n\n> 范例程序：[https://goo.gl/PnK4FN](https://goo.gl/PnK4FN) & [Webduino Bit 全彩点矩阵显示颜色](https://webduino.com.cn/link.html?lang=zh-hans&type=example&blockly=rgbmatrix01)\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/setting-06.jpg)"}, "/WebBit_doc/zh/webduino/advanced/detail.html": {"title": "Webduino Bit 详细规格", "content": "# Webduino Bit 详细规格\n\nWebduino Bit 是 Webduino 最新的开发板，除了原本的功能一应俱全 ( Wi-Fi 操控、多装置串连、协同作业... 等 )，更内建许多新的组件与传感器，Webduino Bit 采用 ESP32 模块，内建 2.4G Wi-Fi 和蓝牙功能，具备 448KB ROM 和 520 KB SRAM 的内存容量，处理速度达 600 DMIPS，搭配 40nm 工艺的超低功耗，是目前市面上最高效能、最稳定以及最通用的产品之一。\n\n> 如欲操控 Webduino Bit，务必阅读 [Webduino Bit ( 初始化设定 )](setting.html#_top) 进行相关网络设定。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/detail-03.gif)\n\n## 默认组件脚位介绍\n\nWebduino Bit 开发板长 5 公分宽 5 公分，重量约 10~12 公克，除了下方 20 Pin 的「金手指接口」，更内建一个 25 颗全彩 LED 灯的矩阵，两个光敏电阻、两个按钮开关、一个温度感应电阻 一个蜂鸣器和一个九轴传感器 ( 三轴加速度、三轴陀螺仪与三轴磁力指南针 )，脚位配置如下：\n\n- *全彩 LED 矩阵*：A10 ( GPIO 4 )\n- *光敏传感器*：左上 A0 ( GPIO 36 )、右上 A3 ( GPIO 39 )\n- *按钮开关*：按钮 A P5 ( GPIO 35 )、按钮 B P11 ( GPIO 27 )\n- *温度传感器*：A6 ( GPIO 34 )\n- *蜂鸣器*：P0 ( GPIO 25 )\n- *九轴传感器 MPU-9250*：P20 ( GPIO 21 )、P19 ( GPIO 22 )\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/detail-05.jpg)\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/detail-04.jpg)\n\n## 外观介绍\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/detail-01.jpg)"}, "/WebBit_doc/zh/webduino/advanced/buzzer.html": {"title": "蜂鸣器", "content": "# 蜂鸣器\n\n蜂鸣器是一个可以产生声音信号的装置，使用直流电供电，接通讯号源之后，音频信号电流通过电磁线圈，使电磁线圈产生磁场，造成振动膜片周期性地振动发声，Webduino Bit 内建的蜂鸣器，能够播放七个八度音阶的声音， 藉由网页填入音符代码，就能播放指定的声音。\n\n## 基本操作\n\n打开 [Webduino Blockly Bit 体验版](https://webduino.com.cn/link.html?lang=zh-hans&type=blockly)，在编辑区放入*开发板积木*， 开发板默认使用「*仿真器*」，联机到画面中「*虚拟的 Bit 开发板*」，默认 Device ID 为 「*1234*」。\n\n> 开发板相关积木，在「*开发板*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-01.jpg)\n\n如果是使用「*实体 Bit 开发板*」，下拉选单选择「*Wi-Fi*」，并于后方字段填入开发板的 Device ID。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-02.jpg)\n\n在开发板内放入「*设定 buzzer 为蜂鸣器*」的积木。\n\n> 蜂鸣器相关积木，在「*蜂鸣器*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/buzzer-01.jpg)\n\n放入「使用 buzzer 播放」的积木，里头先摆入音符与节奏，「音符」第一个下拉选单有「*无声、C、CS、D、DS、E、F、FS、G、GS、A、AS、B*」，可以想象成钢琴的黑键与白键，有 S 的就是黑键， 第二个下拉选单就是有几个八度音，这里可以设定七个八度音 ( 1~7 )，*数字越大声越高*，「节奏」就是*几分之一秒*，最少可以到 1/10 秒。\n\n> 可以连续放入好几个音符节奏，播放的时候会依据放入的位置顺序播放。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/buzzer-02.jpg)\n\n如果觉得一个个的放入音符节奏麻烦，也可以使用一次填入音符节奏的积木。\n\n> 如果节奏的数量小于音符，多出来的音符就会使用最后一个节奏数字播放。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/buzzer-03.jpg)\n\n如果完全不会编辑音乐，甚至可以直接使用「音乐」的积木，里头默认有五种不同的曲调旋律。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/buzzer-04.jpg)\n\n最后也可以将上面三种播放音乐的模式混合在一起，先播放单音、再播放音乐最后播放一次性的音符节奏。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/buzzer-05.jpg)\n\n点选右上方红色按钮执行，如果是虚拟开发板，就会从喇叭或耳机听到声音，如果是实体开发板，就会听见上头的蜂鸣器发出声音了。\n\n> 范例解答：[Webduino Bit 蜂鸣器播放音乐](https://webduino.com.cn/link.html?lang=zh-hans&type=example&blockly=buzzer01)\n\n## 网页按钮操控蜂鸣器\n\n打开网页互动测试区，下拉选单选择「按钮行为」，画面里会出现好几个网页按钮，此时在右下角也会出现对应的积木功能可以选择。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/buzzer-06.jpg)\n\n放入「*点选按钮... 执行*」的积木，放入对应蜂鸣器要播放的声音，或是放入设定蜂鸣器播放状态 ( 暂停、停止、继续 ) 的积木，如此一来在点击按钮的时候，蜂鸣器就会播放声音、或是暂停播放。\n\n> 此处常常会忘记放入「*使用 buzzer 播放」的积木，要特别注意*。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/buzzer-07.jpg)\n\n> 范例解答：[网页按钮操控 Webduino Bit 蜂鸣器](https://webduino.com.cn/link.html?lang=zh-hans&type=example&blockly=buzzer02)"}, "/WebBit_doc/zh/webduino/advanced/button.html": {"title": "按钮开关", "content": "# 按钮开关\n\n开关常见于日常生活中，在 Webduino Bit 开发板正面的左右两侧，默认了两颗按钮开关，透过开关的操控，我们更能实作物联网的情境，甚至打造真实的游戏遥控器或智能家电的应用。\n\n## 基本操作\n\n打开 [Webduino Blockly Bit 体验版](https://webduino.com.cn/link.html?lang=zh-hans&type=blockly)，在编辑区放入*开发板积木*， 开发板默认使用「*仿真器*」，联机到画面中「*虚拟的 Bit 开发板*」，默认 Device ID 为 「*1234*」。\n\n> 开发板相关积木，在「*开发板*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-01.jpg)\n\n如果是使用「*实体 Bit 开发板*」，下拉选单选择「*Wi-Fi*」，并于后方字段填入开发板的 Device ID。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-02.jpg)\n\n在开发板内放入两个「*设定 button 为按钮开关*」的积木，从后方按钮开关的下拉选单，可以选择按钮 A 或按钮 B，选择完成后，点选在前方设定积木的下拉选单，使用「*新变量*」将变量分别命名为 btnA 和 btnB。\n\n> 按钮开关相关积木，在「*按钮开关*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/button-01.jpg)\n\n点选右上方的选单，打开网页互动区，下拉选单选择「*显示文字*」，左侧选单也会出现对应的积木功能。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/button-02.jpg)\n\n放入「当 button 进行按下」的积木，透过下拉选单选择对应的 btnA 或 btnB，设定当按下 btnA 的时候，在网页互动区显示「按下 A」，当按下 btnB 的时候，显示「按下 B」。\n\n> 显示积木在「*显示文字*」目录下，文字积木在「*基本功能 > 文字*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/button-03.jpg)\n\n点选右上方红色按钮执行，用鼠标点选虚拟开发板的按钮开关，或是按压自己的实体开发板的按钮开关，就会看见网页互动区里出现不同的文字。\n\n> 范例解答：[点击 Webduino Bit 按钮开关，显示不同文字](https://webduino.com.cn/link.html?lang=zh-hans&type=example&blockly=button01)\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/button-04.gif)\n\n## 按钮开关操控全彩点矩阵\n\n按钮开关除了可以和网页元素互动，也可以直接操控 Bit 开发板上的其他组件，接着我们就让按钮开关和全彩点矩阵互动，在点击不同按钮的时候呈现不同的图案，因为要和全彩点矩阵互动，所以在开发板内放入一个全彩点矩阵的积木，* 名称设定为 matrix*，放入两个按钮开关的积木，*名称分别设定为 btnA 与 btnB*。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/button-05.jpg)\n\n放入当按钮按下执行动作的积木，分别设定按下 btnA 和 btnB 时，全彩点矩阵会显示不同图案。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/button-06.jpg)\n\n点选右上方红色按钮执行，用鼠标点选虚拟开发板的按钮开关，或是按压自己的实体开发板的按钮开关，就会看见全彩点矩阵出现不同的图案。\n\n> 范例解答：[Webduino Bit 按钮开关操控全彩点矩阵](https://webduino.com.cn/link.html?lang=zh-hans&type=example&blockly=button02)\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/button-07.gif)"}, "/WebBit_doc/zh/webduino/advanced/photocell.html": {"title": "侦测光线", "content": "# 侦测光线\n\nWebduino Bit 内建许多的传感器，其中一项就是光敏电阻，藉由默认的两个光敏电阻，能够侦测光线的强弱，甚至互相搭配实作智能家电或自动侦测的相关应用。\n\n## 基本操作 ( 显示光线数值 )\n\n打开 [Webduino Blockly Bit 体验版](https://webduino.com.cn/link.html?lang=zh-hans&type=blockly)，在编辑区放入*开发板积木*， 开发板默认使用「*仿真器*」，联机到画面中「*虚拟的 Bit 开发板*」，默认 Device ID 为 「*1234*」。\n\n> 开发板相关积木，在「*开发板*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-01.jpg)\n\n如果是使用「*实体 Bit 开发板*」，下拉选单选择「*Wi-Fi*」，并于后方字段填入开发板的 Device ID。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-02.jpg)\n\n在开发板内放入两个「*设定 photocell 为光敏电阻*」的积木，从后方光敏电阻的下拉选单，可以选择左上或右上，选择完成后，点选在前方设定积木的下拉选单，使用「*新变量*」将变量分别命名为 left 和 right。\n\n> 光敏电阻相关积木，在「*光敏电阻*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/photocell-01.jpg)\n\n点选右上方的选单，打开网页互动区，下拉选单选择「*显示文字*」，左侧选单也会出现对应的积木功能。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/photocell-02.jpg)\n\n因为有两个光敏电阻，所以如果要同时侦测，需要分别放入 left 和 right 侦测的积木。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/photocell-03.jpg)\n\n为了让两个光敏电阻的数值同时显示，必须使用「变量」的积木来装载光线数值，这里分别建立 L 变量装载 left 侦测的数值，R 变量装载 right 侦测的数值。\n\n> 变量相关积木在「*变量*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/photocell-04.jpg)\n\n使用显示文字的「显示」积木，搭配「*建立字符串*」的积木，将 R 与 L 变量的数值同时显示在网页互动区内，点选建立字符串积木的「*蓝色小齿轮*」可以新增组合的缺口，就能放入逗号做为分隔。\n\n> 建立字符串相关积木在「*基本功能 > 文字*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/photocell-05.jpg)\n\n点选右上方红色按钮执行，会看见虚拟 Bit 开发板下方出现一个灯泡和一个火焰的图案，这时候只要用鼠标拖曳灯泡靠近光敏电阻，就会看见不同的数值呈现，如果是使用实体 Bit 开发板，则可以使用灯光照射光敏电阻，或用手遮挡光敏电阻， 观察光线数值变化。\n\n> 范例链接：[Webduino Bit 光敏电阻侦测光线](https://webduino.com.cn/link.html?lang=zh-hans&type=example&blockly=photocell01)\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/photocell-06.gif)\n\n## 逻辑互动 ( 点亮网页灯泡 )\n\n已经能够从光敏电阻获得光线数值后，接着就可以透过逻辑判断，来实作一个虚拟的小夜灯功能，因为小夜灯通常只需要一个光敏电阻，所以这里先使用左上的光敏电阻，名称设定为 left。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/photocell-07.jpg)\n\n打开网页互动区，下拉选单选择「*点击灯泡*」，左侧也会出现对应的积木选单。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/photocell-08.jpg)\n\n放入「*逻辑判断*」的积木，判断光线数值小于 0.7 的时候，就点亮互动区的灯泡，若光线大于 0.7 则让灯泡熄灭，若要新增逻辑判断，可以点选逻辑积木的「*蓝色小齿轮*」新增。\n\n> 逻辑相关积木在「*基本功能 > 逻辑*」目录下，数字相关的积木在「*基本功能 > 数学式*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/photocell-09.jpg)\n\n点选右上方红色按钮执行，虚拟 Bit 开发板下方出现一个灯泡和一个火焰的图案，用鼠标拖曳灯泡靠近左上的光敏电阻，就会看见互动区的灯泡熄灭，离开则灯泡就会亮起，如果是使用实体 Bit 开发板，则可以使用灯光照射光敏电阻， 或用手遮挡光敏电阻，观察网页虚拟灯泡变化。\n\n> 范例链接：[Webduino Bit 侦测光线点亮网页灯泡](https://webduino.com.cn/link.html?lang=zh-hans&type=example&blockly=photocell02)\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/photocell-10.gif)"}, "/WebBit_doc/zh/webduino/advanced/mpu9250.html": {"title": "九轴传感器", "content": "# 九轴传感器\n\nWebduino Bit 内建一个九轴传感器，型号为 MPU-9250，除了可以侦测空间内的加速度与旋转，更能透过磁力计的辅助侦测，实现侦测姿态角度、指南针... 等进阶应用。\n\n> 注意，使用九轴传感器需*将 Webduino Bit 更新至最新版本*，更新方式请参考：[Webduino Bit 初始化设定](setting.html#_top) 一文的「OTA 远程更新」\n\n## 加速度计\n\n加速度计主要侦测 x、y 和 z 三轴直线移动时「*瞬间*」加速度变化，要使用加速度计必须先了解加速度计在 Webduino Bit 中的方向，如下图所示，将开发板 5x5 全彩点矩阵朝上，金手指接脚朝向自己，*垂直上下的方向为 z 轴* ( 往上为负，往下为正 )，*水平左右为 x 轴* ( 往左为负，往右为正 ) *水平前后为 y 轴* ( 往自己的方向为负，远离自己的方向为正 )。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/mpu9250-01.jpg)\n\n打开 [Webduino Blockly Bit 体验版](https://webduino.com.cn/link.html?lang=zh-hans&type=blockly)，在编辑区放入*开发板积木*，联机方式选择*Wi-Fi*，并输入 Device ID，接着在开发板内放入「*设定 mup9250 为九轴传感器*」的积木， 在其下方接着摆入「*mpu9250 开始侦测加速度计*」的积木。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/mpu9250-02.jpg)\n\n使用显示文字的积木，同时显示 x、y 和 z 方向的加速度，点选右上方红色按钮执行，就会看见三个方向的加速度呈现在网页中，因为所在位置以及传感器初始化校准的不同，每块 Bit 在启用加速度侦测时，都会有些微的误差，但 Z 通常都会是负一千多 ( **单位为 mg**，1 g 通常为一个重力参数 )，X 和 \bY 通常会在 200 ~ -200 之间，此时可以拿起 Webduino Bit 上下左右挥动，就会看见数值发生变化，由于所侦测的数值为「*加速度*」，因此 *当开发板没有移动或等速移动的时候，加速度会保持在一个稳定的数值区间内*。\n\n> 提醒您，由于侦测的数值为「加速度」，在启动或停止的瞬间，*可能会产生反向的加速度* ( 就如行驶的公交车突然煞车或启动，乘客会往前倾或后仰 )，因此在开发时要透过一些逻辑判断来排除，或避免瞬间太大的启动与停止动作。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/mpu9250-03.jpg)\n\n## 陀螺仪\n\n加速度计主要侦测直线移动的瞬间加速度变化，而陀螺仪则是侦测旋转时「*瞬间*」的角度变化，如下图所示，将开发板 5x5 全彩点矩阵朝上，金手指接脚朝向自己，*绕着 z 轴旋转为 yaw* ( 顺时针旋转为正，逆时针旋转为负 )，*绕着 x 轴旋转为 roll* ( 顺时针朝自己旋转为负，逆时针旋转为正 ) *绕着 y 轴旋转为 pitch* ( 顺时针旋转为正，逆时针旋转为负 )。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/mpu9250-04.jpg)\n\n积木组合方式和加速度计相同，只需将开始侦测下拉选单选择「陀螺仪」，点选右上方红色按钮执行，就会看见三个方向转动的角度变化呈现在网页中，因为是瞬间角度变化，所以当*停止转动后，会看到角度逐渐回归启动时的数值*。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/mpu9250-05.jpg)\n\n## 姿态角度 ( 目前仅支持 roll 和 pitch )\n\n有别于陀螺仪呈现的是「瞬间」角度变化，姿态角度表现的是实际转动的夹角，如下图所示，将开发板 5x5 全彩点矩阵朝上，金手指接脚朝向自己，*绕着 z 轴旋转为 yaw* ( 逆时针旋转角度递增，区间为 -180~180 度 )，*绕着 x 轴旋转 为 roll* ( 顺时针旋转角度递增，区间为 -180~180 度 ) *绕着 y 轴旋转为 pitch* ( 逆时针旋转角度递增，区间为 -180~180 度 )。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/mpu9250-06.jpg)\n\n积木组合方式和加速度计相同，只需将开始侦测下拉选单选择「姿态角度」，点选右上方红色按钮执行，就会看见三个方向转动的角度变化呈现在网页中。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/mpu9250-07.jpg)\n\n## 磁力计\n\n磁力计主要可以计算出开发板在地球磁场空间内的数值，但主要会取决于所在地的经纬度，目前较无法提供一个准确的数值区间参考，因此使用上建议采用加速度计、陀螺仪或姿态角度来实现应用，积木组合方式和加速度计相同， 只需将开始侦测下拉选单选择「磁力计」，点选右上方红色按钮执行，就会看见三个数值呈现在网页中。"}, "/WebBit_doc/zh/webduino/advanced/rgbmatrix.html": {"title": "5x5 全彩 LED 点矩阵", "content": "# 5x5 全彩 LED 点矩阵\n\nWebduino Bit 的正中央内嵌一组 5x5 共 25 颗全彩 LED 的点矩阵，每个灯都可透过红绿蓝三原色进行混色，透过不同位置的灯号与颜色显示，就能呈现各种不同的图案造型。\n\n## 基本操作\n\n打开 [Webduino Blockly Bit 体验版](https://webduino.com.cn/link.html?lang=zh-hant&type=blockly)，在编辑区放入*开发板积木*， 开发板默认使用「*仿真器*」，联机到画面中「*虚拟的 Bit 开发板*」，默认 Device ID 为 「*1234*」。\n\n> 开发板相关积木，在「*开发板*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-01.jpg)\n\n如果是使用「*实体 Bit 开发板*」，下拉选单选择「*Wi-Fi*」，并于后方字段填入开发板的 Device ID。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-02.jpg)\n\n在开发板内放入「*设定 matrix 为全彩点矩阵*」的积木，在其下方接着摆入「*设定 matrix 色彩*」的积木。\n\n> 全彩点矩阵相关积木，在「*全彩点矩阵*」目录下。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-03.jpg)\n\n先用鼠标选择颜色，点击下方空格就能将颜色填入并绘制图案，如果选择黑色则该颗灯不会发光。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-04.jpg)\n\n点选右上方红色按钮执行，就可以看到仿真器的虚拟开发板，或是自己的实体开发板显示对应的颜色和图案。\n\n> 范例解答：[Webduino Bit 全彩点矩阵显示颜色](https://webduino.com.cn/link.html?lang=zh-hans&type=example&blockly=rgbmatrix01)\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-05.jpg)\n\n## 网页按钮互动\n\n已经了解全彩点矩阵的基本应用之后，接着要使用「网页互动区」的「网页按钮」操控灯号显示，点选上方选单的网页互动区按钮，下拉选单选择「*按钮行为*」，选择后在画面中会出现五个按钮，同时在左侧也会出现对应的积木选单。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-06.jpg)\n\n将「*点选按钮执行*」的积木放到画面里，分别设定点选按钮 1 和点选按钮 2 时会出现不同图案，点选按钮 3 则会将全彩点矩阵关闭。\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-07.jpg)\n\n点选右上方红色按钮执行，就可以用网页互动区的按钮，控制仿真器的虚拟开发板，或是自己的实体开发板显示对应的颜色和图案。\n\n> 范例解答：[网页按钮切换 Webduino Bit 全彩点矩阵图案](https://webduino.com.cn/link.html?lang=zh-hans&type=example&blockly=rgbmatrix02)\n\n![](../../assets/webduino/advanced/img/tutorials/zh_cn/rgbmatrix-08.gif)"}, "/WebBit_doc/zh/webduino/education_edition/detect/keyboard.html": {"title": "键盘行为", "content": "# 键盘行为\n\n鼠标和键盘是电脑必备的两大输入装置，熟悉了键盘的输入方式，就可以使用键盘进行简单交互，无论是要做成钢琴键盘还是游戏控制器都轻而易举，同时也可以搭配文字的输入，做出许多意想不到的互动效果。\n\n## 检测键盘行为\n\n「检测键盘行为」积木可以检测电脑键盘上大多数按键的按下与放开。\n\n> 检测键盘行为积木*处于随时检测*的状态，*不需要搭配无限循环*。\n\n![](../../../assets/webduino/education_edition/detect/keyboard/upload_cab0d8638477e4439b9bf927c1b71ace.jpg)\n\n用过按下和放开两种行为，就可以在按下键盘的同时，让小怪兽说出对应按键名称，放开键盘后就不说话。\n\n![](../../../assets/webduino/education_edition/detect/keyboard/upload_f2b9f50319a3b47a1adff6cafdc0dc7a.gif)\n\n按下键盘的行为会「*连续执行指令*」，类似在打字的时候，如果按着某个按键不放，画面中就会出现一连串这个按键的文字，例如下图，设定按下键盘A 的时候小怪兽会往左旋转，执行后，持续按住A 怪兽就会持续旋转，放开A 怪兽就会停止，不需要设定放开的指令。\n\n![](../../../assets/webduino/education_edition/detect/keyboard/upload_ab29dcdc4cf79cb980a9bac21baf2d2a.gif)\n\n## 键盘控制小怪兽移动\n\n积木可以*同时检测多个键盘控制行为*，通过键盘行为就能很简单的做出「按下上下左右键，小怪兽就会上下左右移动」。\n\n![](../../../assets/webduino/education_edition/detect/keyboard/upload_307f1e13b196d6398223719f42edd2e3.gif)"}, "/WebBit_doc/zh/webduino/education_edition/detect/time.html": {"title": "日期＆时间", "content": "# 日期＆时间\n\n日期与时间的积木，可以读取电脑的日期和时间并在网页上显示，可以搭配循环、开关或键盘...等行为，做出时钟、码表、游戏计时...等应用。\n\n## 取得目前日期与时间\n\n「日期」积木能够取得目前的年、月、日，「时间」积木能够取得目前的小时、分钟、秒，小时采用 24 小时计算，如果是下午三点会显示 15。\n\n![](../../../assets/webduino/education_edition/detect/time/upload_cb96a39bbcf323c24bf79ae38d32fe6c.png)\n\n## 时钟\n\n所下图执行该积木即可取得时间，「*时间只会取得一次，所以需要搭配「无限循环」积木，如下图*」。\n\n![](../../../assets/webduino/education_edition/detect/time/upload_27a51c6d97093758206f6fa3e30daee6.gif)\n\n## 闹钟\n\n延伸时钟的范例，搭配逻辑的积木，执行后就能做到在某个时间点产生提醒的闹钟功能。\n\n> 判断时间到了之后，可以通过「停止循环」积木将时间停止，避免时间继续显示。\n\n![](../../../assets/webduino/education_edition/detect/time/upload_966171ad34d632dd98a6bcde20c68074.gif)"}, "/WebBit_doc/zh/webduino/education_edition/detect/input.html": {"title": "对话框输入文字", "content": "# 对话框输入文字\n\n在编辑器中如果使用了「对话框输入文字」的积木，执行后，在怪兽互动舞台的画面底部，就会出现输入文字的对话框，通过输入文字就能进一步与开发板或小怪兽互动。\n\n## 积木清单\n\n对话框输入文字的积木有两种，第一种是「在对话框输入文字」，执行后会出现用来输入文字的对话框，第二种是「输入的文字」，执行后会取得所输入的文字。\n\n![](../../../assets/webduino/education_edition/detect/input/upload_599cb0bbf41d4332295199f7642c7af4.png)\n\n## 对话框输入文字\n\n「对话框输入文字」积木属于「*执行完成才会继续执行后方程序*」的类型( 点击前方问号会提示)，当编辑画面中有这块积木，*执行时当程序遇到这块积木会暂停，直到输入文字后才会再继续*。\n\n![](../../../assets/webduino/education_edition/detect/input/upload_1cce5797dbfdfba59cfab632a515679b.png)\n\n举例来说，下方的程序里的小怪兽在执行后不会讲话，直到输入文字后才会说话。\n\n![](../../../assets/webduino/education_edition/detect/input/upload_b54e5e45cb2c7400d2f5f7027ac9a083.gif)\n\n## 获取输入的文字\n\n「输入的文字」积木*一般都放在「对话框输入文字」积木之后*，用来获取输入的文字，将上述的例子稍做修改，如下图，就能够再让小怪兽讲出输入的文字。\n\n![](../../../assets/webduino/education_edition/detect/input/upload_d6799d41c2963f9eea126cdc0b912e60.gif)\n\n## 重复输入文字\n\n搭配「无限循环」积木，就能将上述的例子修改成「不断输入文字」的版本。\n\n![](../../../assets/webduino/education_edition/detect/input/upload_828002a7cd3adda00deac7e11e91db74.gif)\n\n## 一问一答\n\n通过输入文字的方式，能够轻松实现「一问一答」的效果，在输入文字积木之前摆放小怪兽询问姓名的文字，执行后会停留在输入文字的阶段，输入文字之后，通过「建立字串」积木，让小怪兽说出「XXX 你好」的文字组合。\n\n![](../../../assets/webduino/education_edition/detect/input/upload_449cda52190c8c863ac236a261af0653.gif)"}, "/WebBit_doc/zh/webduino/education_edition/update.html": {"title": "更新开发板固件", "content": "# 更新开发板固件\n\n想要使用编辑器软件控制 Web:bit 开发板，需要为开发板 安装 或 更新 固件，可以选择下述多种方法给 开发板更新固件 或 恢复出厂设置 。\n\n> 什么是编辑器？点此查看 [Web:bit 教育版 > 编辑器介绍](software.html#-1) 。\n\n## 更新固件方法 1：使用 安装版 进行更新\n\n> 什么是安装版？点此查看 [Web:bit 教育版 > 编辑器介绍 > 安装版](software.html#-5) 。\n\n将开发板通过 Micro USB 线连接电脑，最上方会出现安装版的「版本号」（如：V1.2.4）以及「扫描 USB 设备」的提示，此时可以将开发板通过 USB 线连接电脑，让软件进行自动扫描并连接。\n\n![](../../assets/webduino/education_edition/update/upload_3f793de122644f3c4fb1f17de0bcc634.png)\n\n连接到开发板后，*安装版上方会出现开发板的 Device ID 以及固件版本号*，接着开启菜单栏（没有可以按下键盘的 *`Ctrl + W`* 出现），用鼠标选择「*工具> 设置 Web:bit WiFi*」，开始进行初始化设置。\n\n![](../../assets/webduino/education_edition/update/upload_832cf2a13eb24e1c994fac3ea4d81373.png)\n\n在电脑中打开 **安装版** 软件，将开发板通过 Micro USB 线连接电脑，确认安装版已经正确连接到开发板之后( 上方会出现开发板的 Device ID 以及版本号码)，按下`Ctrl + W` 打开工具栏，鼠标选择「*工具> 更新固件*」，就可以开始更新固件。\n\n![](../../assets/webduino/education_edition/update/upload_bbb1222a27c9694ab3b8a1a71515c837.png)\n\n如果检测到有新版本固件可供更新，也会在开发板连接电脑后弹出对话框提示。\n\n![](../../assets/webduino/education_edition/update/upload_46c7a296ad1a32710e18c8dfb11a2ceb.png)\n\n如果没有弹出对话框提示，也会在上方的信息文字里，出现提示更新的消息。\n\n![](../../assets/webduino/education_edition/update/upload_986d0f00a17dbae92eff4feb19c21ab2.png)\n\n点选更新后，会再度提示请勿关闭程序或移除 USB 线，按下确认后就开始更新。\n\n![](../../assets/webduino/education_edition/update/upload_ffc83447d7c649a0c51d19fe6b930632.png)\n\n更新时最上方的信息文字，会同步显示更新的进度。\n\n![](../../assets/webduino/education_edition/update/upload_d83789034c2b05d079e1d6a6b03477f1.png)\n\n更新直到 100% 之后会显示目前的版本号码，表示 开发板固件已经更新完成，如果没有反应请检查线材。\n\n![](../../assets/webduino/education_edition/update/upload_e994b6436ddb867b584438e86d7b29b4.png)\n\n## 恢复出厂固件\n\n如果一直是「扫描 USB 设备」（长达三分钟），没有出现连接成功的消息，则表示 Web:Bit 开发板的固件可能有问题，此时可以用鼠标选择「工具 > 恢复出厂固件」进行固件修复。\n\n![](../../assets/webduino/education_edition/update/upload_c50c3839f4d1fe1f8e60694b1c2813fb.png)\n\n连接成功的可忽略此步骤，恢复出厂固件可能会让 Device ID 不同，请特别注意！\n\n![](../../assets/webduino/education_edition/update/upload_c2ec7e8b5a7f87de903f5edf882fe41d.png)\n\n## 更新固件方法 2：通过 Wi-Fi 远程更新\n\n> 开发板联网需要先进行初始化，请查阅 [Web:bit 教育版 > 开发板设置](setup.html) 。\n\n远程更新 ( OTA ) 可以在开发板连上网络后，连接远程服务器更新获取最新版本固件，更新步骤如下：\n\n- 步骤 1、确认开发板已经可以正常连上 WiFi，若不行，请检查 WiFi 连接或重新进行初始化设定。\n- 步骤 2、断开开发板电源。\n- 步骤 3、连接开发板电源，**在显示白色跑马灯文字的时候，开始持续按住按钮A，直到开发板闪完红灯后没有亮绿灯表示失败，回到步骤 2 、直到出现绿灯熄灭后，此时会再听到蜂鸣器发出轻微的一个声响，此时放开按钮 A **。\n\n![](../../assets/webduino/education_edition/update/ota-06.gif)\n\n- 步骤 4、完成后会看到开发板的LED面板，由第一颗灯开始亮蓝灯，表示开始进行更新，*当蓝灯全部亮起接着熄灭后，表示更新完成*。\n\n![](../../assets/webduino/education_edition/update/ota-07.gif)\n\n- 步骤5、更新完成后开发板会闪红灯自动进行连接，连接成功会亮绿灯，接着绿灯熄灭，表示 OTA 更新固件完成。\n\n## 恢复出厂设置\n\n遇到奇怪的问题的时候无法解决，不妨试试还原硬件出厂时的设置，步骤如下：\n\n- 步骤 1、断开开发板电源。\n- 步骤 2、**同时按住按钮 A 和 B** 。\n- 步骤 3、连接开发板电源，**听到蜂鸣器发出声响后放开按钮 A 与 B**，此时开发板已经恢复出厂设置。 ( **恢复设定值会将自定义 XXX 的 Wi-Fi 帐号、密码、自定义的 Device SSID 和密码清除，这个步骤会造成开发板无法连接所在场所的 Wi-Fi** )\n- 步骤 4、重新进行初始化设定，请参考：[Web:bit 教育版 > 开发板设置](setup.html) 。"}, "/WebBit_doc/zh/webduino/education_edition/basic/math.html": {"title": "数学", "content": "# 数学\n\n数学积木包含了许多数学运算，从基本的加减乘除，到四舍五入、平均值、中位数...等应有尽有，无论是简单的程序或复杂应用，都能通过各式各样的数学运算实现。\n\n## 数学积木清单\n\n数学的积木分别有数字、运算、基础函数、加和、随机数和尺度转换...等常用的数学运算式。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_d1c8bbcfcd83e1a75e18857fdecc1b0f.png)\n\n## 指定数字\n\n「指定数字」积木用来让我们输入数字，可输入整数或是带有小数点的浮点数，常用于运算和判断。\n\n![](../../../assets/webduino/education_edition/basic/math/math-02.jpg)\n\n## 取得范围内随机整数\n\n「取得范围内随机整数」积木会指定一个数字范围，在每次执行这块积木时，就会从这个数字范围内取出随机的整数。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_29f3e4a7463190ae3f2a9e3b9f031e97.png)\n\n搭配「循环无限次」积木和「等待」积木，可以让小怪兽每隔一秒说出一个随机整数。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_1a99ebff4f17e890aedc046d6cdfbf13.gif)\n\n## 取得随机分数\n\n「取得随机分数」积木会在每次执行时，随机取得一个 0 到 1 之间的浮点数。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_6be241f338bec92416cfdf03610a8eda.png)\n\n搭配「循环无限次」积木和「等待」积木，可以让小怪兽每隔一秒说出一个随机浮点数。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_0e48c7c544fd464e89cf892aeab62892.gif)\n\n## 数学运算\n\n「数学运算」积木可以针对数字进行加、减、乘、除和乘方五种运算。\n\n![](../../../assets/webduino/education_edition/basic/math/math-07.jpg)\n\n如果使用多个数学运算的积木，需要注意的是*每个运算积木在计算上都会使用括号，类似的运算式有可能得到不同的结果*，例如下图积木看起来都是5 + 2 x 2，但因为括号位置的不同，得到的结果也不相同。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_6b2f08cc14fd02d7950cd02529ef2f82.jpg)\n\n数学运算除了可以放入数字，也可以用于变量的相加，例如指定变量 a 为 5，变量 b 为 3，通过数学运算就能算出 a + b 等于 8。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_849725911c5a02d0056710c11cc79394.png)\n\n## 取得余数\n\n「数学运算」积木可以取得两个数字相除所得的余数。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_1602c8514bc2334c227b4d36469d3644.png)\n\n## 限制数字范围\n\n「限制数字范围」积木可以设定最大值与最小值，并将数字限制在这个指定的范围内。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_e52951bf6667bf3c9391ee0a5e28ee4a.png)\n\n## 四舍五入\n\n「四舍五入」积木可以对带有浮点数的数字进行四舍五入、无条件舍去或无条件进位三种运算，同时亦可选择舍去或进位到第几位小数点。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_db4e9b77d848e83b2f870c91d64e7800.png)\n\n将需要四舍五入的数字，放在「四舍五入」的积木后方，就可以得到四舍五入之后的结果。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_07c8fc616442712daebf914cd03225aa.png)\n\n## 尺度转换\n\n「尺度转换」积木可以将某个尺度区间内的数值，转换为另外一个区间尺度对应数值。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_ca5150ec5033e3a47699a541d951e893.png)\n\n如下图， 0.5 为 0-1 尺度区间的数值，转换为 0-100 尺度区间得到的结果就是 50。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_38b30ddbe84c04c851b6e11b698fca8c.jpg)\n\n「尺度转换」积木可以帮助我们完成许多较为复杂的尺度转换，例如 0.5 位于 -5-5 之间，转换到 250-400 之间的数值就是 332.5。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_7cbbc2874028f217ed37ef0ef72b4c09.jpg)\n\n「尺度转换」积木常常会和「四舍五入」积木搭配使用，*建议将「四舍五入」积木放在尺度转换积木前方*，因为尺度转换后的数值有可能会带有小数点，转换后再四舍五入能得到较精确的答案。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_e1ce4490809efa423df2ed35e25c8b72.jpg)\n\n## 数组运算\n\n「数组运算」积木能针对以数字组成的数组，进行加总、取出最小值、取出最大值、计算平均值、取得中位数、取得比较众数、计算标准差和随机抽取的计算。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_bf129e0fe1b5b19e170e69dee966bba4.jpg)\n\n在数组运算后方接上数组积木，就可以开始行取值或运算。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_768f06c1ab0df9e9ac09b213cbdf6350.jpg)\n\n## 常用数学函数\n\n「常用数学函数」提供常用的数学计算积木，常用数学函数包含以下几种：开根号、绝对值、负数(-)、对数函数(ln)、log10 函数(log10)、指数函数(e^)和10 的几次方(10^)。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_d2fe94565c95ebfb3971d8fba23b8aed.jpg)\n\n## 三角函数\n\n「三角函数」积木里头提供了两种三角函数用法，分别是角度 ( sin、cos、tan ) 以及弧度 ( asin、acos、atan )，三角函数可以从下拉选单选择切换。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_23b0752c08190b8fb98414980f47d076.jpg)\n\n注意，因为JavaScript 网页语言特性，有些情况使用三角函数时，小数点后方会变成无限循环9999，例如sin(30) 应该等于0.5，出来却变成0.49999...，当遇到这种情况，需使用四舍五入的方式才能呈现预期的结果。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_e08b1a75c5af43eb95e965088d061f7b.jpg)\n\n## 常数\n\n「常数」积木会表现是一个不会变动的常数数值，常数包含了以下几种：圆周率(π)、指数(e)、黄金分割率(φ)、sqrt(2)、sqrt(½) 和无限大(∞)。\n\n![](../../../assets/webduino/education_edition/basic/math/upload_20dde89c350cda10c9fc1b08b0f242d7.jpg)"}, "/WebBit_doc/zh/webduino/education_edition/basic/text.html": {"title": "文字", "content": "# 文字\n\n文字积木除了可以显示有意义的词汇，也可以通过相加的方式把文字组合成文本（文本是由文字组成的），或是在一段词汇文本中寻找对应的字词或字母。\n\n在编程的领域中，文字即字符，字符是指计算机中使用的字母、数字、字和符号，文本即字符串，字符串是由一串字符组成。\n\n## 文字积木清单\n\n文字积木分别有指定文字、换行、转换大小写、建立字串、文字工具、文字查找、文字取代、文字转换...等常用的文字功能。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_5c03f0c1fd1c247a8c76419994cbbe5b.png)\n\n## 指定文字\n\n「指定文字」积木可以输入指定的文字，以便其他积木使用。\n\n![](../../../assets/webduino/education_edition/basic/text/text-02.jpg)\n\n例如在小怪兽讲话积木后方接上指定文字，输入 hello，执行后小怪兽就会说出 hello。\n\n![](../../../assets/webduino/education_edition/basic/text/text-03.jpg)\n\n## 换行\n\n「换行」积木可以将一段文字从指定的位置换行。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_d6a8bd61e12e54c7f3c5e3ad7a01a5da.png)\n\n## 建立文本\n\n「建立文本」积木可以把不同的文字积木组合成一段文本。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_4d6f5e42864bb06f88ca28ebadf3a48e.png)\n\n点击蓝色小齿轮，通过拖拉组合可以增加文字缺口。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_78bed0534676a80a7423dd603b2e4581.gif)\n\n在文字缺口内放入指定的文字积木或是换行积木，就可以让文字组合出想要显示的文本。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_d9ed1672b318256d9807c626ff9693ac.png)\n\n建立文本也可以用来组合两个变量，例如变量 a 为 hello，变量 b 为 world，通过建立文本就能将两个变量组合为中间换行的 hello world。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_362a69d6462aeb94b797a5625fd46b44.png)\n\n## 在变量后方加入文字\n\n「在变量后加入文字」积木能够改变原本变量的内容，使原本变量的内容后方额外增加文字。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_4c010ea08114476a13aa29499d3c1c10.png)\n\n因为是以「变量」为主，所以如果要让小怪兽讲话，就变成是使用变量的方式呈现。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_021201b6ae68c449d8395d9703d1e792.png)\n\n## 取代文字\n\n「取代文字」积木可以快速将一段文字里的某些字，替换为其他的文字，下拉选单可以选择更换第一个指定的文字，或所有指定的文字。 (取代文字不会对变量进行变更，而是产生一段全新的文本)\n\n![](../../../assets/webduino/education_edition/basic/text/upload_49a7f9cff19c7af7d963baa44dbad6bb.png)\n\n下图的例子可以只更换第一个「苹果」为「杨桃」，或是更换所有的「苹果」为「杨桃」。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_3f8739691e3973af97e356cf0e6de17b.png)\n\n## 寻找文本出现位置\n\n「寻找文本出现位置」积木可以在一段文本中找出指定文本出现的位置，可以选择第一个出现的位置或最后一个出现的位置。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_eebbd7dbcc332717aa401fc567f8619c.png)\n\n文字出现的位置是以「字数」来判断，以下图的例子，橘子的「橘」位于整段文字的第4 个位置，所以出现的数字为4，苹果的苹出现在第10 个位置，如果换成英文，orange 的o 位于第8 个位置，banana 的b 位于第16 个位置(逗号后面还有一个空格，空格算一个字符)。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_7b239d9fbc07c0bc8d35fa6bd420e84d.png)\n\n## 取得指定位置的文字\n\n「取得指定位置的文字」积木会取出文本中指定位置的文字，下拉选单共有五种指定位置，分别是第几个、倒数第几个、第一个、最后一个和随机位置。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_8556548d2e5e09c38e467238b62caa61.png)\n\n以下图的例子，第 4 个字是橘，第 11 个字是果。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_d23a1f6a85a95b0b688d13584547be27.png)\n\n## 取得指定区间的文本\n\n「取得指定区间的文本」积木会取出一段指定区间内的文本，需注意的是*第一个空格的数字要比第二个空格内的数字小*。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_459d558b111042bf3394fe484aeb4e57.jpg)\n\n以下图的例子，第 3~8 的文字为「、橘子、西瓜」，而第 8 到最后的文字为「瓜、苹果、香蕉、西瓜」。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_acc74ac1a1f548668e24207009839685.jpg)\n\n## 转换大小写\n\n「转换大小写」积木可以针对「英文字母」进行大小写转换，包含全部转大写、全部转小写或是首字母大写。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_30fe4ab135b86e23fc3541e801f35667.png)\n\n以下图的例子，可以全部转换为大写，或是只有第一个 A 是大写。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_9c985f296dbec4db22f7591469fc5777.png)\n\n## 消除空格\n\n「消除空格」积木可以消除一段文字中左边、右边或左右两边的空格。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_609a2bc25a8e60cbac6ad06a5b405702.png)\n\n## 进制转换\n\n「进制转换」积木能把数字转换为二进制、八进制、十进制或十六进制的数字。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_344dcf0486805fe6ab79aedc03abbd81.png)\n\n例如数字 200 转换为二进制就是 11001000，转换为八进制就是 310，转换为十六进制就是 c8。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_b0abca256a8565665b466e2068206fa5.png)\n\n## 文字长度\n\n「文字长度」积木可以取得一段文本的总字数，需要注意的是英文字以「字母」为单位，且空格也算是一个文字。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_84526e5790769135da11f6be58cec8a2.png)\n\n以下图为例，「一个苹果」的文字长度为 4，「An apple」因为包含空格，所以文字长度为 8。\n\n![](../../../assets/webduino/education_edition/basic/text/upload_1102ffa30013f5ca07d469657df9fec0.png)"}, "/WebBit_doc/zh/webduino/education_edition/basic/logic.html": {"title": "逻辑", "content": "# 逻辑\n\n逻辑是很多的条件和判断，当满足了某些条件就会执行某件事，例如听见闹钟响就该起床、看到绿灯才可以通过...等情况，就是一些简单的逻辑判断。在日常生活里，无论是写程序、数学计算，还是法庭辩论，甚至是路上交通、买卖东西或要不要起床，都包含许多「逻辑」的成分，\n\n## 逻辑积木清单\n\n逻辑的积木由一个主要的积木「如果...执行...」( 前方有蓝色小齿轮的积木)，分别搭配九种逻辑判断的积木( 判断、逻辑运算、数字型态、空值、包含值、真假值...等)组成。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_d74453b817d8cbc8f67420a7333056cb.png)\n\n## 逻辑判断\n\n「逻辑判断」积木预设有两种型态的组装「缺口」，在上方比较小的是「条件判断」 如果，下方比较大的是「执行内容」 执行，代表着*如果情况满足上方的条件判断( 判断返回值为「真」或「ture」 )，就会执行对应的内容*。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_16cadd8a887cd7d7c8571d29cb6dc5be.png)\n\n点选左上方的*蓝色小齿轮*，可以新增逻辑判断的条件，点一下可以打开，再点一下关闭。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_c1d95e67bf824e8681c654f61745add0.gif)\n\n逻辑条件判断有三种：*「如果」一定是在第一层，「否则如果」在中间，「否则」一定在最后*，「否则」的条件判断表示当「如果」和「否则如果」的条件都没有满足，就会执行「否则」的内容。如下图\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_5945cdf322fcb3bf5cabddaec5e06cc4.png)\n\n如果只有*两个条件*，例如非 A 即 B，只需使用「如果」和「否则」就可以。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_fbf73927c61a23deda1b01145a3de5a1.png)\n\n## 条件判断式\n\n条件判断式主要会放在逻辑的「条件判断」缺口内，提供不同情境的逻辑判断，判断的条件主要分为：等于(=)、不等于(≠)、小于(<)、小于等于(≦ )、大于(>)、大于等于(≧)。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_cb9448f68887c711b063359ef36932b8.png)\n\n用法：只要把条件判断式的积木，放到判断条件的缺口内即可。如下图\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_186028a15795813539076734ad9ff8f0.png)\n\n举例来说，可以先新增一个变量a 为0 到100 之间的随机整数，并让绿色小怪兽讲出数字，接着用逻辑判断，如果变量a 小于60 ( 返回判断为「真」(true) )，就让红色怪兽讲「不及格」，否则就讲「及格」，执行程序后就能看到对应的结果。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_eeaa27d92157eade277a5dcf36857317.png)\n\n## 逻辑运算符\n\n「逻辑运算符」积木为逻辑判断提供了更弹性的条件判断，当中包含了「*且*」与「*或*」，如果使用「且」，在两端判断的条件必须都满足时，才会执行动作，如果使用「或」，只要满足其中一个条件就会执行动作。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_8f782a8a26b0d48c224cea14db2e418c.png)\n\n通常当逻辑判断里出现「如果.否则」的时候，就会用到逻辑运算符，而逻辑运算符常常和条件判断的积木搭配使用。 ( 有时也会遇到只有「否则如果」搭配逻辑运算符的情况 )\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_42f9c58678c6331a73c6000333291869.png)\n\n以刚刚的例子来说，可以增加到四个条件判断，分别是 0、1~59、60~99 和 100，当条件判断成立时，就会让小怪兽说出数字以及对应的文字。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_e11ae559f854d5034ee6a9400629a365.png)\n\n## 判断数字型态\n\n「判断数字型态」积木可以帮助我们快速判断*奇数、偶数、整数、数字有小数点、文字和数组*。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_d6587c54a4a8a374d8c3526cce3d3080.png)\n\n用法：只需直接放入条件判断的缺口内即可。如下图\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_b154c49ccea77e77c9a8018d8a4e6c3c.png)\n\n例如我们可以设定变量 a 为两个随机数相除，再通过小怪兽讲出整数或小数。 ( 除法的积木使用了「多行输入」，可以在积木上按右键选择多行输入，教学参考：[程序积木小技巧](../software.html#-8)\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_32bdf404013aa3ff57dbfd13ec0cba63.jpg)\n\n## 判断空值\n\n「判断空值」积木主要是和「数组」积木搭配，*如果是空值返回「真」(true)，否则返回「假」（false）*。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_940a527a986f027d4312a3e3f9f908e6.png)\n\n会产生空值有几种情况：「*无文字、数字0、空数组、空值、「假」（false）、没有值的变量*」，如果满足这几种情况，就会返回「真」(true) 。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_d3859a77c9c8d2f118e63f93daad933b.png)\n\n## 判断是否包含文字\n\n「判断是否包含文字」积木可以检查某段文字内，是否*包含*了指定的文字或文字段落。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_e19fc6c7bb1646e1c55ae7742d71f5ea.png)\n\n举例来说，如果检查「你是我的小呀小苹果」里面有包含「小苹果」，绿色怪兽就会说「找到小苹果了」，反之如果是「小柠檬」，红色怪兽就会说「没有小柠檬」。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_db8ca02956d5db204ba27bc507384141.jpg)\n\n## 非\n\n「非」积木就如字面一样，表示「否」，通常会和「真/假」或「空值」的积木搭配使用。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_8e537cdd9a0fbe90e1305185cedc64c5.png)\n\n如果把积木接在「非」的积木后面，状态就会反过来，例如空就会变成非空（不是空的）、真就会变假，假就会变真，以此类推。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_4594830254e82507a032e5679cac1ddc.jpg)\n\n## 真/假\n\n「真/假」积木主要表示「真」(true) 与「假」（false） 两个值，目的在判断的时候，在数字、文字之外，多一些判断的条件。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_48176ba391825c26aaef72b3595b60be.png)\n\n## 空\n\n在写程序的时候，有时候会遇到某个变量或是某个数值变成空值 ( null )，这时就可以使用空值的积木判断，用法和「真/假」的用法类似。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_810b05b8276ef7170332561e0d1e94b8.png)\n\n## 三元逻辑运算符\n\n「三元逻辑运算符」积木是针对只有「*两种条件*」的问题，并针对根据条件传回「两个运算式」的其中一个。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_f62416838b47bcaf4ef9a3085dad9247.png)\n\n比如上面提到的及格与不及格的例子，因为只有两种条件，就可以通过三元逻辑运算符来轻松实现，且还可以使用比较少的积木来完成同样的结果。\n\n![](../../../assets/webduino/education_edition/basic/logic/upload_e71e8699fedf0988d8a4d0b7a122f5d1.jpg)"}, "/WebBit_doc/zh/webduino/education_edition/basic/color.html": {"title": "颜色", "content": "# 颜色\n\n通过颜色积木，可以改变小怪兽互动舞台的颜色，或指定实体开发板矩阵 LED 的灯光颜色。\n\n## 颜色积木清单\n\n![](../../../assets/webduino/education_edition/basic/color/upload_90684cbefd049b2c7f29bf1d66f7af70.png)\n\n## 指定颜色\n\n「指定颜色」积木可以让我们通过色彩选取面板，选择对应的颜色。\n\n如果我们指定小怪兽互动舞台的背景为红色，那么执行后，舞台背景就会变成红色。\n\n![](../../../assets/webduino/education_edition/basic/color/upload_b6df48315ec88021377d9f3093e9ef79.png)\n\n## 随机颜色\n\n「随机颜色」会在每次执行时，随机从各种颜色中取出一种颜色显示。\n\n![](../../../assets/webduino/education_edition/basic/color/upload_62ecdea1b9ed30c1bd93fec9600df9c4.png)\n\n如果搭配循环执行后，就能看到小怪兽舞台背景的颜色不断随机变化。\n\n![](../../../assets/webduino/education_edition/basic/color/upload_67a8f84a9ce43b92f130c1155cc613d9.gif)\n\n## RGB 三原色\n\n「RGB 三原色」积木能够指定积木中三原色的数值，直接通过数值来呈现不同的颜色。\n\n> 三原色表示 *红色(Red)、绿色(Green)、蓝色(Blue)*，三种颜色分别有 256 种从暗到亮的变化，透过三种颜色的混合，就能产生一千六百多万种的颜色。 ( 但人的眼睛无法分辨这么多种颜色 )\n\n![](../../../assets/webduino/education_edition/basic/color/upload_257fcab98503c20529714b930af799f2.png)\n\n因为颜色有 256 种，对应的数值就是 0 ~ 255，0 是最暗，255 是最亮，输入对应的数值就能产生对应的颜色，举例来说红色 255 搭配绿色 255 就会是黄色。\n\n> 通常的三原色为「*色光*」，*红色 + 绿色 = 黄色*，*绿色 + 蓝色 = 青色*，*红色 + 蓝色 = 紫色*。\n\n![](../../../assets/webduino/education_edition/basic/color/upload_26a1d5197486dfc82517dfef78aa935e.png)\n\n搭配循环积木，就能够做出红色到黄色的颜色转换效果。\n\n![](../../../assets/webduino/education_edition/basic/color/upload_f0478b8767b710d98996e73c7ff96844.gif)\n\n## 混合颜色\n\n「混合颜色」积木是指两种颜色积木按照比例混合产生新的颜色，比例为 0~1 之间的数值，数字越小颜色越接近颜色 1，数字越大颜色越接近颜色 2。\n\n如果把颜色 1 设定为红色，颜色 2 设定为蓝色，比例 0.2 的混合颜色就是偏红色的紫色。\n\n![](../../../assets/webduino/education_edition/basic/color/upload_8285c81813b251c1d153ca10d771b3db.png)\n\n搭配循环积木，就能够做出从红色到蓝色的颜色转换效果\n\n![](../../../assets/webduino/education_edition/basic/color/upload_75393c4e2ad3efe1989f87f9906739aa.gif)"}, "/WebBit_doc/zh/webduino/education_edition/basic/function.html": {"title": "函数", "content": "# 函数\n\n在计算机中，函数是指一段在一起的、可以做某一件事儿的程序。\n\n函数积木可以帮助我们简化或管理较为复杂的程序逻辑，因为在写程序的时候，常常会遇到需要重复编写并执行的程序积木，如果每重复一次都得重写一次，就会导致整份程序逻辑的混乱复杂，通过函数可以将这些重复的程序集中管理，需要使用的时候再去调用函数，就可以执行内部对应的程序。\n\n## 函数积木清单\n\n![](../../../assets/webduino/education_edition/basic/function/function-01.jpg)\n\n## 建立函数\n\n「建立函数」积木可以将许多重复会用到的程序积木包装成函数。\n\n![](../../../assets/webduino/education_edition/basic/function/function-03.jpg)\n\n使用建立函数积木*并不会执行函数*，因为函数是*定义「需要执行的内容」*，建立完成函数积木内容后，在函数积木的目录里，就会出现对应的*执行函数积木*，当去使用这块积木才表示执行这个函数。\n\n![](../../../assets/webduino/education_edition/basic/function/function-02.jpg)\n\n下图建立了 a 和 b 两个函数之后，调用*函数 a 和 b*，执行后，绿色小怪兽就会说出苹果，红色小怪兽就会说出香蕉。 ( *如果单纯只有建立函数而不拉取出来调用，执行后什么事情都不会发生* )\n\n![](../../../assets/webduino/education_edition/basic/function/function-05.jpg)\n\n除了单纯的使用函数，我们也可以建立「*函数内的参数变量*」，点选函数积木前方的小齿轮，就可以新增参数变量。\n\n![](../../../assets/webduino/education_edition/basic/function/function-06.gif)\n\n新增函数内的参数变量后，执行函数时也会看到放入变量数值的缺口。 ( 函数内有几个参数变量就会有几个缺口 )\n\n![](../../../assets/webduino/education_edition/basic/function/function-07.jpg)\n\n函数内的参数变量让程序增加了许多弹性，并也可以减少许多重复的程序，举例来说，通过函数和函数内参数变量，就能做出提供参数变量数值，并算出数值总和的函数。\n\n![](../../../assets/webduino/education_edition/basic/function/function-08.jpg)\n\n## 建立带有返回值的函数\n\n「建立带有返回值的函数」积木可以让执行的函数，变成单纯的数值，这对于一些复杂的程序应用相当有用。\n\n![](../../../assets/webduino/education_edition/basic/function/function-09.jpg)\n\n如果使用的是「建立带有返回值的函数」，就会发现执行函数时积木前方多了一个作为组合用的形状。 ( 下图是一段建立带有函数的参数变量的函数 )\n\n![](../../../assets/webduino/education_edition/basic/function/function-10.jpg)\n\n通过函数的参数变量，搭配函数返回的数值，就能做到依据提供的变量数值不同 ( x、y 不同值 )，而产生不同的结果。\n\n![](../../../assets/webduino/education_edition/basic/function/function-11.jpg)\n\n## 在函数内判断并返回值\n\n「在函数内判断并返回值」积木必须和「建立带有返回值的函数」的积木搭配，主要作为判断后要返回什么数值使用。 ( 这个积木也必须放在函数内才能正常运作，如下图示例用法。)\n\n![](../../../assets/webduino/education_edition/basic/function/function-12.jpg)\n\n通过这个积木，搭配函数内的变量，就可以通过传入的变量数值，最后返回 x 和 y 哪个比较大的结果。\n\n![](../../../assets/webduino/education_edition/basic/function/function-13.jpg)\n\n因为「函数内判断并返回值」积木具备逻辑判断的功能，所以也可以使用逻辑积木加上一个变量来做判断，就能做出一模一样的效果。\n\n![](../../../assets/webduino/education_edition/basic/function/function-14.jpg)"}, "/WebBit_doc/zh/webduino/education_edition/basic/array.html": {"title": "数组", "content": "# 数组\n\n数组可以将数字、文字、列表或变量，按照顺序组合起来，这些按序排列的集合就称作数组，一个数组可以再细分为多个元素，或是一个数组内还包含其他数组，在进行比较复杂的运算时，也会通过数组的一些操作来实现。\n\n## 数组积木清单\n\n![](../../../assets/webduino/education_edition/basic/array/01.png)\n\n## 空数组\n\n「空数组」积木会建立一个数组容器，也就是里面没有包含任何元素的数组。\n\n![](../../../assets/webduino/education_edition/basic/array/02.png)\n\n如果要用变量进行数组的操作，首先必须把这个变量定义为数组或空数组，才能针对这个变量进行数组数值的添加、删除、编辑...等动作。\n\n![](../../../assets/webduino/education_edition/basic/array/03.png)\n\n## 建立数组\n\n「建立数组」积木可以在指定位置放入许多对应的内容，建立一个可以链接各类内容的数组。\n\n![](../../../assets/webduino/education_edition/basic/array/04.png)\n\n点击蓝色小齿轮 ⚙ ，可以增加更多可放入内容的缺口。\n\n![](../../../assets/webduino/education_edition/basic/array/05.gif)\n\n这个数组建立完成后，可以试着让小怪兽讲出这个数组（数组的内容会用逗号分隔）。\n\n![](../../../assets/webduino/education_edition/basic/array/06.png)\n\n或是可以使用下述积木，从数组中取出每个内容，并依序讲出数组内容。\n\n![](../../../assets/webduino/education_edition/basic/array/07.gif)\n\n## 建立重复内容的数组\n\n「建立重复内容数组」积木可以建立具有重复内容的列表，内容可以是变量、文字、数字或数组，将其放入缺口内，就会根据设定的内容建立数组。\n\n![](../../../assets/webduino/education_edition/basic/array/08.png)\n\n效果就是让「芭乐」文本词汇重复建立五次并添加到数组中，这时候绿色小怪兽就会念出五次「芭乐」。\n\n![](../../../assets/webduino/education_edition/basic/array/09.png)\n\n## 设定数组内容\n\n「设定数组内容」积木可以针对数组的内容 ( 第几个、倒数第几个、第一个、最后一个和随机 ) 进行三种编辑行为 (也就是设定、插入或移除 )。\n\n![](../../../assets/webduino/education_edition/basic/array/10.png)\n\n举例来说，假设一个数组有四种水果苹果、柳丁、香蕉和芭乐，通过「设定数组内容」积木将数组中第一个水果元素换成莲雾，这时候 绿色小怪兽 讲出数组的第一个水果就变成了莲雾，然后试试移除数组的第二个内容，此时红色小怪兽讲出的数组就会变成只有三种水果（莲雾、香蕉和芭乐）。\n\n![](../../../assets/webduino/education_edition/basic/array/11.png)\n\n接着使用「插入」文本桃子在「最后一个」，就可以看到数组又变成四种水果，最后一种是桃子。\n\n![](../../../assets/webduino/education_edition/basic/array/12.png)\n\n## 取得数组内容\n\n「取得数组内容」积木可以取得一个数组中某个元素的值( 第几个、倒数第几个、第一个、最后一个和随机)，或是取得某个元素的值之后，同时移除该元素。\n\n![](../../../assets/webduino/education_edition/basic/array/13.png)\n\n如果单纯取得某个元素的值，并不会影响原本数组的内容和长度，但如果是「取得并移除」，这个数组就不再包含这个元素，例如一开始有四种水果，如果只是取得内容，取得内容后的数组依然是四种水果，不过如果取得后移除内容，取得内容之后数组就变成了只有三种水果。\n\n![](../../../assets/webduino/education_edition/basic/array/14.png)\n\n## 寻找数组内容\n\n「取得数组内容」积木能从一个数组中，找到特定元素所在的位置，并回传该位置的编号。\n\n![](../../../assets/webduino/education_edition/basic/array/15.png)\n\n通过取得数组积木来取得水果数组，就能知道**苹果**位在第一个位置、**柳丁**位在第二个位置、**香蕉**位在第三个位置、**芭乐**位在第四个位置。\n\n> 务必注意，如果是「代码」而非使用「积木」，第一个位置通常都是 0 ，第二个位置是 1 ，但是为了和生活习惯保持一致，在积木中的第一个位置的显示为 1 ，第二个位置为 2 ，以此类推。\n\n![](../../../assets/webduino/education_edition/basic/array/16.png)\n\n## 数组排序\n\n「数组排序」积木会将指定的数组内容按字母、数字的规则进行排序，排序后会得到一个新的数组，*不会影响原本数组的内容*。\n\n![](../../../assets/webduino/education_edition/basic/array/17.png)\n\n从下图的例子可以看出，绿色小怪兽会讲出按照字母排序过后的水果数组( a, b, c, .... )，而红色小怪兽讲出原本的水果数组并没有受到数组排序积木的影响。\n\n![](../../../assets/webduino/education_edition/basic/array/18.png)\n\n如果选择字母排序，就会「*先按照字母大小写排序，大写在前，小写在后，排序后再按照第二个字母排序*」，如果选择不区分大小写，就会直接进行排序，「 *如果第一个字母相同，就用第二个字母排序*」，以下图的例子，大写 A 在前，小写 a 在后，排序后再按照 123、456 进行排序。\n\n![](../../../assets/webduino/education_edition/basic/array/19.png)\n\n## 文本与数组转换\n\n「文本与数组转换」积木可以将带有「分隔符」( 类似空白、逗号、分号...等分隔符号 ) 的文本转换为数组，或是将数组合并为一段文本。\n\n![](../../../assets/webduino/education_edition/basic/array/20.png)\n\n如果一段文本没有变成数组，其中第二个元素就会是第二个字( 绿色小怪兽就会讲出「果」 )，如果将文字拆分为数组，第二个元素就会是数组中的第二个内容( 红色小怪兽就会讲出「橙子」 )。\n\n![](../../../assets/webduino/education_edition/basic/array/21.png)\n\n反之如果是将数组合并为文字，可以将分隔符留空，就会看见数组的内容变成一整串的文本，中间不会有逗号分隔，如果带有分隔符( 例如 a )，就会看见结合成的文字中间都有 a 。\n\n![](../../../assets/webduino/education_edition/basic/array/22.png)\n\n## 数组长度\n\n「数组长度」积木可以取得数组中内容的总数，如果是空数组则数组长度为 0 。\n\n![](../../../assets/webduino/education_edition/basic/array/23.png)\n\n因为数组长度表示的是「数组的缺口数」( 数组可以放入多少个元素)，所以如果「有缺口」但没有放入元素，仍然会影响数组长度，例如有个四格缺口的数组，但只放入了三种水果，最后呈现出来的数组长度是 4 。\n\n![](../../../assets/webduino/education_edition/basic/array/24.png)"}, "/WebBit_doc/zh/webduino/education_edition/basic/variables.html": {"title": "变量", "content": "# 变量\n\n变量，是所有程序都会用到的基本元素，使用前会赋予变量一个名称，接着就可以用这个变量来表示文字、数字、数组、颜色或逻辑。\n\n## 新增变量\n\n使用变量的第一步，就是「新增一个变量」，打开编辑器，将「*设定变量为*」的积木拖拉到积木编辑区中，下拉选单选择「*新变量*」，点选后弹出对话视窗，输入新变量的名称即可新增一个变量。如下图 ( 建议变量的命名尽可能以「英文 + 数字」为主 )\n\n![](../../../assets/webduino/education_edition/basic/variables/upload_692cb4676e22fabba168b81fd4fc8942.png)\n\n在新增的变量后方加上对应的值 ( 值可以是文字、数字、数组、颜色或逻辑 )，这个变量就等同于这个值，如果没有赋予值，这个变量就是空变量。\n\n![](../../../assets/webduino/education_edition/basic/variables/upload_91de3aa8dd28541f92a746d5d80dc9b2.png)\n\n新增变量后，在左侧积木清单的变量目录下，也会看到新增的变量积木。\n\n> 注意，如果在编辑画面里完全没有「设定变量为 XXX」的积木，积木清单里就不会看见 XXX 的变量积木。\n\n![](../../../assets/webduino/education_edition/basic/variables/upload_0247f43ea7b357bccf0312d532cec450.png)\n\n## 设定变量\n\n设定变量表示赋予变量一个值，使用方式和新增变量完全相同，由于程序语言有「*后面覆盖前面*」的特性，所以*如果变量名称相同，后面设定的值会覆盖掉前面设定的值* ，以下图的例子而言，变量apple 最后的值为456。\n\n![](../../../assets/webduino/education_edition/basic/variables/upload_4252b4401f914b7e136be1e5d5eb65fc.png)\n\n## 重新命名变量\n\n区别于「新增变量」，重新命名变量可以将画面中所有相同的变量统一改名，例如画面里出现了四次 apple 的变量，通过重新命名，可以将四个 apple 变量名称全部换成 ball。\n\n![](../../../assets/webduino/education_edition/basic/variables/upload_0a808a5d0cba23367ada8f2e0ca1045a.gif)\n\n## 变量增加\n\n变量增加表示「*让变量的值增加多少*」，假设原本变量的值为 1 ，使用变量增加 1 之后，这个变量就会加 1 变成 2 ，同理，如果使用变量增加 -1 ，那么这个变量就会加（-1）变成 0 。\n\n![](../../../assets/webduino/education_edition/basic/variables/upload_974c14c2cab0fa43e48c69fa8f230a60.png)\n\n注意，如果是不同类型的改变，例如原本的变量是文字「苹果」，却增加 数字「1」，最后得到的结果是「苹果1」三个字，同理如果变量是数字「1」，而增加文字「苹果」，得到的结果是「1苹果」。\n\n![](../../../assets/webduino/education_edition/basic/variables/upload_4e99e403bd636d4708affc09d34547a2.png)\n\n## 使用变量\n\n新增变量或设定变量完成后，就可以在积木编辑区中使用变量，以下图为例，先设定a 变量为1，b 变量为2，接着就能计算a + b 或a ÷ b 之类的数学运算，或进行判断a 和b 哪个值比较大的逻辑判断。当程序逻辑越来越复杂，就得通过变量来操作。\n\n![](../../../assets/webduino/education_edition/basic/variables/upload_af5c87709a5df7b84a596578ebf61373.png)"}, "/WebBit_doc/zh/webduino/education_edition/basic/loop.html": {"title": "循环", "content": "# 循环\n\n在程序领域里，循环 是常常使用的基本功能，循环就是循环执行程序，将需要循环执行的积木放在循环积木内，就能循环指定次数、延迟循环时间，或是执行无限次循环积木。\n\n## 循环积木清单\n\n循环的积木分别有一个「等待」的积木，五个不同循环模式的积木和一个「停止循环」的积木。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_ca6884696c2d35d55891c84efe72d3e3.png)\n\n## 等待\n\n「等待」积木可以让程序暂停一段指定的时间，当程序积木里遇到「等待」积木，就会等待指定的时间之后才会进行后面的动作。\n\n![](../../../assets/webduino/education_edition/basic/loop/loop-23.jpg)\n\n以下方的例子来说，如果不加上「等待」，四只小怪兽会同时说出 hello，如果加上等待 1 秒，四只小怪兽就会以每隔一秒时间，依序说出 hello。\n\n- 没有加上「等待」积木\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_a56e532f444f10f1b63e0a204061e30b.png)\n \n > 注意，上述所谓的「同时」，是针对人类肉眼来说的意思，对于程序而言仍然是按照顺序进行，只是间隔时间非常短，短到人类的肉眼分辨不出来\n \n- 加上「等待」积木\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_293de1e01c5e037871f6163c6558dc73.gif)\n\n## 循环执行几次\n\n「循环执行几次」积木，可以指定循环内的积木所循环的次数，积木预设次数为 10 次。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_f79542ae68a6272f380d047e89a50d73.png)\n\n通过循环10次，可以让小怪兽旋转 100 度。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_d127a673a65ffa14a8d0bc1850e227d8.png)\n\n延续前面介绍过的「等待」，如果在循环里头不加入「等待」，就会看见怪兽瞬间旋转了100 度，如果我们再加上等待0.5 秒的积木，就会看到怪兽每隔0.5 秒旋转10 度，旋转十次。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_6581350ae4072c6853deb40ba6c1b8715.gif)\n\n## 计数循环\n\n「计数循环」积木有点类似「循环执行几次」积木的进阶版，差别在于计数积木使用了一个变量，通过改变这个变量的数值，来决定循环几次、如何循环以及循环的间隔。\n\n> 如下图,因为内含一个变量，所以当编辑画面里有计数的积木，在变量的目录下也会出现一个对应的变量i。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_931c65737aff90e055172a2bc1b0046f.png)\n\n使用「计数循环积木搭配等待」，可以让绿色小怪兽每隔0.5 秒讲出变量i 的数值，这个变量i 会*根据我们指定的起始数值、最终数值和间隔作数值进行递增或递减*，以下图的例子而言，变量i 会每隔0.5s 进行加1，直到变成10 为止( 也就会依序念出1234...10 )。\n\n> 注意，*如果要「依序」念出数字，一定要加上「等待」的积木*，不然就会呈现最后的数字。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_908d5656340dfec2d3493cb91b4bb0fc.gif)\n\n## 循环无限次\n\n「循环无限次」积木会无止尽的一直执行循环积木内容，除非使用「停止循环」积木，循环的事件才会停止。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_e31a0f641fd9e1812671054b40556bf5.png)\n\n延续前面介绍过的等待，在「循环无限次」的积木内加入「等待」，搭配小怪兽的旋转，就可以让小怪兽不断地旋转。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_d170f481f8ae8aacb7857631becdff80.gif)\n\n## 判断为真，就循环无限次\n\n「判断为真，就循环无限次」积木等同于「循环无限次」积木加上「逻辑」判断，*只要 如果 后面缺口的逻辑判断为「真」( true )，就会开始进行无限循环*。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_4d24b8aba98c0f9b641ca205da27a3c5.png)\n\n举例来说，我们可以先设定一个变量 a 为 2 到 9 之间的数字，透过判断如果 a 是偶数，就让小怪兽开始旋转，否则就不旋转。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_382e2b22cb51186e60dad591d1381be4.gif)\n\n上面的例子也可以使用「逻辑」搭配「循环无限次」来实现同样的效果。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_a2efd4f119a98ec24fe026edc06ac3a1.png)\n\n## 取数组元素并执行\n\n有别于上述的循环方式，「取出数组元素并执行」积木是以数组长度作为循环次数的依据，因此数组后面缺口内必须放入数组积木，执行后就会依序取出数组内容并执行对应动作。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_5ce25b86a4d39f1a5a9eb37ce0e55b86.png)\n\n如下图，我们可以设定变量 a 为一个数组，里头放入五种水果名称，接着设定一个变量 i，依序让变量 i 等于水果名称，再让小怪兽讲出水果名称并进行旋转的动作。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_8578fd8cf709d07c7f0ce194d2675365.gif)\n\n## 后台执行\n\n「后台执行」是所有循环积木里头的功能选项，由于程序码的执行顺序缘故，「**前一段程序尚未完成前，无法执行下一段程序**」，也因此*大多数的情况在画面上只能执行一个循环*，然而后台执行**可以同时使用多个循环**。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_89cb190849c5f3c10505ab4408333d8b.png)\n\n举例来说，如果我们使用两个「循环十次」的积木，都*不勾选后台执行*，第一个放入小怪兽旋转，第二个放入小怪兽移动，网页执行后，就会看到小怪兽*先旋转再移动*。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_2e869e3909426065dbe1f26797fed529.gif)\n\n如果我们把上面例子中的循环积木，*都勾选后台执行*，网页执行后就会发现小怪兽*一边移动一边旋转*。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_fca308cfb10229cf2cb36d2604d51c3e.gif)\n\n是否有后台执行，在「循环无限次」的情况下会更容易发现差异，**如果画面中有两个无限次的循环，如果没有勾选后台执行，因为行为还停留在前一个无限次循环，在后面的循环就不会执行**。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_7379ccd91a2ab2e57d15a51dbcef0c62.gif)\n\n## 停止循环\n\n上述所有的循环行为，都可以通过「停止循环」积木来停止，停止循环又分成「*停止画面上所有循环*」，或「*放在循环内，停止所在位置的循环*」。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_b1817a24a19b730c925b2f0c4af96e26.png)\n\n例如在「循环无限次」积木里加入「小怪兽旋转角度大于 90 度就*停止这个循环*」的判断，就会在小怪兽角度大于 90 度时停止循环，继续执行下方的讲话程序。\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_7ce353ec6f92ec9ac4b9cc2bae786417.gif)\n\n如果有多个循环，也可以使用「停止所有循环」来停止，例如下方的程序，当小怪兽旋转角度大于 90 度，就会停止所有循环。 ( 此处勾选了后台执行，请参阅「[后台执行](loop.html#-9)」章节 )\n\n![](../../../assets/webduino/education_edition/basic/loop/upload_55f343e086261afb02b6988c542ea8f3.gif)"}, "/WebBit_doc/zh/webduino/education_edition/network/broadcast.html": {"title": "网络广播", "content": "# 网络广播\n\n网络广播功能，不仅能让与开发板彼此交换信息，更可以实现一对多、多对一、虚实互动、远距广播...等多样化的操控，通过广播功能的实现，便能将物联网的应用发挥到极致。\n\n## 广播积木清单\n\n广播积木包含一块负责发送广播消息的积木、一块负责接收广播消息的积木和一块呈现广播消息的积木。\n\n![](../../../assets/webduino/education_edition/network/broadcast/upload_66313af34ac597a959f48048083c90b8.png)\n\n## 发送广播消息\n\n「发送广播消息」积木可以指定一个频道名称，以及要向这个频道发送的文字，只要频道名称相同，所有在该频道上的装置或人员，都能收到广播消息，*发送广播消息不限制只有实体装置能发送，不论是实体装置、虚拟装置、没有开发板的程序...等，都能够向指定频道发送消息*。\n\n> 「发送广播消息」积木属于「*发送完成才会继续执行后面程序*」的类型( 点击前方问号会提示)，当编辑画面中有这块积木，*执行时当程序遇到这块积木会暂停，直到发送完广播消息后才会再继续*。\n\n![](../../../assets/webduino/education_edition/network/broadcast/upload_3d0b521e0853faeef5db3cce155ccedb.png)\n\n## 接收广播消息\n\n「接收广播消息」积木可以指定一个频道名称，就能不断收听这个频道的变化，只要有人或开发板向这个频道发送消息，就能够通过广播消息的积木显示，*接收广播消息不限制只有实体装置能接收，不论是实体装置、虚拟装置、没有开发板的程序...等，都能够接收指定频道的消息*。\n\n> 「接收广播消息」积木属于「*不间断收听频道*」的类型 ( 点击前方问号会提示 )，不需要放在循环内，就会不断地收听频道消息。\n\n![](../../../assets/webduino/education_edition/network/broadcast/upload_aee7d86e61092d779b2de4f4d544ce06.png)\n\n举例来说，使用者A 可以在「点击小怪兽」的同时，向频道test 发送广播消息，而使用者B 和C 负责收听test 频道，如果有收到，就让的小怪兽显示收到的广播消息。\n\n![](../../../assets/webduino/education_edition/network/broadcast/upload_0b91bc8997597950c81a08b6ff9c4da5.gif)\n\n又或者可以使用 开发板的按钮开关，按下 A 的时候向 test 频道发送文字 A，按下 B 的时候发送文字 B。\n\n![](../../../assets/webduino/education_edition/network/broadcast/upload_6d03b662089ad7597383e722fcba85a1.png)\n\n收听 test 频道的的开发板可以撰写逻辑判断，当收到 A 的时候显示红色的 A，收到 B 的时候显示蓝色的 B。\n\n![](../../../assets/webduino/education_edition/network/broadcast/upload_1787d5ea745207986a66096b047dc097.png)\n\n两块开发板的程序都执行后，点击负责发送广播的开发板的按钮开关，就可以看到另外一块开发板显示对应的消息。\n\n![](../../../assets/webduino/education_edition/network/broadcast/broadcast-07.gif)"}, "/WebBit_doc/zh/webduino/education_edition/setup.html": {"title": "开发板设置", "content": "# 开发板设置\n\n在往下使用开发板的 WIFI 联网功能之前，需要先进行初始化设置，通过本节的初始化设置可以让开发板可以连上网络（Internet），还可以够自定义开发板的 WIFI 显示名称和密码，更是可以通过网络进行远程更新（OTA）。\n\n> 初始化后可以**通过「Wi-Fi」控制开发板**，如果只是使用「USB 控制」开发板，则可以跳过初始化设置。\n\n## 初始化方法 1：使用安装版进行初始化\n\n> 什么是安装版？点此查看 [Web:bit 教育版 > 编辑器介绍 > 安装版](software.html#-5) 。\n\n使用安装版按照下列步骤进行初始化设置。\n\n### 步骤 1、进入菜单 > 工具 > 设置 Web:bit WIFI\n\n将开发板通过 Micro USB 线连接电脑，打开安装版后，软件顶栏会出现安装版的「版本号（如：V1.2.4）」以及「扫描 USB 设备」的提示（如下图），此时可以将开发板通过 USB 线连接电脑，让软件进行自动扫描并连接开发板。\n\n![](../../assets/webduino/education_edition/setup/upload_3f793de122644f3c4fb1f17de0bcc634.png)\n\n连接到开发板后，*软件顶栏会出现开发板的 Device ID 以及固件版本号*（如下图），接着查看菜单栏（没有看到需要按下键盘的*`Ctrl + W`* 开启），用鼠标选择「*工具> 设置 Web:bit WiFi*」，开始进行初始化设置。\n\n![](../../assets/webduino/education_edition/setup/upload_c792e42e263f5a843da6255867d1a77f.png)\n\n> *注意！没有出现如图连接情况，请使用 [Web:bit 教育版 > 更新开发板固件 > 恢复出厂固件](update.html#-2)。\n\n### 步骤 2、设置 Web:bit Wi-Fi 的名称（SSID）与密码\n\n点击设置 WiFi 后，会弹出一个对话窗，此时要填入想要连接的 WiFi 的名称和密码。 ( 这里就填入自己所在场所(例如：公司、学校或家里）的 Wi-Fi 帐号和密码 )\n\n设置 WIFI 连接的名称（SSID），存在配置则会读回，默认值是 `webduino.io` 。\n\n![](../../assets/webduino/education_edition/setup/upload_621ed89a98ab4e189626b6f46381ddd5.png)\n\n设置 WIFI 连接的 密码 ，存在配置则会读回，默认值是 `webduino` 。\n\n![](../../assets/webduino/education_edition/setup/upload_3e99dc9aeb3caa3e2793b1528718f1e0.png)\n\n设置完成后，会弹出一个对话窗口，询问是否关闭 USB 连接，如果选择「确定」，开发板就会通过先前的 Wi-Fi 的帐号与密码，连接到指定的 Wi-Fi ，如果选择「取消」，就会关闭 Wi-Fi 连接功能，此时只能使用 USB 连接操作。\n\n![](../../assets/webduino/education_edition/setup/upload_4b45f7eb17a57e6a31f1d483db93047e.png)\n\n若选择关闭 USB 连接功能，开发板会进入 WIFI 连接模式。\n\n此时开发板会重启并闪烁红灯，当 **红灯熄灭** 且 **绿灯亮起** 之后，表示 Web:Bit 开发板已经成功连接上 WiFi 。\n\n![](../../assets/webduino/education_edition/setup/upload_9fc275139e019a3ba9f86d0fd133c762.gif)\n\n- 若红灯持续闪烁或恒亮，请拔掉电源，重新操作步骤 1 与步骤 2 。\n\n- 若红灯闪完后亮起「蓝灯」而不是绿灯，表示已有新版本可以进行下载更新，请参考[Web:bit 教育版 > 更新开发板固件](update.html#-1) 。\n\n![](../../assets/webduino/education_edition/setup/upload_184a8ab60565dbd34c2e4cac4a0a530b.gif)\n\n## 初始化方法 2：WIFI 连接到开发板进行初始化\n\n如果想通过无线控制开发板，可以通过有 Wi-Fi 连接功能的笔记本电脑或移动设备（手机），连接到开发板的 WIFI 热点进行初始化设置，相关步骤如下所示：\n\n### 步骤 1、接上电源，输入 WiFi 帐号和密码进行连接\n\n使用 USB 线为开发板接上电源，此时开发板正面的 矩阵 LED 会滚动显示一串文字( *默认是 bit 三个英文 + 四个数字* )，如下图的滚动显示的 bit1234 。\n\n![](../../assets/webduino/education_edition/setup/setup-05.gif)\n\n这串文字会出现在其他可以连接 WIFI 的设备的 WiFi 名称列表中，例如下图显示的 bit1234 ，在 WiFi 搜索界面中就会看到 bit1234 的 WIFI 名称。\n\n![](../../assets/webduino/education_edition/setup/setup-06.jpg)\n\n滚动结束后，第一次使用开发板未进行初始化设置，就无法连上外网（Internet）服务器，所以 **会闪红灯，或者红灯恒亮** 。这时请准备一台具有 WiFi 功能的电脑、手提或移动设备（手机），使用这台设备进行 Wi-Fi 搜索，连接刚刚看到为「bitXXXX」的装置( 以上述的例子就是 bit1234 )，找到该设备后，输入默认密码 **12345678** ，进行连接即可。\n\n### 步骤 2、设置 WiFi 帐号密码与显示名称\n\n*确认连接成功*后，打开浏览器 ( 建议使用 Chrome )，地址栏输入 `192.168.4.1` 会进入到 Web:Bit 开发板的设置画面，画面中包含以下几种设置：\n\n![](../../assets/webduino/education_edition/setup/upload_6e1c12f5120345e4e97d8d05d9251791.png)\n\n> 可在下图表格中找到对应设置项详细解释。\n\n![](../../assets/webduino/education_edition/setup/settings.png)\n\n设置完成后按下 **SUBMIT** 保存，出现 **SAVE OK** 的字样表示设置成功。\n\n![](../../assets/webduino/education_edition/setup/upload_3ec8cc6a377c2a2cd987be93d391da60.png)\n\n此时开发板会重启并闪烁红灯，当 **红灯熄灭** 且 **绿灯亮起** 之后，表示 Web:Bit 开发板已经成功连接上 WiFi 。\n\n![](../../assets/webduino/education_edition/setup/upload_9fc275139e019a3ba9f86d0fd133c762.gif)\n\n- 若红灯持续闪烁或恒亮，请拔掉电源，重新操作步骤 1 与步骤 2 。\n\n- 若红灯闪完后亮起「蓝灯」而不是绿灯，表示已有新版本可以进行下载更新，请参考[Web:bit 教育版 > 更新开发板固件](update.html#-1) 。\n\n![](../../assets/webduino/education_edition/setup/upload_184a8ab60565dbd34c2e4cac4a0a530b.gif)"}, "/WebBit_doc/zh/webduino/education_edition/monster/event.html": {"title": "小怪兽互动＆舞台", "content": "# 小怪兽互动＆舞台\n\n除了可以设定小怪兽的位置或大小，编辑器更能让我们与小怪兽互动，例如用鼠标点击小怪兽、小怪兽互相碰撞、碰撞舞台画面边缘...等。\n\n## 小怪兽积木清单 ( 互动＆舞台 )\n\n互动＆舞台的积木分别有鼠标点击小怪兽、鼠标触碰小怪兽、小怪兽互相碰撞、小怪兽碰撞舞台边缘、碰到舞台边缘就反弹、更换舞台背景和设定为全屏幕。\n\n![](../../../assets/webduino/education_edition/monster/event/event-01.png)\n\n## 鼠标点击\n\n「鼠标点击」积木可以在鼠标点击小怪兽时，让小怪兽做指定的事情。\n\n> 鼠标点击积木「*不需要放在循环内*」就可重复检测，并在后台执行。\n\n![](../../../assets/webduino/education_edition/monster/event/upload_bd5d493660fdf95650cfd71875b09f68.png)\n\n下图的例子，点击绿色小怪兽时会说话，点击红色小怪兽会放大，点击黄色小怪兽会旋转，点击蓝色小怪兽会改变情绪。\n\n![](../../../assets/webduino/education_edition/monster/event/event-03.gif)\n\n## 鼠标触碰\n\n「鼠标触碰」积木包含两个行为动作，分别是鼠标触碰到小怪兽要做什么事，以及鼠标离开小怪兽后要做什么事。\n\n> 注意，离开的行为动作一定会接在触碰之后，鼠标触碰积木「*不需要放在循环内*」就可重复检测。\n\n![](../../../assets/webduino/education_edition/monster/event/upload_6eee2e14f316f79216ef294e531284c1.png)\n\n下图的例子，在鼠标触碰到绿色小怪兽时，小怪兽的情绪会开心，鼠标离开后小怪兽又恢复正常的情绪。\n\n![](../../../assets/webduino/education_edition/monster/event/upload_bd4c4a7f42b86231ee1d30f7da6d1681.gif)\n\n## 互相触碰\n\n「互相触碰」积木可以检测小怪兽彼此之间是否有触碰。\n\n>「互相触碰」积木「*只会检测一次*」，必须*搭配循环*，才能重复检测。\n\n![](../../../assets/webduino/education_edition/monster/event/upload_eab6bd21822786b42a47fe7afd4e3edc.png)\n\n以下图为例，搭配「无限循环」积木就能不断检测小怪兽是否互相触碰。用鼠标拉动小怪兽，当两只小怪兽相碰时，小怪兽就变成惊讶的情绪，分开后又恢复正常。\n\n![](../../../assets/webduino/education_edition/monster/event/event-07.gif)\n\n## 触碰舞台边缘\n\n「触碰舞台边缘」积木可以检测小怪兽是否触碰到互动舞台的四个边，或指定检测碰到上、下、左、右四个边的行为。\n\n>「触碰舞台边缘」积木「*只会检测一次*」，必须*搭配循环*，才能重复检测。\n\n![](../../../assets/webduino/education_edition/monster/event/upload_d046836899bee6928e3cb4e801b7c6a2.png)\n\n以下图为例，搭配「无限循环」积木就能让小怪兽碰到舞台画面上边缘或下边缘时，变成开心的情绪，碰到左边缘或右边缘则呈现生气的情绪，没有碰到时则是正常情绪。\n\n![](../../../assets/webduino/education_edition/monster/event/event-09.gif)\n\n## 触碰舞台边缘就反弹\n\n「触碰舞台边缘就反弹」积木是「触碰舞台边缘」积木的简化版，将碰触后的行为单一化为「反弹」，反弹表示位置的相反，*如果碰到舞台左右两侧，则小怪兽移动的X 方向会相反，如果碰到舞台上下两侧，则小怪兽移动的Y 方向会相反*。\n\n>「触碰舞台边缘就反弹」积木「*只会检测一次*」，必须*搭配循环*，才能重复检测。\n\n![](../../../assets/webduino/education_edition/monster/event/upload_9cc804bee48cd25db97ef0415aa5de8d.png)\n\n以下图为例，搭配「无限循环」积木碰到舞台边缘时就会反弹。\n\n![](../../../assets/webduino/education_edition/monster/event/upload_2054073407edffc93259cee64ea8d559.gif)\n\n## 更换舞台背景颜色或图片\n\n「更换舞台背景颜色」和「更换舞台背景图片」，可以改变怪兽舞台背景为指定的颜色或图片，图片只要填入图片网址，执行后就会更换。 ( 图片支持 jpg、jpeg、png 和 gif )\n\n![](../../../assets/webduino/education_edition/monster/event/upload_a0ffebb197b6a1b7e624df95575db57e.png)\n\n举例来说，找一张[清明上河图](https://theme.npm.edu.tw/opendata/att/collectionPic/04015934/17024347.jpg#_blank)的图片网址，将网址贴上在背景图片的文字积木内，执行后就会看见舞台背景变成清明上河图了。\n\n![](../../../assets/webduino/education_edition/monster/event/upload_0a5192dcef98295928291f37dc3aa941.png)\n\n## 设定舞台为全屏幕\n\n「设定舞台为全屏幕」积木不影响任何操作，只会在「执行时」把怪兽互动舞台变成全屏幕大小。\n\n![](../../../assets/webduino/education_edition/monster/event/upload_c7f81fc1821ae721f0a1ae538cf657d7.png)\n\n如果不想使用该功能，也可以手动操作，点选怪兽互动舞台右上方的小按钮，也可以进行全屏幕的切换。\n\n![](../../../assets/webduino/education_edition/monster/event/event-15.jpg)\n\n## 取得舞台尺寸\n\n「取得舞台尺寸」积木可以取得当下怪兽互动舞台的宽度或高度。\n\n![](../../../assets/webduino/education_edition/monster/event/upload_3f0c3896ee92a0b281e3cb96344ac1f5.png)\n\n下图的例子会在执行的时候，绿色小怪兽讲出舞台宽度，红色小怪兽讲出舞台高度。\n\n![](../../../assets/webduino/education_edition/monster/event/upload_990e0968794979db21161874e12d667e.png)"}, "/WebBit_doc/zh/webduino/education_edition/monster/basic.html": {"title": "小怪兽基本操作", "content": "# 小怪兽基本操作\n\n编辑器设计了四只可爱的小怪兽，通过程序积木编排逻辑顺序，就能控制每只小怪兽的说话、声音、互动和行为等动作，甚至能进一步与实体开发板互动，做出更多好玩的有趣应用。\n\n## 小怪兽积木清单 ( 基本操作 )\n\n基本操作小怪兽的积木分别有讲话、展示图片、情绪、改变位置、改变角度、改变大小、显示隐藏和阶层...等，可以通过这些积木控制小怪兽的外在表现。\n\n![](../../../assets/webduino/education_edition/monster/basic/upload_ecaf893841c42dfab8dba2e59219b3f0.png)\n\n## 讲话＆不讲话\n\n「讲话」和「不讲话」积木可以让小怪兽讲出指定的文字，或不要讲出文字，通过下拉选单也可以选择哪一只小怪兽讲话，或所有小怪兽一起讲话。\n\n![](../../../assets/webduino/education_edition/monster/basic/upload_2e3b52771cffb4aa57eba477b5c2a786.png)\n\n只要在讲话的积木后方，连接指定的文字，执行后小怪兽就会说出指定的文字。\n\n![](../../../assets/webduino/education_edition/monster/basic/upload_705418bdeba488d8a1aac5daf3ff86f5.png)\n\n只要把文字留空，或者使用不说话的积木，就能够让小怪兽不说话。\n\n![](../../../assets/webduino/education_edition/monster/basic/upload_e559ef990c771072f48b1693c8b762b9.png)\n\n## 展示图片\n\n「展示图片」积木可以让小怪兽展示一张「网络图片」。\n\n![](../../../assets/webduino/education_edition/monster/basic/upload_b7edb18992b7d500b6902688a5b9e318.png)\n\n举例来说，从百度百科上搜寻[蒙娜丽莎]，可以得到这张图片的「[网址](https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Mona_Lisa%2C_by_Leonardo_da_Vinci%2C_from_C2RMF_retouched.jpg/460px-Mona_Lisa%2C_by_Leonardo_da_Vinci%2C_from_C2RMF_retouched.jpg#_blank)」，复制图片网址，贴到小怪兽展示图片的文字空格内，执行后，就会看见小怪兽展示这张图片。\n\n> 目前图片格式仅支持 jpg、jpeg、png、gif（图片网址结尾必须带有图片格式才能显示图片）\n\n![](../../../assets/webduino/education_edition/monster/basic/upload_0e42941e1908cd0eee54be33f33dc605.png)\n\n## 情绪\n\n「情绪」积木可以改变小怪兽的情绪，包含开心、惊讶、生气、难过和随机情绪。\n\n![](../../../assets/webduino/education_edition/monster/basic/upload_590cfe6b6bb11b37e0785e45a28d3591.png)\n\n选择对应的小怪兽 ( 也可以四只同时 )，选择对应的情绪，执行后就会看见小怪兽的情绪变化。\n\n![](../../../assets/webduino/education_edition/monster/basic/upload_1ab6008309379d6e26ac09ad81d20011.png)\n\n## 改变位置\n\n「改变位置」积木可以指定小怪兽改变*目前的位置*，选项有往上、往下、往左、往右、随机或朝向鼠标方向。\n\n![](../../../assets/webduino/education_edition/monster/basic/upload_64c0e2ae93164965ef2800de7c4d081f.png)\n\n如下图，搭配「循环十次」和「等待 0.1 秒」积木，就能够让小怪兽往右上方移动。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-10.gif)\n\n如果使用「无限循环」积木，搭配「朝着鼠标位置」的设定，就能够让小怪兽追着鼠标移动。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-11.gif)\n\n## 定位\n\n「定位」积木能够把小怪兽摆放到指定的坐标位置。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-12.png)\n\n怪兽的座标系统采用*笛卡尔直角座标系统* (直角座标系统)，往上y 为正，往右x 为正，而(0,0) *原点位在怪兽互动舞台的左下角*，指定小怪兽xy 坐标，执行后小怪兽就会出现在指定的位置。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-13.jpg)\n\n## 旋转角度\n\n「旋转角度」可以指定小怪兽改变*目前的角度*，选项有往左或往右。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-14.png)\n\n搭配「无限循环」积木，就能让小怪兽不断的每隔 0.1 秒旋转 10 度。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-15.gif)\n\n## 面朝方向\n\n「面朝方向」角度可以指定小怪兽旋转的角度，顺时针为正，逆时针为负。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-16.png)\n\n因为「面朝方向」是指定一个角度，如果要做到和前一个积木「旋转角度」一样的效果，可以使用变量搭配「无限循环」积木，在每一次执行时修改变量数值即可。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-17.gif)\n\n## 自动面朝鼠标方向\n\n「自动面朝鼠标方向」积木能让小怪兽转到鼠标所在的方向，有自动和停止两个选项。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-18.png)\n\n因为「自动面朝鼠标方向」只会执行一次，所以如果要让小怪兽不断的面向鼠标，就必须搭配无限循环的积木，如下图，执行后小怪兽就会自动面向鼠标旋转。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-19.gif)\n\n## 取得座标和角度\n\n「取得座标和角度」积木能够读取小怪兽当前的 X 座标、Y 座标和旋转角度。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-20.png)\n\n下图的例子，就能让小怪兽自己讲出自己的 X 座标、Y 座标和旋转角度。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-21.jpg)\n\n## 尺寸放大缩小\n\n「尺寸放大缩小」积木可以指定小怪兽改变*目前的大小*，选项有放大或缩小。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-22.png)\n\n搭配「循环十次」和「等待 0.1 秒」积木，执行后，就能够让小怪兽逐渐变大。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-23.gif)\n\n## 尺寸百分比\n\n「尺寸百分比」积木可以指定小怪兽放大缩小的百分比。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-24.png)\n\n由于 100% 表示原本怪兽大小，所以 200% 就会是一倍大，50% 则是会缩成 1/2 大小，下图通过尺寸百分比，分别让四只小怪兽呈现不同尺寸大小。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-25.jpg)\n\n## 显示/不显示\n\n「显示/不显示」积木可以指定小怪兽是否显示在互动舞台区。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-26.jpg)\n\n## 阶层\n\n「阶层」积木可以指定小怪兽排列的阶层，最上层在最前面，最下层在最后面。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-28.png)\n\n通过「循环」以及「等待」积木，能够让小怪兽的阶层依序显示在最前面。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-29.gif)\n\n## 回到原始状态\n\n「回到原始状态」积木可以让小怪兽回到初始状态，初始状态包含不说话、预设座标、预设旋转角度和预设尺寸大小。\n\n![](../../../assets/webduino/education_edition/monster/basic/basic-27.png)"}, "/WebBit_doc/zh/webduino/education_edition/board_function/pin_io.html": {"title": "输入 & 输出", "content": "# 输入 & 输出\n\n在 Web:Bit 开发板底部边缘有一排有 25 个金属接触点，这些金属接触点称为「引脚」，或通俗一点也可称呼「金手指」。 引脚包含了 5 个标注 0、1、2、3V 和 GND 的大引脚，以及其他 20 个未标示号码的小引脚，除了可以使用 鳄鱼夹 操作大引脚，也可以使用拓展板 搭配杜邦线操作小引脚，通过引脚的搭配，就能灵活的操作各种外接元件与传感器。\n\n## I/O 引脚对照表（以下引脚均为 pin Name,例如1为P1）\n\n![](../../../assets/webduino/education_edition/board_function/pin_io/index-04.jpg)\n\n## I/O 引脚积木清单\n\nI/O 引脚积木包含模拟（Analog）与数字（Digital ）的相关「输入」和「输出」共四种积木。\n\n![](../../../assets/webduino/education_edition/board_function/pin_io/io-pin-03.jpg)\n\n> 「I/O 引脚」积木必须搭配「开发板」积木，且并不支持模拟器，只支持 USB 与 Wi-Fi 控制。\n\n## 读取数值 ( 数字输入 )\n\n使用「数字输入」的积木，读取的数值只会有 1 和 0 两种信号，预设在完全没有接传感器的状态下数值为 1 ，「程式」积木通过一个「无限循环」的积木，不断读取引脚信号。\n\n![](../../../assets/webduino/education_edition/board_function/pin_io/io-pin-01.jpg)\n\n可以使用「杜邦线 + 面包板 + 电阻」进行测试，并通过「上拉电阻」的方法，在程式执行后，将杜邦线连接指定引脚（如 1 ）和 GND ( 接地 )，程式便会收到 0 的信号。\n\n![](../../../assets/webduino/education_edition/board_function/pin_io/io-pin-02.gif)\n\n## 读取数值 ( 模拟输入 )\n\n使用「模拟输入」的积木，读取的数值为 0 ～ 1 之间的浮点数，程式积木通过一个「无限循环」积木，不断读取引脚信号。( 模拟输入仅支持 1 号和 2 号引脚 )\n\n![](../../../assets/webduino/education_edition/board_function/pin_io/io-pin-04.jpg)\n\n可以使用「光敏电阻 + 杜邦线 + 面包板 + 电阻」进行测试，下方范例并采取「下拉电阻」的方法，在程式执行后，程式便会收到 0 ～ 1 的模拟信号，光线越强数字越大，光线越弱数字越小。\n\n![](../../../assets/webduino/education_edition/board_function/pin_io/io-pin-05.gif)\n\n## 输出数值\n\n「输出」的积木分成两种，一种是 模拟输出 ( PWM )，可以输出 0 ～ 1 之间的浮点数，另外一种是 数字输出 ，仅能输出 0 和 1 两种数值，以下方的例子而言，通过一个循环的方式调用「模拟输出」积木，不断输出 0 ～ 1 之间的浮点数作为 LED 的亮度，就能做出呼吸灯的效果。( 直接将 LED 长的一端引脚接在拓展板的 1 号引脚，短脚接在 GND )\n\n![](../../../assets/webduino/education_edition/board_function/pin_io/io-pin-06.jpg)\n\n![](../../../assets/webduino/education_edition/board_function/pin_io/io-pin-07.gif)\n\n如果使用「数字输出」积木，虽然无法设计 LED 呼吸灯的效果，但仍然可以通过「无限循环」积木，设计出灯光闪烁的范例。\n\n![](../../../assets/webduino/education_edition/board_function/pin_io/io-pin-08.jpg)\n\n![](../../../assets/webduino/education_edition/board_function/pin_io/io-pin-09.gif)"}, "/WebBit_doc/zh/webduino/education_edition/board_function/rgbled-matrix.html": {"title": "矩阵 LED ", "content": "# 矩阵 LED \n\n开发板的正中央内嵌了一个由 25 颗矩阵 LED  组成的的 LED 矩阵 ，每个 LED 都可通过红、绿、蓝三种颜色进行混合产生各种不同颜色，让指定位置的 LED 显示指定的颜色并组合，就能显示各种图案。\n\n## 矩阵 LED 积木清单\n\n矩阵 LED 积木清单包含显示颜色、关灯、绘制图案、预设图案、指定第几颗灯的颜色、跑马灯和亮度等积木。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_f63f939496f887fe4786365a69edc0fc.png)\n\n> *使用矩阵 LED 积木必须搭配「开发板」积木*，选择模拟器，执行后可以控制右侧模拟器的 LED 矩阵，选择 USB，执行后会通过 USB 连接方式控制实体开发板，选择 Wi-Fi 则可通过 Wi-Fi 指定 Device ID 操控开发板。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_a405d0e0455fd644717101c3751df0a6.png)\n\n## 显示颜色\n\n「显示颜色」积木可以让 25 颗灯同时亮起指定的颜色。 ( 若选择黑色，效果等同不亮灯 )\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_e2315998a8cfe9acedd68bec5112c70c.png)\n\n开发板选择模拟器，显示颜色积木选择红色，执行后，虚拟的开发板 25 颗灯都变成红色。 ( 若手边有开发板，可以使用 USB 或 Wi-Fi 连接控制 )\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_081903273b3fd8d4f529c88856192fe4.png)\n\n## 绘制图案\n\n「绘制图案」积木能够自定义每颗灯不同的颜色，绘制一个 5x5 的图案。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_c852f4d68838e6c5d0016e01560b9f9e.png)\n\n点击积木上方的颜色区块就能选择不同颜色，如果是同颜色，重复点击就可以还原为黑色 ( 直接使用黑色也是同样的效果 )。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_0b38e47c44fb3a3d7755e7908cea45e5.gif)\n\n例如绘制一朵花，让花瓣为红色，花梗和叶子为绿色，执行后，虚拟的开发板就会呈现一朵彩色的花。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_32a049fb957b51d0cc47af0c38baf1d1.png)\n\n## 预设图案\n\n「预设图案」积木提供 60 种预设图案，以及一个随机图案选项 ( 60 种图案随机取出一种 )。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_9b89853f2ac3a318d844980d02b42f0e.gif)\n\n选择图案和颜色，执行后，虚拟开发板就会出现对应的图案和颜色。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_5a1b8919a68c65b2b25529c2278016ea.png)\n\n## 显示一个字\n\n「显示一个字」积木可以显示*单个*大小写英文字母、数字或标点符号 ，并指定显示的颜色。 ( 不支持显示中文 )\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_d8c17706d60bfdaddf9a1997ad2ebd62.png)\n\n在文字积木输入字母或数字并指定颜色，执行后就会看到指定颜色的字母或数字出现。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_2810b8f54fbf9129c79c93a919bfa638.png)\n\n## 跑马灯\n\n「跑马灯」积木可以通过跑马灯的方式，以指定的颜色显示一串文字，跑马灯可以只进行一次或无限次重复播放，并能设定文字移动的速度。 ( 不支持显示中文 )\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_879d253f34acc1b464e08ef98965e7f9.jpg)\n\n如果设定跑马灯次数为「一次」，跑马灯积木会是「*执行完成才会继续执行后面积木程序*」的类型( 点击前方问号会提示)，*跑马灯结束后才会接着执行其他程序*，若设定为「无限次」，*后台程序会继续执行，但和LED 矩阵有关的行为会被跑马灯所取代*，使用上要特别注意。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_7b9090bfacbbbdf3801cf8f77112c4bc.png)\n\n下图的例子，执行后会先出现红色 Hello 文字的跑马灯，结束后紧接着出现绿色笑脸。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_6fbc7a9ca95c10b182cce3a2b44b1952.gif)\n\n## 矩阵 LED 控制灯号\n\n「矩阵 LED 控制灯号」积木可以控制矩阵 LED 指定灯号的运行。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_a360aaa10807f6cb8c8e2facc7445288.png)\n\n矩阵 LED 的顺序对应到 开发板的灯号顺序，开发板灯号 1~25 的顺序为从左到右、从上到下。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/rgbled-matrix-16.jpg)\n\n举例来说，若设定矩阵 LED 的三个值为红色、绿色和蓝色，开发板的第 1~3 个灯就会呈现对应的颜色。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_392fba6ea5f3fbbc97935255cdfe03de.png)\n\n如果是多维矩阵 LED ，会按照矩阵 LED 元素的顺序进行显示，若元素内容留空，该颗 LED 会呈现熄灯状态。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_249539e18180c1815e49ef8dd3e51120.png)\n\n## 第几颗灯\n\n「第几颗灯」积木可以指定第几颗灯的颜色。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_2f91b361f5363749fb2de4332e041c7b.png)\n\n第几颗灯的顺序对应到开发板的灯号顺序，开发板灯号 1~25 的顺序为从左到右、从上到下。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/rgbled-matrix-16.jpg)\n\n分别指定不同位置的灯号颜色，执行后就会看见指定位置的灯号亮起。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_670bd7d51c9f594273b0a4329f5a7511.png)\n\n## X、Y 座标控制灯号\n\n「X、Y 座标控制灯号」积木可以通过 X 和 Y 的座标值指定灯号的颜色显示。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_f467507ed38a3018e166a1a4d806ef7b.png)\n\n开发板的 X、Y 座标以左上角为 ( 1, 1 )，往右 X 加 1，往下 Y 加 1，依此类推。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/rgbled-matrix-22.jpg)\n\n分别指定不同 X、Y 的灯号颜色，执行后就会看见指定位置的灯号亮起。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_6e19592bbea111a87ba2441f6b44f05c.png)\n\n## 亮度\n\n「亮度」积木可以控制「*全部 LED 灯*」的亮度，该积木无法指定单一颗灯的亮度，亮度最暗到最亮的数值为 0 ~20，预设值 10。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_e531c3542454cd50f41475c8f89ae4f9.png)\n\n## 关灯\n\n「关灯」积木可以关闭「*全部 LED 灯*」，效果等同于把 25 颗灯的颜色同时设定为黑色。\n\n![](../../../assets/webduino/education_edition/board_function/rgbled-matrix/upload_d8f9d8823ceebcb3763d556a5b0bb4a8.png)"}, "/WebBit_doc/zh/webduino/education_edition/board_function/photocell-thermistor.html": {"title": "光线＆温度", "content": "# 光线＆温度\n\n开发板内有两个光敏传感器，以及一个热敏电阻，光敏传感器可以检测环境光线的流明数值，热敏电阻则可检测到小数点两位的温度变化，通过对光线和温度的检测，就能做出环境监控相关的应用。\n\n## 积木清单\n\n检测光线分别可以检测左上和右上的亮度变化，检测的单位为流明，数值区间为 0~1000 的整数，温度检测的单位为 ℃（摄氏度），数值可到小数点两位。\n\n![](../../../assets/webduino/education_edition/board_function/photocell-thermistor/upload_67a10398c136bfeed9a746d768e4f45a.png)\n\n> *检测光线和温度积木必须搭配「开发板」积木*，选择模拟器，执行后可以使用鼠标拖拉模拟器的灯泡或火焰。\n\n![](../../../assets/webduino/education_edition/board_function/photocell-thermistor/upload_1715ac062f8e311ec52e5f0138674042.png)\n\n## 检测光线\n\n「检测光线」积木使用时只会检测一次，搭配「无限循环」积木就能进行连续检测。\n\n\n![](../../../assets/webduino/education_edition/board_function/photocell-thermistor/upload_0be0e23afc298517fc1d3c103908efa5.png)\n\n执行后，如果是使用模拟器，*画面里会出现一个「灯泡」图案*，拉动「灯泡」靠近画面里的光敏电阻，就能模拟光线的变化，如果是使用实体开发板，可用光线照射光敏电阻观察光线变化。\n\n![](../../../assets/webduino/education_edition/board_function/photocell-thermistor/photocell-thermistor-03.gif)\n\n了解光线检测原理后，若搭配简单的「逻辑」判断，就能做出小夜灯的效果，以下图的例子而言，只要左边或右边的任何一个光敏传感器检测到亮度大于等于600 流明，就会熄灯，反之左右两边只要同时检测的数值小于600 流明就会亮白灯。\n\n![](../../../assets/webduino/education_edition/board_function/photocell-thermistor/upload_d0f3308a6f71417b07c312d0429679f1.gif)\n\n## 检测温度\n\n「检测温度」积木使用时只会检测一次，搭配「无限循环」积木就能进行连续检测。\n\n![](../../../assets/webduino/education_edition/board_function/photocell-thermistor/upload_d198ba23a25ac94a4765d49bcffad040.png)\n\n执行后，如果是使用模拟器，*画面里会出现一个「火焰」图案*，拉动「火焰」靠近画面里的热敏电阻，就能模拟温度的变化，如果是使用实体开发板，可用手指按压热敏电阻、或用嘴对着热敏电阻吹气，就能观察温度变化。\n\n![](../../../assets/webduino/education_edition/board_function/photocell-thermistor/upload_dfdc520d3406cdfc8e0a8f0a5047b29b.gif)\n\n了解温度检测原理后，若搭配简单的逻辑判断，就能做出用颜色反映温度的效果，当温度大于等于 50 度就呈现红色，反之小于 40 度就是蓝色。\n\n![](../../../assets/webduino/education_edition/board_function/photocell-thermistor/upload_08ab033663e27f5b4224f9244860c3d3.gif)"}, "/WebBit_doc/zh/webduino/education_edition/board_function/ab-button.html": {"title": "按钮开关", "content": "# 按钮开关\n\n在开发板正面的左右两侧，有两颗按钮开关，通过使用这两个开关，可以打造真实的游戏遥控器或智能家居控制的应用，更符合物联网的使用场景。\n\n## 按钮开关积木说明\n\n按钮开关积木可以指定「按下、放开、长按」三种开关行为，三种行为可分别套用到 A、B 或 A 和 B 同时操作。 ( 长按的定义为持续按下一秒 )\n\n![](../../../assets/webduino/education_edition/board_function/ab-button/upload_06284e2585e416a5ddfd913d0ca77e09.jpg)\n\n> *使用按钮开关积木必须搭配「开发板」积木*，选择模拟器，执行后就可以使用鼠标点击模拟器上的按键，选择 USB，执行后会通过 USB 连接方式控制实体开发板，选择 Wi-Fi 则可通过Wi-Fi 指定 Device ID 操控开发板。\n\n![](../../../assets/webduino/education_edition/board_function/ab-button/upload_029e0e6306c329860727021f5db13f2f.jpg)\n\n## 按下开关改变 LED 矩阵图案\n\n在编辑画面放入按下A、按下B 和按下A+B 的积木，接着分别在各自的区块内放入LED 矩阵显示图形的积木，执行后，如果是使用模拟器，就可以用滑鼠点击 A 、B 或 A+B 按钮查看变化效果，如果是使用实体开发板，则可以直接用手指按压开关。\n\n> 模拟器里的 A+B 按钮开关，只有在编辑画面有 A+B 按钮开关的积木时才会出现。\n\n![](../../../assets/webduino/education_edition/board_function/ab-button/upload_11fe6d329a7e69cc40c5499d13512724.gif)\n\n## 按下、放开和长按\n\n通过开关的按下、放开和长按三种行为，就能做出「按下时有图案，变成长按后图案会变色，最后放开开关就会关灯」的范例，执行后，如果是使用模拟器，就可以用鼠标点击 A 按钮查看变化效果，如果是使用实体开发板，则可以直接用手指按压开关。\n\n![](../../../assets/webduino/education_edition/board_function/ab-button/upload_2bc8f9ecd689421f9d4a0d8dfb538eb3.gif)"}, "/WebBit_doc/zh/webduino/education_edition/board_function/buzzer.html": {"title": "音乐＆声音", "content": "# 音乐＆声音\n\n开发板内有一个微型蜂鸣器，可以发出三个八度音阶的单一声响，通过不同音符代码的组合，或者搭配内置的范例音乐，就能让开发板发出各种美妙的旋律。\n\n## 音乐＆声音积木清单\n\n音乐＆声音的积木包含演奏某个音阶、休息、预设音乐和停止演奏...等积木。\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/upload_d81f8c3e1d6daeb5fc4f33be0b754585.png)\n\n> *音乐＆声音积木必须搭配「开发板」积木*，选择模拟器，执行后可以听见电脑喇叭发出声音，选择USB，执行后会通过USB 连接方式控制实体开发板，让开发板的蜂鸣器发出声音。\n\n## 演奏音阶\n\n「演奏音阶」积木可以演奏三个八度音阶，同时亦可指定每个音阶的拍子，拍子分为 1/16、1/8、1/4、1/2、1 和 2 拍。\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/upload_c9fa8b5fa500b5fb755c1633c03bce49.jpg)\n\n点选音阶的选项会弹出一个虚拟的钢琴键盘，使用鼠标移到琴键上，电脑的喇叭就会发出对应的声响。\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/upload_46fe754af544df24c66e0910e7f2f19c.gif)\n\n在音阶的缺口，可以分别放入「音阶」和「休止符」积木，后面的缺口只能放入「拍子」积木。\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/upload_027f5c26da138c9ce4971dd4532c8178.png)\n\n放入好几个音阶，执行后可以听到一个音阶接着一个音阶播放。\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/upload_2e3c85ed2d24bf38109c154dd60bd828.gif)\n\n由于「演奏音阶」积木会是「*演奏完成才会继续执行后方程序*」的类型，若程序放在音阶之后，在所有音阶演奏完成后，才会执行后面程序。\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/upload_92adfef7e8a7b2e550d142129807d807.gif)\n\n「演奏音阶」积木也可以搭配「无限循环」积木，做到不断重复播放一段旋律的效果。\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/upload_5f262a6ff6b57814d1c4f418f1425e17.gif)\n\n「音阶」积木指出数组的使用，根据数组的排列组合，就能自行编辑音乐并重复使用，下图的例子，分别将音阶和拍子独立成两个数组。\n\n> 使用「数组」的情况下，若音阶数量少于拍子，多出来的拍子会采用最后一个音阶播放，若拍子数量少于音阶，多出来的音阶会采用最后一个拍子播放。\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/upload_55969f257d9c76d8d2a7c66414e0c373.png)\n\n## 演奏休息\n\n「演奏休息」积木表示该拍子没有声音，等同于使用「演奏音阶」积木搭配「休止符」积木。\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/upload_553dd18457d0c23e596671b25ece4fc2.png)\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/upload_599ca13a4d02c7810f3c1b90a53530c2.gif)\n\n## 演奏音乐\n\n「演奏音乐」积木包含超级玛丽、超级玛丽和弦、真善美、哥哥爸爸真伟大和小叮当五首音乐，可以独立使用或搭配「音阶」积木使用。\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/upload_1a9af3f10689c6827d63128096f46e0d.png)\n\n由于「演奏音乐」积木会是「*演奏完成才会继续执行后面程序*」的类型，若有音阶或其他程序放在演奏音乐之后，音乐演奏完成后，才会执行后面的程序。\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/upload_03b4c735d2fcf7d21b04c430c96f3766.gif)\n\n## 停止/暂停/继续演奏\n\n「停止/暂停/继续演奏」积木可以控制音乐演奏的行为。\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/upload_1ab3917e21aed65cd39b6e0dfab6d380.png)\n\n下图的例子通过开发板的按钮开关控制音乐播放，A 和 B 同时按下时开始播放，播放进行中按下 A 就会暂停，按下 B 就会继续播放。\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/buzzer-14.gif)\n\n如果要将「音乐」、「音阶拍子」积木混合控制，在切换音乐之前加入「停止播放」积木，就可完全停止现有的音乐并进行切换。\n\n![](../../../assets/webduino/education_edition/board_function/buzzer/upload_ebad84f9b0d0904fe82e662ec2d62282.png)"}, "/WebBit_doc/zh/webduino/education_edition/board_function/board.html": {"title": "开发板", "content": "# 开发板\n\n这里提供了三种控制开发板的方式，分别是「模拟器」、「USB」和「Wi-Fi」，模拟器能够在没有硬件的情况下模拟硬件，USB 可以在没有网络的情况下，通过 USB 连接操控。而Wi-Fi 则可以进行无线远程操控板子，通过三种不同操控方式的互相搭配，可以在各种场景下控制开发板。\n\n![](../../../assets/webduino/education_edition/board_function/board/upload_a305960c5d3186e1705fbd0719edd5dc.jpg)\n\n## 使用方式\n\n下拉选单选择「模拟器」，表示*使用右侧的「虚拟开发板」*，开发板积木里所有能控制的元件，都会和右侧的虚拟开发板对应，例如绘制一个图案，执行后，虚拟开发板就会显示图形。\n\n![](../../../assets/webduino/education_edition/board_function/board/upload_ed5475fb209b45ed098fe98244184228.jpg)\n\n下拉选单选择「USB」，表示*使用「USB 线」连接「开发板」*，**必须使用「编辑器（安装版）」操作**，例如绘制一个图案，执行后，通过 USB 连接的开发板就会显示图案。\n\n> 「编辑器（安装版）请参考：[编辑器介绍](../info/software.html)\n\n![](../../../assets/webduino/education_edition/board_function/board/board-03.jpg)\n\n下拉选单选择「Wi-Fi」，表示*使用「Wi-Fi」连接「开发板」*，也就是通过**每块开发板的 Device ID 进行控制**，只要知道 Device ID，不论开发板身在何处，都能远程操控。\n\n> 开发板 Device ID 请参考：[开发板设置](../info/setup.html)\n\n![](../../../assets/webduino/education_edition/board_function/board/board-04.jpg)\n\n## 控制多块开发板\n\n编辑器可*同时控制多块开发板*，只需要在编辑画面里放入开发板，指定开发板的操控方式，执行后就会看到所有开发板同时发生变化，下图的例子，在同一个编辑画面里，让一块模拟器开发板和两块Wi-Fi 开发板，同时呈现花朵图案。\n\n> 多块开发板 *最多只能包含一块「模拟器」开发板和一块「USB」开发板，「Wi-Fi」开发板则没有数量限制*。\n\n![](../../../assets/webduino/education_edition/board_function/board/board-05.jpg)\n\n在控制多块开发板的情况下，**不支持使用函数控制**，要特别注意！\n\n![](../../../assets/webduino/education_edition/board_function/board/upload_d910330f4e5dadc186b69c21c4ff8645.png)\n\n但不可以在多个开发板中使用 函数 控制硬件外设，如下图。\n\n![](../../../assets/webduino/education_edition/board_function/board/upload_ea4ff5dace7523836f3e5e57283affda.png)\n\n因此若是想要做到同样的效果，此时的做法应该要如下：\n\n![](../../../assets/webduino/education_edition/board_function/board/board-07.png)"}, "/WebBit_doc/zh/webduino/education_edition/board_function/mpu9250.html": {"title": "运动 & 姿态", "content": "# 运动 & 姿态\n\n开发板内有一个MPU-9250 九轴传感器，除了可以检测空间内的加速度与旋转，用作体感检测、体感游戏...等应用之外，更能通过磁力计的辅助检测，实现检测姿态角度、指南针...等应用。\n\n## 九轴体感检测积木清单\n\n九轴体感检测积木有两种，一种可检测指定的动作，另一种则可取得九轴感测器的数值。\n\n![](../../../assets/webduino/education_edition/board_function/mpu9250/upload_18c7a52b17ac3acd71b2e3e17dace35c.png)\n\n> *九轴体感检测积木必须搭配「开发板」积木*，选择模拟器时无法取得九轴体感数值，但可以通过指定动作的按钮模拟对应动作，选择USB，执行后会通过 USB 连接方式控制实体开发板，选择 Wi-Fi 则可通过 Wi-Fi 指定 Device ID 操控。\n\n![](../../../assets/webduino/education_edition/board_function/mpu9250/upload_0cc551d1867973ce68e94649ceaba3ab.png)\n\n## 检测指定的动作\n\n「检测指定的动作」积木能检测静止、晃动、正面朝上、背面朝上、向后向前翻转、向左向右翻转、向左向右旋转、指向东西南北...等14 种开发板动作。\n\n![](../../../assets/webduino/education_edition/board_function/mpu9250/mpu9250-03.jpg)\n\n下图的例子，开发板往右旋转会出现向右的绿色箭头，开发板往左旋转会出现向左的蓝色箭头，如果开发板晃动则会出现红色笑脸。\n\n![](../../../assets/webduino/education_edition/board_function/mpu9250/upload_53b4a76c4c94b0f3c80d1a2a84509995.png)\n\n如果是使用模拟器，执行后再开发板的右侧会出现一排按钮，并用文字提示正在检测的指定动作，以上图的例子而言，表示正在检测向右旋转、向左旋转以及晃动。\n\n![](../../../assets/webduino/education_edition/board_function/mpu9250/20190806100154.png)\n\n## 取得九轴传感器的数值\n\n「取得九轴传感器的数值」积木能够取得加速度、磁力计、陀螺仪以及水平旋转、前后左右翻转的数值。 ( *模拟器无法模拟此块积木，必须使用实体开发板* )\n\n![](../../../assets/webduino/education_edition/board_function/mpu9250/20190806100231.png)"}, "/WebBit_doc/zh/webduino/education_edition/introduction.html": {"title": "", "content": "![](../../assets/webduino/education_edition/introduction/editor.png)\n\nWeb:Bit 是 Webduino Bit 开发板的缩写，Web:Bit 教育版是由 Webduino 与台湾许多优秀的信息化教育的教师们，共同合作研发出的一款用于 STEAM 课堂的教学套件。\n\n下面介绍一下积木编辑器相关文档目录。\n\n![](../../assets/webduino/education_edition/introduction/menu.png)\n\n想知道更多？可以点击目录继续往下阅读。\n\n\n**相关链接**\n\n- [Web:Bit 中文社区](https://forum.banana-pi.org.cn/c/bpi-bit)\n- [Web:Bit 英文社区](http://forum.banana-pi.org/c/bpi-bit)\n- [Webduino 国内版](https://webduino.com.cn)\n- [Webduino 国际版](https://webduino.io/)"}, "/WebBit_doc/zh/webduino/education_edition/sound/sound-effect.html": {"title": "特殊音效", "content": "# 特殊音效\n\n在「播放 XX 音效」积木中内置了许多有趣的特殊音效，里头包含了动物音效、环境音效、人类生活音效...等，使用不同音效和小怪兽、开发板组合，就能实现许多丰富的应用。\n\n## 积木清单\n\n特殊音效分成三个项目，分别是动物、人声和特殊音效。\n\n![](../../../assets/webduino/education_edition/sound/upload_01ae1bf1b04810c7cb106aab9bdabf91.jpg)\n\n## 点击小怪兽发出音效\n\n搭配「点击小怪兽」积木，点击执行后，用鼠标点击小怪兽就会发出对应的特殊音效。\n\n![](../../../assets/webduino/education_edition/sound/upload_f34f3980273799bfb98a1058ece8e423.png)\n\n## 替小怪兽的反弹加入音效\n\n点选右上方选单「范例」，打开范例清单。\n\n![](../../../assets/webduino/education_edition/sound/upload_1010989345dc7e884addd9c63c571e1a.png)\n\n打开范例清单后，开启基础操作里的「小怪兽移动时碰到边缘反弹」。\n\n![](../../../assets/webduino/education_edition/sound/upload_6288679620bdf7de696162aeb65f8e45.png)\n\n开启范例后，找到「当绿色怪兽碰到舞台画面的四边缘」选择在积木中加入，并在执行的区域内加入特殊音效，执行后，当绿色怪兽碰到画面边缘时，就会发出特殊音效。\n\n![](../../../assets/webduino/education_edition/sound/upload_b9ab26b295f96de6e39a2c3e54f09697.png)"}, "/WebBit_doc/zh/webduino/education_edition/sound/speech-recognition.html": {"title": "语音识别", "content": "# 语音识别\n\n随着科技的技术日新月异，过去在行动装置才能使用的语音辨识功能，如今编辑器也能完整实现，结合Google 语音辨识的技术，如果电脑有麦克风，就能轻松做出「Hey Siri」或「OK Google」的有趣声控效果。\n\n## 语音辨识积木说明\n\n语音辨识积木可以分别识别中文和英文的语言，无法进行中英文夹杂的混合辨识。\n\n![](https://raw.githubusercontent.com/junhuanchen/test_repository/master/bpi-web/tutorials/images/zh_tw/docs/webbit/sound/speech-recognition-01.jpg)\n\n语音辨识积木属于「*执行完成才会继续执行后方程序*」的类型 ( 点击前方问号小图示会提示 )，每段语音辨识时间为两秒，*辨识后才会继续执行后方的程序*。\n\n![](https://raw.githubusercontent.com/junhuanchen/test_repository/master/bpi-web/tutorials/images/zh_tw/docs/webbit/sound/speech-recognition-02.jpg)\n\n## 透过小怪兽显示语音辨识文字\n\n进行语音辨识之后，就能使用「辨识的文字」积木，下图的范例会在语音辨识后，让小怪兽讲出辨识的文字。\n\n![](https://raw.githubusercontent.com/junhuanchen/test_repository/master/bpi-web/tutorials/images/zh_tw/docs/webbit/sound/speech-recognition-03.jpg)\n\n使用语音辨识积木时，如果是「网页版」的编辑器，在网页执行后会询问「是否允许使用麦克风」，勾选允许。\n\n![](https://raw.githubusercontent.com/junhuanchen/test_repository/master/bpi-web/tutorials/images/zh_tw/docs/webbit/sound/speech-recognition-04.jpg)\n\n网页允许麦克风后，在浏览器页签上会出现一个小圆点，提示麦克风正在运作。\n\n![](https://raw.githubusercontent.com/junhuanchen/test_repository/master/bpi-web/tutorials/images/zh_tw/docs/webbit/sound/speech-recognition-05.jpg)\n\n此时可以对着麦克风讲话，语毕就能看见小怪兽讲出辨识的文字。\n\n![](https://raw.githubusercontent.com/junhuanchen/test_repository/master/bpi-web/tutorials/images/zh_tw/docs/webbit/sound/speech-recognition-06.jpg)\n\n## 连续语音辨识\n\n藉由语音辨识积木的特性，搭配重复回圈，就能不断进行语音辨识来更新小怪兽讲出的文字。\n\n![](https://raw.githubusercontent.com/junhuanchen/test_repository/master/bpi-web/tutorials/images/zh_tw/docs/webbit/sound/speech-recognition-08.gif)\n\n## 语音辨识控制 开发板\n\n如果将语音辨识结合 开发板，搭配逻辑判断判断文字内包含的字词，就能实现物联网声控的应用，下图的例子便可以很简单的透过声控开关灯，或透过声控改变颜色。\n\n![](https://raw.githubusercontent.com/junhuanchen/test_repository/master/bpi-web/tutorials/images/zh_tw/docs/webbit/sound/speech-recognition-09.gif)"}, "/WebBit_doc/zh/webduino/education_edition/sound/speak-aloud.html": {"title": "语音朗读", "content": "# 语音朗读\n\n语音朗读是通过电脑的语音合成器，念出我们指定的语言，教育版的语音朗读可以轻松做出语音报时器、语音通知、语音对话...等创意应用，更可以调整语音的速度和音调，变化出许多有趣的花样。\n\n## 积木说明\n\n语音朗读积木包含三种语 ( 中文、英文或日文 )，五种音调和五种速度。\n\n> 注意，*在「安装版」编辑器中，可能无法正常朗读中文和日文*，若遇到无法发音的状况，请使用「网页版」版本的编辑器。 ( 参考 [编辑器](../index.html#software) )\n\n![](https://raw.githubusercontent.com/junhuanchen/test_repository/master/bpi-web/tutorials/images/zh_tw/docs/webbit/sound/speak-aloud-01.jpg)\n\n语音朗读积木属于「*执行完成才会继续执行后方程序*」的类型( 点击前方问号小图示会提示)，当程序中使用了语音朗读积木，*朗读结束后才会接着执行其他程序*，使用上要特别注意。\n\n![](https://raw.githubusercontent.com/junhuanchen/test_repository/master/bpi-web/tutorials/images/zh_tw/docs/webbit/sound/speak-aloud-02.jpg)\n\n## 朗读文字\n\n若要朗读文字，只需要在后方文字积木输入对应的文字，网页执行后就能从电脑喇叭听到语音。\n\n![](https://raw.githubusercontent.com/junhuanchen/test_repository/master/bpi-web/tutorials/images/zh_tw/docs/webbit/sound/speak-aloud-03.jpg)\n\n## 朗读不同段落的文字\n\n如果要朗读不同段落的文字，第一种方法可使用建立字串积木，配合变量积木，在网页执行后就会从电脑喇叭听到语音。\n\n![](https://raw.githubusercontent.com/junhuanchen/test_repository/master/bpi-web/tutorials/images/zh_tw/docs/webbit/sound/speak-aloud-04.jpg)\n\n第二种方法可以通过使用语音朗读积木的特性，将不同段落的文字依序接在后方，网页执行后再朗读完第一段，就会接着朗读第二段。\n\n![](https://raw.githubusercontent.com/junhuanchen/test_repository/master/bpi-web/tutorials/images/zh_tw/docs/webbit/sound/speak-aloud-05.jpg)\n\n## 朗读输入的文字\n\n由于「在对话框中输入文字」和语音朗读积木特性相同，搭配重复回圈，就能做到通过语音朗读，念出输入的文字。\n\n![](https://raw.githubusercontent.com/junhuanchen/test_repository/master/bpi-web/tutorials/images/zh_tw/docs/webbit/sound/speak-aloud-06.jpg)"}, "/WebBit_doc/zh/webduino/education_edition/software.html": {"title": "编辑器介绍", "content": "# 编辑器介绍\n\nWeb:Bit 编辑器是 Webduino 的学习积木编程的软件，积木编程大幅简化了编写代码的步骤流程，并添加了**虚拟仿真开发板**、**小怪兽互动舞台**、**外接拓展硬件**等许多积木供你玩耍。不论是大朋友小朋友，都可以轻松的入门 Web:Bit 。\n\n## 什么是积木编程？\n\n对于第一次接触的人来说，可能不太清楚「积木编程」的由来，「积木」是翻译自「block」这个英文单词，其操作方式类似「组装积木」或「拼图」的概念，通过互相堆叠和搭配组合，就能判断不同的逻辑或依据指定的排列顺序，实现对应的程序动作。\n\n![](../../assets/webduino/education_edition/software/upload_307159386b586670a14bf1f5ec5fc23a.gif)\n\n## 编辑器类型\n\n![](../../assets/webduino/education_edition/software/upload_be9e4f1e27a719fed2161c1c19409f4e.png)\n\n编辑器分为 **网页版** 和 **安装版**，功能与界面几乎完全相同，可以依据不同的教学场景需求采用不同的版本。\n\n### 网页版\n\n使用基于 Google Chrome 内核的浏览器即可体验积木编程，注意网页版暂不支持「USB 连接」开发板。\n\n> 网页版链接：[webbit.webduino.io](https://webbit.webduino.io/blockly/?lang=zh-hans)\n\n### 安装版\n\n> 安装版下载：[WebBitSetup_x.x.x.exe](https://banana-pi.dev/Image/BPI-BIT/)\n\n**安裝版**目前只提供 Windows 7 以上的系统版本，界面与网页版保持一致，还能够更方便的初始化设置和使用「USB 连接」开发板。\n\n## 操作界面说明\n\n编辑器的操作界面分成下列几类区域：\n\n- **主功能菜单**：包含文件的打开与保存、范例和教学、清空、更多功能和执行。\n- **积木/程序代码切换**：将拼接好的积木转换为标准 Javascript 代码。\n- **积木列表**：包含基本功能、小怪兽控制、开发板控制和物联网拓展...等积木。\n- **积木编辑区**：进行积木的逻辑组合，产生各种不同的场景应用。\n- **开发板模拟器**：包含一块虚拟的开发板，可以模拟开发板的实际状况和应用。\n- **小怪兽互动舞台**：包含四种不同造型和颜色的小怪兽，可以通过积木设定相关动作和互动。\n- **缩放按钮**：能够快速缩放画面积木或删除积木。\n- **画面折叠按钮**：可以折叠开发板模拟器和小怪兽互动区，让积木编辑区域放大或缩小。\n\n![](../../assets/webduino/education_edition/software/upload_f63b41003e28555aeff8f6ee16471391.png)\n\n## 如何使用编辑器？\n\n编辑器是基于 Google 所开发出的 Blockly 图形化编程工具，下面我们演示一下使用进行编程的效果。\n\n![](../../assets/webduino/education_edition/software/upload_33a9b73ee3cbdf221b611e0931b75774.gif)\n\n每块积木都有它对应的功能和用途，如果想了解该积木的使用方式，可以「**使用鼠标在指定的积木上单击右键**」，就能打开积木的功能列表，点击「**教学**」可以阅读该积木的教学文件，如果该积木有「**小工具**」，则可以点击小工具使用更多进阶功能。\n\n![](../../assets/webduino/education_edition/software/upload_c4c6cdc0de1c91c2558cffd94e90b0f3.png)\n\n## 积木使用小技巧\n\n### 小技巧 1、多行与单行输入\n\n如果积木程序太长，可以用鼠标在积木上点击右键，且该积木支持多行输入，可以选择「**多行输入**」将积木由单行变成多行，也更方便阅读和编辑。\n\n![](../../assets/webduino/education_edition/software/upload_8230ecfcdec22e4763e6c91d52a10fe5.gif)\n\n### 小技巧 2、整理积木\n\n在使用积木编程的时候，往往会遇到积木四面八方散落在积木编辑区上的状况，这时可以在编辑区域上点击右键，选择「**整理积木**」将积木排列整齐。\n\n![](../../assets/webduino/education_edition/software/upload_0a5eafe50dec64e3e2d6fa239253f3cc.gif)\n\n## 网页版独有功能\n\n右上方的主功能菜单，包含编辑器的主要功能，但「**网页版**」和「**安装版**」编辑器的菜单略有不同。\n\n### 分享链接\n\n在网页版可以使用「**文件> 分享**」，分享可以帮助我们保存积木分享给他人，它会产生一段「**网址**」，下次再开启这个网址就可以载入分享的积木，但是安装版无法使用该功能。\n\n![](../../assets/webduino/education_edition/software/upload_d3033bfde0425d6e16c1858a89b2ae85.png)\n\n在网页版主菜单的「**更多**」里面，包含「**下载安装**」的选项，点击后会下载安装版的压缩文件，解压缩安装就可以使用安装版。 ( 目前安装版编辑器仅支持 Windows )\n\n![](../../assets/webduino/education_edition/software/upload_90807bd259b8c6159aad92f7686fd0ee.png)\n\n## 安装版菜单说明\n\n打开安装版之后工具列里分别有「*系统*」、「*工具*」和「*信息*」三个主要功能列表，如果你没有出现下图的工具列，可以按下电脑键盘的 *`Ctrl + W`* 打开工具列，。\n\n![](../../assets/webduino/education_edition/software/toolbar-01.gif)\n\n### 系统 > 通过浏览器打开\n\n点选「通过浏览器打开」，会自动打开电脑的 Chrome 浏览器并连接至编辑器（网页版），如果没有该选项，请下载安装 [Chrome 浏览器](https://www.google.cn/intl/zh-CN/chrome/) 到系统里。\n\n### 工具 > 关闭 USB 连接\n\n如果开发板使用 USB 线 连接到电脑，安装版可以在没有 Wi-Fi 的状态下控制开发板，但此时开发板也将「关闭 Wi-Fi 连接功能」，如果要开启开发板的 Wi-Fi 连接功能，则需关闭安装版程序，或是点击「关闭 USB 连接」功能。\n\n> *如果关闭 USB 连接，开发板就会采用 Wi-Fi 连接模式，反之开启 USB 连接就会关闭 Wi-Fi 连接功能*。\n> 详细操作方式会在[「开发板功能」](../board/board.html) 介绍使用方法。\n>\n\n![](../../assets/webduino/education_edition/software/upload_8d9b6d8facf9d70b7d06e22b1aa48757.png)\n\n### 工具 > 恢复出厂固件\n\n可以解决开发板大部分疑难杂症，并回到初始状态。\n\n![](../../assets/webduino/education_edition/software/20190801094352.png)\n\n> 恢复出厂固件可以参考 [更新固件方法 1：使用安装版进行更新 > 恢复出厂固件](update.html#-2)\n\n### 工具 > 设置 Web:Bit WiFi\n\n该功能帮助开发板连接网络，如果没有 Wi-Fi 控制开发板的需求，可以不需要使用该功能，点击该选项之后，会要求我们输入 Wi-Fi 的 SSID 和 密码，这功能可以帮助我们将「WIFI 路由器」的 Wi-Fi 名称（SSID） 和 密码 设置到开发板中。\n\n> *特别提醒！如果无法使用该功能*，**需要恢复出厂固件**。\n> 详细设定步骤可以参考 [「开发板设置」](setup.html)\n> 恢复出厂固件可以参考 [更新固件方法 1：使用安装版进行更新 > 恢复出厂固件](update.html#-2)\n>\n\n![](../../assets/webduino/education_edition/software/upload_5adc4e1cd8a9aad3325832e39268ddc2.png)\n\n![](../../assets/webduino/education_edition/software/upload_6606fc470897e6ba6c2a2d06470c96ac.png)\n\n### 工具 > 设置 Web:bit MQTT 服务器\n\n在这之前请先配置开发板的 WIFI 连接到路由器，这将为开发板配置 Web:bit 无线控制的外网服务器，外网就是指互联网（广域网）。\n\n如果想要在外网的环境（如咖啡厅的 WIFI 网络）下 控制 连接到家里 WIFI 的开发板（家里的 WIFI 必须能够上网浏览网页）。\n\n这就需要设置 MQTT 服务器的地区，如中国或全球（不同地区的服务器不能互联），此时使用开发板 WIFI 连接即可在外网控制。\n\n### 工具 > 更新固件\n\n如果软件提示开发板有新版本的固件，可以点击该选项进行固件更新。\n\n> *特别提醒！如果无法使用该功能*，**需要恢复出厂固件**，可以参考 [更新固件方法 1：使用安装版进行更新 > 恢复出厂固件](update.html#-2)。\n\n![](../../assets/webduino/education_edition/software/upload_2eb67fe4b80aa5bed56f592eddc5fb2c.png)\n\n### 信息 > 版本、复制设备 ID、帮助\n\n版本功能会显示目前的固件版本，复制设备 ID 可以将开发板的 Device ID 复制出来，而帮助会显示安装版支持的各种快捷键。\n\n![](../../assets/webduino/education_edition/software/upload_0cf91b296511f8a9f78812a9d5abed9f.png)"}, "/WebBit_doc/zh/webduino/install&use.html": {"title": "Web:Bit 软件安装&使用方法", "content": "# Web:Bit 软件安装&使用方法\n\n测试环境：Win10 家庭版 & WIN7 基础版\n\n## 第一步，安装编程软件 \n\n[点击链接](https://banana-pi.dev/Image/BPI-BIT/WebBitSetup.exe) 下载软件。\n\n### win10\n\n![](../assets/webduino/install&use/20190821221729518.png)\n\n![](../assets/webduino/install&use/20190821221755367.png)\n\n点击保存，然后打开软件位置，安装软件即可。\n  \n![](../assets/webduino/install&use/2019082122181136.png)\n\n提示信息，可以忽略。（Win7 无提醒）\n\n![](../assets/webduino/install&use/20190821221831358.png)\n\n点击“仍要运行”进行安装。\n\n![](../assets/webduino/install&use/20190821221843878.png)\n\n点击“OK”。\n\n![](../assets/webduino/install&use/20190821221856411.png)\n\n点击“安装”，等待安装。\n\n![](../assets/webduino/install&use/20190821221911873.png)\n\n安装成功，如下图，点击“完成”，软件就安装成功了。\n\n![](../assets/webduino/install&use/2019082122192570.png)\n\n### Win7\n\n使用 360 浏览器下载软件。\n\n![](../assets/webduino/install&use/20190826160348541.png)\n\n下载完成打开\n\n![](../assets/webduino/install&use/2019082616040324.png)\n\n安装\n\n![](../assets/webduino/install&use/20190826160423616.gif)\n\n返回桌面就可以看到 Web：Bit 软件了\n\n![](../assets/webduino/install&use/20190826160442604.png)\n\n## 第二步，安装有线驱动\n\n打开链接 [安装驱动](../getting_started/driver.html) 进入教程，或点击左侧目录 安装驱动 。\n\n![](../assets/webduino/install&use/20190821221938626.png)\n\n点击”CH341SER Win 系统驱动”，下载驱动。\n\n![](../assets/webduino/install&use/20190821221951728.png)\n\n点击保存，打开文件位置，如下：\n\n![](../assets/webduino/install&use/20190821222005699.png)\n\n解压 CH341SER 文件\n\n![](../assets/webduino/install&use/20190821222015105.png)\n\n\n点击“SETUP”，进行驱动安装。\n\n![](../assets/webduino/install&use/20190821222033464.png)\n\n点击“安装”即可\n\n![](../assets/webduino/install&use/20190821222046881.png)\n\n## 第三步，有线连接板子\n\n用 USB 数据线连接 BIT 板后，打开设备管理器，显示USB-SERIAL-CH340（COMX），这说明你已经成功安装驱动了。\n\n![](../assets/webduino/install&use/20190821222103591.png)\n\n双击“webBit”图标，打开软件，如下。\n\n![](../assets/webduino/install&use/20190822171849507.png)\n\n点击“允许访问”。\n\n接下来就可以使用 BIT 板子开始积木编程了。\n\n## 第四步，使用积木编程\n\n### 载入范例体验\n\n打开 Web:Bit 看到整个界面\n\n![](../assets/webduino/install&use/2019082616050744.png)\n\n点击右上角范例,可以看到右下方小怪兽变化\n\n![](../assets/webduino/install&use/2019082616051813.gif)\n\n接下来看下模拟开发板的效果\n\n![](../assets/webduino/install&use/20190826160537525.gif)\n\n### 控制实体开发板\n\n使用 USB 线连接\n\n![](../assets/webduino/install&use/20190826160548329.jpg)\n\n打开软件看右上方是否连接成功 \n\n![](../assets/webduino/install&use/20190826160623634.png)\n\n一直出现扫描 USB 设备则需恢复出厂固件。\n\n![](../assets/webduino/install&use/20190826160633551.png)\n\n更新完成后，需要设置服务器为中国 \n\n![](../assets/webduino/install&use/20190826160644567.PNG)\n\n就能连接成功使用了，更多使用方法请继续往下看吧。"}, "/WebBit_doc/zh/webduino/modules/basic.html": {"title": "使用方法", "content": "# 使用方法\n\n## 载入拓展积木\n\n>   教育版暂不支持导入拓展积木\n    请在标准环境下进行[Webduino Blockly 标准版](https://bit.webduino.com.cn/blockly/)。\n\n在这里你将体验到 Webduino 的额外拓展功能，更多第三方的功能模块可以在开源社区中获得。\n\n\n> 以此示例模板为例：[webduino-blockly-template](https://bpi-steam.com/webduino-blockly-template/) 。\n\n进入 [ webduino blockly Bit ](https://bit.webduino.com.cn/blockly/?lang=zh-hans)。\n\n![](../../assets/webduino/modules/basic/0.png)\n\n点击左下角的 菜单键（设置） 然后可以看到 使用自有积木。\n\n![](../../assets/webduino/modules/basic/1.png)\n\n在该框粘贴拓展 `https://bpi-steam.com/webduino-blockly-template/blockly.json` 地址并点击 汇入 即可。\n\n![](../../assets/webduino/modules/basic/2.png)\n\n汇入成功，再次点击 左下角的 × 返回主页吧。\n\n![](../../assets/webduino/modules/basic/3.png)\n\n此时你可以在主页的菜单们看到它们了。\n\n![](../../assets/webduino/modules/basic/4.png)\n\n## 载入使用范例\n\n> 标准的积木示例中应该提供 blockly.xml 供他人参考和使用。\n\n如果提供的示例积木，可以通过下载项目的 demos/blockly.xml 文件并导入。\n\n![](../../assets/webduino/modules/basic/5.png)\n\n选择文件后，点击汇入即可载入使用范例。\n\n![](../../assets/webduino/modules/basic/6.png)\n\n可以看到如下效果\n\n![](../../assets/webduino/modules/basic/7.png)\n\n可以点击右上角运行按钮，运行查看效果。\n\n![](../../assets/webduino/modules/basic/8.png)\n\n修改一下提问参数，再次运行得到新的结果。\n\n![](../../assets/webduino/modules/basic/9.png)\n\n如果想要自己制作和设计积木，可以参考[**开发者文档**](../../../../WebBit_dev/zh/)。"}, "/WebBit_doc/zh/index.html": {"title": "WebBit 使用手册", "content": "# WebBit 使用手册\n\nBPI-STEAM 是专注于软硬件开源技术的开源组织，属于[Banana-Pi](http://www.banana-pi.org)的分支，从 2018 年起推出 BPI-BIT 开发板，随之推出 Webduino 、 MicroPython 、 Arduino 等开源技术支持，通过使用手册能够让用户轻松入门 BPI-STEAM 所提供的技术产品。\n\n>本文档托管于属于[BPI-STEAM](https://github.com/BPI-STEAM)开源组织。\n\n## 认识 BPI-BIT 开发板\n\nBPI-BIT 是一款基于 ESP32 高性能芯片且兼容 micro:bit 设计的开源 STEAM 教育开发板，又名 Bpi:Bit、Web:Bit 。\n\n![](assets/_static/bit.png)\n\n## 使用 Webduino 编程\n\n通过 Web:Bit 专用积木编辑器，使用拖拽积木来轻松学习编程。\n\n![](assets/_static/editor.png) \n\n\n## 使用 MicroPython 编程\n\n通过烧写 MicroPython 固件，就可以在开发板中使用 Python 语言进行编程。\n\n将提供丰富的示例代码以及专业 IDE 的支持（如：VsCode、PyCharm）。\n\n![](assets/_static/micropython_LOGO.jpg)\n\n## 使用 Arduino 编程\n\n提供了入门 Arduino 的软件工具和最佳示例，降低进入 ESP32 嵌入式专业开发的门槛。\n\n![](assets/_static/Arduino_logo.png)\n\n>Arduino 将不会阐述过多基础内容，请具备 C/C++ 的语言开发基础。"}, "/WebBit_doc/zh/getting_started/driver.html": {"title": "驱动安装", "content": "# 驱动安装\n\n为什么需要安装驱动，根据百度百科定义，驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作。\n\n因此，若是有需要专业开发硬件的用户，可以参考本文进行电脑驱动的安装，没有这种需要的话，可以跳过本文。\n\n## 连接板子\n\n板子采用 CH340 / CH341 串口驱动芯片，可以轻松的在 Windows 、 Linux 、macOS 等系统下自动安装驱动。\n\n> [CH341SER Win 系统驱动](http://www.wch.cn/downloads/file/5.html)\n>\n> [CH341SER 其他系统驱动](https://blog.csdn.net/jazzsoldier/article/details/70169732)\n>\n\n将板子通过 MicroUSB 线连接到你的电脑里，以下以 Windows 10 为例。\n\n![](../assets/getting_started/driver/connect.gif)\n\n## 查看驱动\n\n进入 **设备管理器** 确认串口驱动（Serial）是否安装，进入方法如下。\n\n- （右键）此电脑 -> 属性 -> **设备管理器**\n- 开始菜单 -> （输入）**设备管理器**\n- 控制面板 -> （搜索）**设备管理器**\n\n![](../assets/getting_started/driver/error.png)\n\n可以看到 设备显示 **USB2.0-Serial** ，说明**未安装驱动**，若此前已安装驱动，可以跳至步骤 5 。\n\n## 安装驱动\n\n点此获取 [Serial CH341](http://www.wch.cn/downloads/file/5.html) 驱动，并按如下说明操作安装驱动\n\n打开下载的 **CH341SER.ZIP** 压缩包，进入 **CH341SER** 文件夹，打开 **SETUP.EXE**，即可看到如下图。\n\n![](../assets/getting_started/driver/install.png)\n\n点击 **INSTALL** （安装），等待片刻即可完成安装。\n\n## 确认串口\n\n核对板子是否连接成功\n\n![](../assets/getting_started/driver/success.png)\n\n可以看到原来的 **USB2.0-Serial** 消失了，取而代之的是 **USB-SERIAL CH340(COM3)**，这意味着你已经成功安装驱动，并且得到板子串口名称为（**COM3**），你可以通过各种串口工具来查看串口名（COM3）的板子传出的信息。\n\n## 其他系统\n\n### macOS 安装\n\n- [CH340 macOS 驱动使用教程](https://blog.csdn.net/jazzsoldier/article/details/70171771)\n\n### Linux 安装\n\n- 官方 linux Kernel2.6 以后默认自带，也可在[此处下载](http://www.wch.cn/download/CH341SER_LINUX_ZIP.html)。"}, "/WebBit_doc/zh/getting_started/hardware.html": {"title": "开发板介绍", "content": "# 开发板介绍\n\n> 以下内容介绍硬件 1.4 版，编辑日期 2019年7月24日。\n\nBpi:Bit 又名 Web:Bit ，是 Webduino 的专用开发板，采用 ESP-WROOM-32 （ESP32）模组作为核心，拥有 Wi-Fi & Bluetooth 无线功能，支持多设备协同控制，更是内置了许多的传感器，用户可以轻松体验到开发的无穷乐趣。\n\n## 正面与背面\n\n![](../assets/getting_started/hardware/upload_9ca0f2e8545e2835e9b0a8b5ae0c1330.png)\n\nWeb:Bit 外观长约 5 公分，宽约 5 公分，重量约 10 ~ 12 公克，带 25 颗 LED 灯为正面（图左侧），反之为是背面（图右侧）。\n\n![](../assets/getting_started/hardware/upload_51dd835e8e65108c6f4edee97babc922.png)\n\n## 尺寸规格图\n\n![](../assets/getting_started/hardware/upload_f43892b83561e0fbb5be54cd4b288b08.png)\n\n## 矩阵 LED 定义\n\nWeb:Bit 按照 5 * 5 排列方式焊接了 25 颗(编号 0 ~ 24 ) 1600 万色矩阵 LED (WS2812) ，所有的 LED 的控制仅使用一个引脚 (GPIO 4) 即可控制。\n\n![](../assets/getting_started/hardware/upload_7fe376a15b4393441c58b84f052f8bb4.png)\n\n## 底部金手指定义\n\n在 Web:Bit 的底部具有一排 25 Pin 的「金手指」接口，其定义如下。\n\n**注意：背面的金手指未连接硬件，所以无法使用**\n\n![](../assets/getting_started/hardware/upload_4545d093f0c3899da1495995597ec383.png)\n\n![](../assets/getting_started/hardware/upload_ca07897451dd2440025709b70978f2f4.png)\n\n## 内置传感器定义\n\nWeb:Bit 搭载了 25 颗矩阵 LED ，两个光敏传感器、两个按钮开关、一个热敏电阻、一个无源蜂鸣器和一个九轴传感器（分别为三轴加速度、三轴陀螺仪与三轴磁力计）对应引脚如下：\n\n![](../assets/getting_started/hardware/table.png)\n\n## 相关硬件资料\n\n- [BPI-WEBDUINO-BIT-V1_2](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/BPI-WEBDUINO-BIT-V1_2.pdf)\n\n- [BPI-WEBDUINO-BIT-V1_4](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/BPI-WEBDUINO-BIT-V1_4.pdf)\n\n- [Buzzer-SS-S050020Z-120](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/Buzzer-SS-S050020Z-120.pdf)\n\n- [CH340DS1-ch](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/CH340DS1-ch.pdf)\n\n- [CH340DS1-en](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/CH340DS1-en.pdf)\n\n- [esp32_hardware_design_guidelines_en](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/esp32_hardware_design_guidelines_en.pdf)\n\n- [ESP32-datesheet_english](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/ESP32-datesheet_english.pdf)\n\n- [esp-wroom-32_datasheet_cn](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/esp-wroom-32_datasheet_cn.pdf)\n\n- [LightSensor-PTSMD021-0805](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/LightSensor-PTSMD021-0805.pdf)\n\n- [LM1117](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/LM1117.pdf)\n\n- [MPU-9250 Datasheet-v1.1-ch](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/MPU-9250%20Datasheet-v1.1-ch.pdf)\n\n- [MPU-9250 Datasheet-v1.1-en](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/MPU-9250%20Datasheet-v1.1-en.pdf)\n\n- [MPU-9250 Register Map-v1.6](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/MPU-9250%20Register%20Map-v1.6.pdf)\n\n- [NTC-0805-103F-3950F](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/NTC-0805-103F-3950F.pdf)\n\n- [SY7208](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/SY7208.pdf)\n\n- [WS2812B](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/WS2812B.pdf)\n\n- [DS-000189-ICM-20948-v1.3](https://github.com/BPI-STEAM/BPI-BIT-Hardware/tree/master/docs/DS-000189-ICM-20948-v1.3.pdf)"}}